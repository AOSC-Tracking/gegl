%h{
#include "gegl-object.h"

#ifndef __TYPEDEF_GEGL_NODE__
#define __TYPEDEF_GEGL_NODE__
typedef struct _GeglNode  GeglNode;
#endif

typedef enum
{
   GEGL_NODE_VISIT_ENABLED = 1 << 0,
   GEGL_NODE_VISIT_DISABLED = 1 << 1,
   GEGL_NODE_VISIT_ALL = GEGL_NODE_VISIT_ENABLED | GEGL_NODE_VISIT_DISABLED,
   GEGL_NODE_VISIT_MASK = 0x03 
} GeglNodeVisitFlags;

typedef gboolean 
(*GeglNodeTraverseFunc)(GeglNode *node, gpointer data);

%}
%{
#include "gegl-node.h"
#include "gegl-node-private.h"
#include "gegl-object-private.h"
#include <stdio.h>
%}

class Gegl:Node from Gegl:Object {

  private GList    *inputs;         /*inputs*/
  private gint      num_inputs;     /*fixed for life of node, for now*/ 
  private GList    *outputs;        /*outputs, all these share this node  */
  private gint      alt_input;      /*a way to pass through this node*/
  private gboolean  enabled;        /*whether node is enabled.*/
  private gboolean  visited;        /*flag for traversals*/ 
  private gboolean  discovered;     /*flag for traversals*/ 
  private gchar    *name;           /*name for the node*/


  /**
   * constructor:
   * @self: a #GeglNode.
   * @inputs: #GeglNode list.
   *
   * Initializes a #GeglNode.
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self,
              GList *inputs)
  {
    g_return_val_if_fail (!(GEGL_OBJECT(self)->constructed), FALSE);
       
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    self->_priv->inputs = NULL;

    /* Copy the list of inputs and data pointers,
       then ref the inputs */

    add_inputs(self,inputs);
    self->_priv->num_inputs = g_list_length(self->_priv->inputs);
    self->_priv->outputs = NULL;
    self->_priv->visited = TRUE;
    self->_priv->discovered = TRUE;
    self->_priv->name = g_strdup(gtk_type_name(GTK_OBJECT_TYPE(self)));
    self->_priv->alt_input = 0;
    self->_priv->enabled = TRUE;

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Frees memory allocated by this object.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglNode *self = GEGL_NODE(object);
    g_return_if_fail (object != NULL);

    /* Free inputs list and name, outputs should
       be free already */
    remove_inputs(self);
    g_free(self->_priv->name);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * unlink:
   * @self: a #GeglNode.
   * 
   * Unlink this node from any outputs. Loops through the outputs list and
   * removes this node from each.
   *
   **/ 
  public 
  void
  unlink(self)
  {
    GList *llink;

    /* Loop through my outputs */
    llink = self->_priv->outputs;
    while(llink)
    {
      GeglNode *output = (GeglNode *)(llink->data);

      /* Find me in this output's input list */
      GList *ll = g_list_find(output->_priv->inputs, self);

      /* Set that data to NULL */
      ll->data = NULL;

      /* Unref me */
      gegl_object_unref(GEGL_OBJECT(self));

      llink = g_list_next(llink);
    }

    /* Free output list links now */
    g_list_free(self->_priv->outputs);
    self->_priv->outputs = NULL;
  }


  /**
   * get_name:
   * @self: a #GeglNode.
   *
   * Gets the name of the node.
   * 
   * Returns: name of node.
   **/
  public 
  gchar * 
  get_name(self)
  {
    return self->_priv->name;
  }


  /**
   * set_name:
   * @self: a #GeglNode.
   * @name: set name to this.
   *
   * Sets the name of the node.
   * 
   **/
  public 
  void 
  set_name(self, 
           gchar *name)
  {
    self->_priv->name = g_strdup(name);
  }


  /**
   * get_inputs:
   * @self: a #GeglNode.
   *
   * Gets the inputs list of the node.
   * 
   * Returns: #GeglNode list of inputs.
   **/
  protected 
  GList * 
  get_inputs(self)
  {
    return self->_priv->inputs;
  }


  /**
   * get_outputs:
   * @self: a #GeglNode.
   *
   * Gets the outputs list of the node.
   * 
   * Returns: #GeglNode list of outputs. 
   **/
  protected 
  GList * 
  get_outputs(self)
  {
    return self->_priv->outputs;
  }


  /**
   * set_nth_input:
   * @self: a #GeglNode.
   * @input: the node to make the nth input.
   * @n: which input.
   * 
   * Sets the nth input of the node.
   *
   * Returns: the #GeglNode that was set.
   **/
  public
  GeglNode *
  set_nth_input(self,
                GeglNode * input,
                gint n)
  {
    GList *llink;
    GeglNode *old_input; 
    g_return_val_if_fail (n >=0 && n < self->_priv->num_inputs, NULL);

    /* Get the nth link and the old input */
    llink = g_list_nth(self->_priv->inputs, n);
    old_input = (GeglNode *)llink->data; 

    /* Remove the old input */
    /*llink->data = NULL;*/ 

    /* Remove ref of the old input, fix its output list */
    if(old_input)
      remove_output(old_input,self);

    /* Put the new input in this link */
    llink->data = (gpointer)input; 

    /* Ref the new input, fix its output list */
    if(input)
      add_output(input,self);

    return input;
  } 


  /**
   * get_nth_input:
   * @self: a #GeglNode.
   * @n: which input.
   * 
   * Gets the nth input of the node.
   *
   * Returns: a #GeglNode, the nth input of this node.
   **/
  public
  GeglNode *
  get_nth_input(self,
                gint n)
  {
    g_return_val_if_fail (n >=0 && n < self->_priv->num_inputs, NULL);
    return (GeglNode *)g_list_nth_data(self->_priv->inputs,n);
  } 


  /**
   * get_nth_output:
   * @self: a #GeglNode.
   * @n: which output.
   *
   * Gets the nth output of the node.
   * 
   * Returns: a #GeglNode, the nth input of this node.
   **/
  public
  GeglNode *
  get_nth_output(self,
                 guint n)
  {
    g_return_val_if_fail (n >=0 && n < num_outputs(self), NULL);
    return (GeglNode *)g_list_nth_data(self->_priv->outputs,n);
  }
         

  /**
   * add_inputs:
   * @self: a #GeglNode.
   * @list: list of inputs.
   *
   * Makes @list the new inputs list and removes the old inputs list.
   * 
   **/
  private
  void
  add_inputs(self,
             GList *list)
  {
    GList *llink;

    if(self->_priv->inputs)
      remove_inputs(self);

    /* Allocates links and copies data pointers */
    self->_priv->inputs = g_list_copy(list);

    /* Loop through the inputs, add me as an output */
    llink = self->_priv->inputs;
    while(llink)
      {
        GeglNode *input = (GeglNode*)(llink->data);

        /* Add me to the outputs list of this input */
        if(input)
          add_output(input,self);

        llink = g_list_next(llink);
      }
  }


  /**
   * remove_inputs:
   * @self: a #GeglNode.
   *
   * Removes the current inputs list.
   * 
   **/
  private
  void
  remove_inputs(self)
  {
    GList *llink = self->_priv->inputs;
    while(llink)
      {
        GeglNode *input = (GeglNode*)(llink->data);

        /* Remove me as an output of this input */
        if(input)
          remove_output(input,self);

        llink = g_list_next(llink);
      }

    /* Remove the list of inputs */
    g_list_free(self->_priv->inputs);

    self->_priv->inputs = NULL;
  }


  /**
   * add_output:
   * @self: a #GeglNode.
   * @output: a #GeglNode to add to output list.
   * 
   * Adds @output to the node's outputs list. 
   *
   * Returns: the added #GeglNode. 
   **/
  private 
  GeglNode *
  add_output(self,
             GeglNode *output)
  {
    g_return_val_if_fail (output != NULL, NULL);
    g_return_val_if_fail ((output_multiplicity(self,output)+1 == 
                       input_multiplicity(output,self)), NULL);

    /* Add the output to the list */
    self->_priv->outputs = g_list_prepend(self->_priv->outputs,
                                         (gpointer)output);

    /* ref me, since I am gaining an output */
    gegl_object_ref(GEGL_OBJECT(self));

    return output;
  } 


  /**
   * remove_output:
   * @self: a #GeglNode.
   * @output: a #GeglNode to remove from outputs list.
   *
   * Removes @output from the node's outputs list.
   * 
   **/
  private 
  void
  remove_output(self,
                GeglNode *output)
  {
    g_return_if_fail (output != NULL);
    g_return_if_fail ((output_multiplicity(self,output) == 
                       input_multiplicity(output,self)));

    /* Remove one occurence of this output */
    self->_priv->outputs = g_list_remove(self->_priv->outputs, 
                                         (gpointer)output);

    /* unref me, since I am losing an output */
    gegl_object_unref(GEGL_OBJECT(self));
  }


  /**
   * node_multiplicity:
   * @self: a #GeglNode.
   * @list: list to use.
   * @node: a #GeglNode to look for on @list.
   *
   * Finds the multiplicity of @node on @list. That is, how many times @node
   * appears on @list.
   *
   * Returns: Number of times @node is on @list. 
   **/
  private 
  gint 
  node_multiplicity(self,
                    GList *list,
                    GeglNode *node)
  {
    GList * occurence = list;
    gint multiplicity = 0;

    while (occurence != NULL) 
    {
      occurence = g_list_find(occurence, (gpointer)node);
      if(occurence != NULL)  
      {
         multiplicity++;
         occurence = occurence->next;
      }
    } 

    return multiplicity;
  }


  /**
   * input_multiplicity:
   * @self: a #GeglNode.
   * @input: a #GeglNode to look for.
   *
   * Finds the multiplicity of @input on the node's inputs list.  That is, how
   * many times @input appears on the inputs list.
   *
   * Returns: How many times @input is on the inputs list. 
   **/
  public
  gint  
  input_multiplicity(self,
                     GeglNode *input)
  {
    return node_multiplicity(self, self->_priv->inputs, input);
  }


  /**
   * output_multiplicity:
   * @self: a #GeglNode.
   * @output: a #GeglNode to look for.
   *
   * Finds the multiplicity of @input on the node's outputs list.  That is, how
   * many times @output appears on the outputs list.
   *
   * Returns: How many times @output is on the outputs list. 
   **/
  public 
  gint  
  output_multiplicity(self,
                      GeglNode *output)
  {
    return node_multiplicity(self, self->_priv->outputs, output);
  }


  /**
   * is_leaf:
   * @self: a #GeglNode.
   *
   * Tests to see if the node is a leaf node. A leaf node has no inputs. 
   *
   * Returns: TRUE if is a leaf. 
   **/
  public
  gboolean
  is_leaf(self) 
  {
    return (num_inputs(self) == 0) ? TRUE: FALSE;
  }


  /**
   * is_root:
   * @self: a #GeglNode.
   *
   * Tests to see if the node is a root node. A root node has no outputs.
   *
   * Returns: TRUE if it is a root. 
   **/
  public
  gboolean
  is_root(self)
  {
    return (num_outputs(self) == 0) ? TRUE: FALSE;
  }


  /**
   * num_inputs:
   * @self: a #GeglNode.
   *
   * Gets the number of inputs.
   *
   * Returns: number of inputs. 
   **/
  public
  gint 
  num_inputs(self)
  {
    return self->_priv->num_inputs;
  }


  /**
   * get_alt_input:
   * @self: a #GeglNode.
   *
   * Gets the index of input to use instead of this node.  Allows traversals to
   * pass through this node if not enabled or if looking for a particular kind of
   * node. 
   *
   * Returns: the input's index to use instead of this node. 
   **/
  public
  gint 
  get_alt_input(self)
  {
    return self->_priv->alt_input;
  }


  /**
   * get_enabled:
   * @self: a #GeglNode.
   *
   * Gets whether this node is enabled. 
   *
   * Returns: TRUE if this node is enabled. 
   **/
  public
  gboolean 
  get_enabled(self)
  {
    return self->_priv->enabled;
  }


  /**
   * set_enabled:
   * @self: a #GeglNode.
   *
   * Sets whether this node is enabled. 
   *
   **/
  public
  void
  set_enabled(self,
              gboolean enabled)
  {
    self->_priv->enabled = enabled;
  }


  /**
   * num_outputs:
   * @self: a #GeglNode.
   *
   * Gets the number of outputs.
   *
   * Returns: number of outputs. 
   **/
  public
  gint 
  num_outputs(self)
  {
    return g_list_length(self->_priv->outputs);
  }


  /**
   * init_traversal:
   * @self: a #GeglNode.
   *
   * Sets visited and discovered flags to FALSE for this node and all
   * descendants.
   *
   **/
  private 
  void
  init_traversal(self)
  {
    GList *llink;

    /* Set the visited and discovered flags false */
    self->_priv->visited = FALSE; 
    self->_priv->discovered = FALSE; 

    llink = self->_priv->inputs;

    /* Call init_traversal on my inputs */
    while(llink)
      {
        GeglNode *node = (GeglNode *)llink->data;
        if(node)
          init_traversal(node);
        llink = g_list_next(llink);
      }
  } 


  /**
   * traverse_depth_first:
   * @self: a #GeglNode.
   * @visit_func: function to call on each node.
   * @data: data to pass to each node.
   * @init: init every descendant of this node. 
   *
   * Traverse the graph depth-first from this node through all descendants. 
   *
   **/
  public 
  void
  traverse_depth_first(self,
                       GeglNodeTraverseFunc visit_func,
                       gpointer data,
                       gboolean init)
  {
    GeglNode *node;
    GList *llink;

    /* If its the first node, init everything below it */
    if(init)
      init_traversal(self);

    /* Then visit all the inputs first */
    llink = self->_priv->inputs;
    while(llink)
      {
        node = (GeglNode *)llink->data;
        if(node && !node->_priv->visited)
            traverse_depth_first(node, visit_func, data, FALSE);

        llink = g_list_next(llink);
      }

    /* Visit me last */
    visit_func(self,data);
    self->_priv->visited = TRUE;
  } 


  /**
   * traverse_breadth_first:
   * @self: a #GeglNode.
   * @visit_func: function to call on each node.
   * @data: data to pass to each node.
   *
   * Traverse the graph breadth-first from this node through all descendants. 
   *
   **/
  public
  void
  traverse_breadth_first(self,
                         GeglNodeTraverseFunc visit_func,
                         gpointer data)
  {
    GList *queue = NULL; 
    GList *first;

    /* Init all nodes under this one to unvisited */
    init_traversal(self);  

    /* Initialize the queue with me */
    queue = g_list_append(queue,(gpointer)self);
    
    /* Mark me as "discovered" */
    self->_priv->discovered = TRUE;

    /* Pop the top of the queue*/
    while((first = g_list_first(queue)))
      {
        /* Get the inputs of this node */
        GeglNode * node = (GeglNode *)(first->data);
        GList * llink = node->_priv->inputs;

        /* Delete this one from top of queue */
        queue = g_list_remove_link(queue,first);
        g_list_free_1(first);

        /* Loop through inputs and add to end of 
           queue if not discovered */
        while(llink)
          {
            GeglNode * input = (GeglNode *)llink->data;
            
            /* Add any undiscovered input to the queue at end,
               but skip any null nodes */
            if (input && !input->_priv->discovered)
              {
                queue = g_list_append(queue,(gpointer)input);

                /* Mark it as discovered */
                input->_priv->discovered = TRUE;
              }

            /* Next input */
            llink = g_list_next(llink);
          }

        /* Visit the node */
        visit_func(node,data);
        node->_priv->visited = TRUE;
      }
  }

}
