%h{
#include "gegl-point-op.h"
#include "gegl-image-buffer.h"
#include "gegl-types.h" 
%}
%{
#include "gegl-composite-op.h"
#include "gegl-composite-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h> 
%}

class Gegl:Composite:Op from Gegl:Point:Op {

  private GeglCompositeMode 	comp_mode;  			/* composite mode */

  public 
  GeglCompositeOp *
  new  (GeglImageBuffer *dest,
        GeglImageBuffer *src, 
        GeglRect *dest_rect,
        GeglRect *src_rect, 
        GeglCompositeMode mode,
        gboolean premult)
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src, dest_rect, src_rect, mode, premult))
      return FALSE;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest,
              GeglImageBuffer * src,  
              GeglRect *dest_rect,
              GeglRect * src_rect,
              GeglCompositeMode mode,
              gboolean premult)
  {
    GeglColorModel              *dest_cm, *src_cm;
    gint                        dest_num_channels, src_num_channels;
    gboolean                    dest_has_alpha, src_has_alpha;
    gboolean                    dest_is_premult, src_is_premult;
    GeglImageBuffer             *image_buffers[2];
    GeglRect                    rects[2];
	
    GeglCompositeOpPrivate *selfP = 
	(GeglCompositeOpPrivate *)(self->_priv); 
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    image_buffers[0] = dest;
    image_buffers[1] = src;
    rects[0].x = dest_rect->x;
    rects[0].y = dest_rect->y;
    rects[0].w = dest_rect->w;
    rects[0].h = dest_rect->h;
    rects[1].x = src_rect->x;
    rects[1].y = src_rect->y;
    rects[1].w = src_rect->w;
    rects[1].h = src_rect->h;

    /* Chain up */
    if (!gegl_point_op_constructor (GEGL_POINT_OP(self), image_buffers, rects, 2))
      return FALSE;

    /*
      Now based on the image buffer(s) color model(s)/data storage
      choose one of our scanline funcs to install
      This is where some "autogeneration" happens.
    */ 
	
    /*
      Get memory for the dest and src pointer array
      Plus set the scanline function depending on if the cm of dest and src
      has alpha or not
    */   
    dest_cm = gegl_image_buffer_color_model (dest);
    dest_num_channels =  gegl_color_model_num_channels (dest_cm);
    dest_has_alpha = gegl_color_model_has_alpha (dest_cm);
    dest_is_premult = gegl_color_model_is_premultiplied (dest_cm);

    src_cm = gegl_image_buffer_color_model (src);
    src_num_channels =  gegl_color_model_num_channels (src_cm);
    src_has_alpha = gegl_color_model_has_alpha (src_cm);
    src_is_premult = gegl_color_model_is_premultiplied (src_cm);

    if ( premult)	
    {
      if ( dest_has_alpha && src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_premult_RGBA_op_premult_RGBA_FLOAT;
      else if ( !dest_has_alpha && !src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGB_op_RGB_FLOAT;
      else if ( dest_has_alpha && !src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_premult_RGBA_op_RGB_FLOAT;
      else if ( !dest_has_alpha && src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGB_op_premult_RGBA_FLOAT;
    }
    else
    {
      if ( dest_has_alpha && src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGBA_op_RGBA_FLOAT;
      else if ( !dest_has_alpha && !src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGB_op_RGB_FLOAT;
      else if ( dest_has_alpha && !src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGBA_op_RGB_FLOAT;
      else if ( !dest_has_alpha && src_has_alpha )
        point_op_class->scanline_func = gegl_composite_op_RGB_op_RGBA_FLOAT;
    }
    /* set comp mode */ 	
    selfP->comp_mode = mode;

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  premult_RGBA_op_premult_RGBA_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *dest_a, *src_r, *src_g, *src_b, *src_a;
    gfloat               a, b;
    gfloat              *src_data[4], *dest_data[4];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv); 

    GeglOp *op = GEGL_OP (point_op); 
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv); 

	
    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[0],
                    (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[1],
                    (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
    dest_a = (gfloat*) dest_data[3];
 
    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];
    src_a = (gfloat*) src_data[3];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
          *dest_a++ = *src_a++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          a = 1.0 - *src_a;
          *dest_r++ = a * *dest_r + *src_r++;
          *dest_g++ = a * *dest_g + *src_g++;
          *dest_b++ = a * *dest_b + *src_b++;
          *dest_a++ = a * *dest_a + *src_a++;
        } 
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          *dest_r++ = *src_r++ * *dest_a;
          *dest_g++ = *src_g++ * *dest_a;
          *dest_b++ = *src_b++ * *dest_a;
          *dest_a++ = *src_a++ * *dest_a;  
        }
      break;
      case COMPOSITE_OUT:
        while (width--)
        {
          a = 1.0 - *dest_a;
          *dest_r++ = a * *src_r++;
          *dest_g++ = a * *src_g++;
          *dest_b++ = a * *src_b++;
          *dest_a++ = a * *src_a++;  
        }
      break;
      case COMPOSITE_XOR:
        while (width--)
        {
          a = 1.0 - *dest_a;
          b = 1.0 - *src_a; 
          *dest_r++ = a * *src_r++ + b * *dest_r;
          *dest_g++ = a * *src_g++ + b * *dest_g;
          *dest_b++ = a * *src_b++ + b * *dest_b;
          *dest_a++ = a * *src_a++ + b * *dest_a;
        }
      break;
      case COMPOSITE_ATOP:
        while (width--)
        {
          a = 1.0 - *src_a++; 
          *dest_r++ = a * *dest_r + *dest_a * *src_r++;
          *dest_g++ = a * *dest_g + *dest_a * *src_g++;
          *dest_b++ = a * *dest_b + *dest_a * *src_b++;
           dest_a++;
        }
      break;
      case COMPOSITE_PLUS:
        while (width--)
        {
          *dest_r++ += *src_r++;
          *dest_g++ += *src_g++;
          *dest_b++ += *src_b++;
          *dest_a++ += *src_a++;
        }
      break;
      default:
      break;
    }	
  }
 
  private
  void
  premult_RGBA_op_RGB_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *dest_a, *src_r, *src_g, *src_b;
    gfloat               a;
    gfloat              *src_data[3], *dest_data[4];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv);

    GeglOp *op = GEGL_OP (point_op);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);


    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[0],
                    (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[1],
                    (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
    dest_a = (gfloat*) dest_data[3];

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
          *dest_a++ = 1.0;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
          *dest_a++ = 1.0;
        }
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          *dest_r++ = *src_r++ * *dest_a;
          *dest_g++ = *src_g++ * *dest_a;
          *dest_b++ = *src_b++ * *dest_a++;
        }
      break;
      case COMPOSITE_OUT:
        while (width--)
        {
          a = 1.0 - *dest_a;
          *dest_r++ = a * *src_r++;
          *dest_g++ = a * *src_g++;
          *dest_b++ = a * *src_b++;
          *dest_a++ = a;
        }
      break;
      case COMPOSITE_XOR:
        while (width--)
        {
          a = 1.0 - *dest_a;
          *dest_r++ = a * *src_r++;
          *dest_g++ = a * *src_g++;
          *dest_b++ = a * *src_b++;
          *dest_a++ = a;
        }
      break;
      case COMPOSITE_ATOP:
        while (width--)
        {
          *dest_r++ = *dest_a * *src_r++;
          *dest_g++ = *dest_a * *src_g++;
          *dest_b++ = *dest_a * *src_b++;
           dest_a++;
        }
      break;
      case COMPOSITE_PLUS:
        while (width--)
        {
          *dest_r++ += *src_r++;
          *dest_g++ += *src_g++;
          *dest_b++ += *src_b++;
          *dest_a++ += 1.0;
        }
      break;
      default:
      break;
    }  
  }

  private
  void
  RGB_op_premult_RGBA_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b, *src_a;
    gfloat               a, b;
    gfloat              *src_data[4], *dest_data[3];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv);

    GeglOp *op = GEGL_OP (point_op);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);


    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[0],
                    (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                    opP->image_buffers[1],
                    (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];
    src_a = (gfloat*) src_data[3];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          a = 1.0 - *src_a++;
          *dest_r++ = a * *dest_r + *src_r++;
          *dest_g++ = a * *dest_g + *src_g++;
          *dest_b++ = a * *dest_b + *src_b++;
        }
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OUT:
        while (width--)
        {
          *dest_r++ = 0.0;
          *dest_g++ = 0.0;
          *dest_b++ = 0.0;
        }
      break;
      case COMPOSITE_XOR:
        while (width--)
        {
          b = 1.0 - *src_a++;
          *dest_r++ *= b;
          *dest_g++ *= b;
          *dest_b++ *= b;
        }
      break;
      case COMPOSITE_ATOP:
        while (width--)
        {
          a = 1.0 - *src_a++;
          *dest_r++ = a * *dest_r + *src_r++;
          *dest_g++ = a * *dest_g + *src_g++;
          *dest_b++ = a * *dest_b + *src_b++;
        }
      break;
      case COMPOSITE_PLUS:
        while (width--)
        {
          *dest_r++ += *src_r++;
          *dest_g++ += *src_g++;
          *dest_b++ += *src_b++;
        }
      break;
      default:
      break;
    }  
  }

  private
  void
  RGBA_op_RGBA_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *dest_a, *src_r, *src_g, *src_b, *src_a;
    gfloat              a, b, c;
    gfloat              *src_data[4], *dest_data[4];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv);

    GeglOp *op = GEGL_OP (point_op);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);


    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[0],
                  (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[1],
                  (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
    dest_a = (gfloat*) dest_data[3];

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];
    src_a = (gfloat*) src_data[3];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
          *dest_a++ = *src_a++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          a = (1.0 - *src_a) * *dest_a;
          b = *src_a++;
          *dest_a   = a + b;
          if(*dest_a)
          {
            c = 1.0 / *dest_a++;
            *dest_r++ = (a * *dest_r + b * *src_r++) * c;
            *dest_g++ = (a * *dest_g + b * *src_g++) * c;
            *dest_b++ = (a * *dest_b + b * *src_b++) * c;
          }
          else
          {
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
             dest_a++; 
             src_r++;
	     src_g++;
             src_b++;
          }
        }
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          *dest_a *= *src_a++;
          if(*dest_a++){
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
          }else{
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
             src_r++;
             src_g++;
             src_b++;
          }
        }
      break;
      case COMPOSITE_OUT:
      while (width--)
        {
          *dest_a = (1.0 - *dest_a) * *src_a++;
          if(*dest_a++){
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
          } else {
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
             src_r++;
             src_g++;
             src_b++;
          }
        }
      break;
      case COMPOSITE_XOR:
      while (width--)
      {
        a = (1.0 - *dest_a) * *src_a;
        b = (1.0 - *src_a++) * *dest_a;
        *dest_a = a + b;
        if(*dest_a){
          c = 1.0 / *dest_a++;
          *dest_r++ = (a * *src_r++ + b * *dest_r) * c;
          *dest_g++ = (a * *src_g++ + b * *dest_g) * c;
          *dest_b++ = (a * *src_b++ + b * *dest_b) * c;
        } else {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
           dest_a++;
           src_r++;
           src_g++;
           src_b++;
        } 
      }
      break;
      case COMPOSITE_ATOP:
      while (width--)
      {
        a = 1.0 - *dest_a;
        if(*src_a){
          *dest_r++ = a * *dest_r + *dest_a * *src_r++;
          *dest_g++ = a * *dest_g + *dest_a * *src_g++;
          *dest_b++ = a * *dest_b + *dest_a * *src_b++;
        } else {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
           src_r++;
           src_g++;
           src_b++;
        } 
        *dest_a++ = *src_a++; 
      }
      break;
      case COMPOSITE_PLUS:
      while (width--)
      {
        *dest_r++ += *src_r++;
        *dest_g++ += *src_g++;
        *dest_b++ += *src_b++;
        *dest_a++ =  (*dest_a + *src_a++) * .5;
      }
    break;
    default:
    break;
    }
  }
  private
  void
  RGBA_op_RGB_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *dest_a, *src_r, *src_g, *src_b;
    gfloat              *src_data[3], *dest_data[4];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv);

    GeglOp *op = GEGL_OP (point_op);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);


    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[0],
                  (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[1],
                  (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
    dest_a = (gfloat*) dest_data[3];

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          *dest_a++ = 1.0;  
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          if(*dest_a++){
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
          }else{
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
            src_r++;
            src_g++;
            src_b++;
          }
        }
      break;
      case COMPOSITE_OUT:
      while (width--)
        {
          *dest_a = (1.0 - *dest_a);
          if(*dest_a++){
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
          } else {
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
            src_r++;
            src_g++;
            src_b++;
          }
        }
      break;
      case COMPOSITE_XOR:
      while (width--)
      {
        *dest_a = (1.0 - *dest_a);
        if(*dest_a++){
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        } 
        else 
        {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
           dest_a++;
           src_r++;
           src_g++;
           src_b++;
        } 
      }
      break;
      case COMPOSITE_ATOP:
      while (width--)
      {
          *dest_r++ = *dest_a * *src_r++;
          *dest_g++ = *dest_a * *src_g++;
          *dest_b++ = *dest_a * *src_b++;
          *dest_a++ = 1;
      }
      break;
      case COMPOSITE_PLUS:
      while (width--)
      {
        *dest_r++ += *src_r++;
        *dest_g++ += *src_g++;
        *dest_b++ += *src_b++;
      }
      break;
      default:
      break;
    }
  }
  
  private
  void
  RGB_op_RGBA_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b, *src_a;
    gfloat              a, b;
    gfloat              *src_data[4], *dest_data[3];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv);

    GeglOp *op = GEGL_OP (point_op);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);


    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[0],
                  (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[1],
                  (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];
    src_a = (gfloat*) src_data[3];

    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          a = (1.0 - *src_a);
          b = *src_a++;
          *dest_r++ = a * *dest_r + b * *src_r++;
          *dest_g++ = a * *dest_g + b * *src_g++;
          *dest_b++ = a * *dest_b + b * *src_b++;
        }
      break;
      case COMPOSITE_IN:
        while (width--)
        {
           a = *src_a++;
          if(a){
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
          }else{
            *dest_r++ = 0;
            *dest_g++ = 0;
            *dest_b++ = 0;
            src_r++;
            src_g++;
            src_b++;
          }
        }
      break;
      case COMPOSITE_OUT:
      while (width--)
        {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
        }
      break;
      case COMPOSITE_XOR:
      while (width--)
      {
        b = (1.0 - *src_a++);
        if(b){
          *dest_r++ = *dest_r;
          *dest_g++ = *dest_g;
          *dest_b++ = *dest_b;
        } else {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
           src_r++;
           src_g++;
           src_b++;
        } 
      }
      break;
      case COMPOSITE_ATOP:
      while (width--)
      {
        if(*src_a++){
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        } else {
          *dest_r++ = 0;
          *dest_g++ = 0;
          *dest_b++ = 0;
           src_r++;
           src_g++;
           src_b++;
        } 
      }
      break;
      case COMPOSITE_PLUS:
      while (width--)
      {
        *dest_r++ += *src_r++;
        *dest_g++ += *src_g++;
        *dest_b++ += *src_b++;
      }
    break;
    default:
    break;
    }
  }


  private 
  void
  RGB_op_RGB_FLOAT (GeglPointOp *point_op)
  {
    guint               width;
    GeglCompositeMode   comp_mode;
    gfloat              *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b;
    gfloat              *dest_data[3], *src_data[3];

    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    GeglCompositeOp *self = GEGL_COMPOSITE_OP (point_op);
    GeglCompositeOpPrivate *selfP = (GeglCompositeOpPrivate *)(self->_priv); 

    GeglOp *op = GEGL_OP (point_op); 
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv); 

	
    width = point_opP->scanline_width;
    comp_mode = selfP->comp_mode;

    /* Initialize the data pointers to the scanline */
    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[0],
                  (guchar**)dest_data);
    gegl_image_buffer_get_scanline_data (
                  opP->image_buffers[1],
                  (guchar**)src_data);

    /* Make r,g,b point to the image data */
    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
 
    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];
    
    switch(comp_mode){
      case COMPOSITE_REPLACE:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OVER:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        } 
      break;
      case COMPOSITE_IN:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_OUT:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_XOR:
        while (width--)
        {
          *dest_r++ = 0.0; 
          *dest_g++ = 0.0;
          *dest_b++ = 0.0;
        }
      break;
      case COMPOSITE_ATOP:
        while (width--)
        {
          *dest_r++ = *src_r++;
          *dest_g++ = *src_g++;
          *dest_b++ = *src_b++;
        }
      break;
      case COMPOSITE_PLUS:
        while (width--)
        {
          *dest_r++ += *src_r++;
          *dest_g++ += *src_g++;
          *dest_b++ += *src_b++;
        }
      break;
      default:
      break;
    }	

  }
}
