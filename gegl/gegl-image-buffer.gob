%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  protected gint width;
  protected gint height;

  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, 
      gint w, 
      gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglColorModel *cm,  
              gint w, 
              gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self),NULL))
      return FALSE;

    /* ImageBuffers set their color model when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);

    /* Set the size as well */
    self->width = w;
    self->height = h;

    return TRUE;
  }

  public
  gint 
  get_width (self)
  {
    return self->width;
  }

  public 
  gint 
  get_height (self)
  {
    return self->height;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Image)
  void 
  compute_have_rect (GeglImage *self_image)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(self_image);
    self_image->have_rect.x = 0;
    self_image->have_rect.y = 0;
    self_image->have_rect.w = self->width;
    self_image->have_rect.h = self->height;
  }

  override (Gegl:Image)
  void 
  compute_cache_rect (GeglImage *self_image)
  {
    /* Completely cached since we are a leaf node */ 
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(self_image);

    self_image->cache_rect.x = 0;
    self_image->cache_rect.y = 0;
    self_image->cache_rect.w = self->width;
    self_image->cache_rect.h = self->height;
  }
}
