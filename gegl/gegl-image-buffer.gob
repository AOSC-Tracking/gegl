%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-copy-op.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  private guchar **data;         /* channel data pointers */

  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, gint w, gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, GeglColorModel *cm, gint w, gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self)))
      return FALSE;

    /* ImageBuffers set color model and allocate data when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);
    return alloc(self,w,h);
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImageBuffer *self_image_buffer = GEGL_IMAGE_BUFFER(object);

    free_data (self_image_buffer);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  gboolean 
  alloc(self, 
        gint w,
        gint h)
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;
    gint i;

    if (!cm)
      {
        g_warning("gegl_image_buffer_alloc: color_model unknown\n");
	return FALSE;
      }

    {
      gint bpc = gegl_color_model_bytes_per_channel(cm);  
      gint num_channels = gegl_color_model_num_channels(cm);
      gint channel_bytes = bpc * w * h;

      self->_priv->data = g_new(guchar *, num_channels);

      for(i = 0; i < num_channels; i++)
	{
          self->_priv->data[i] = g_new (guchar, channel_bytes); 
	  if (!self->_priv->data[i]) 
	    {
	      free_data(self);
	      g_warning ("gegl_image_buffer_alloc: Cant alloc image data.\n"); 
	      return FALSE;
	    }
	}

      image->_priv->width = w;
      image->_priv->height = h;
    }

    return TRUE;
  }

  private
  void
  free_data(self) 
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;
    gint num_channels = gegl_color_model_num_channels(cm);
    gint i;

    for(i = 0; i < num_channels; i++)
      {
	if (self->_priv->data[i]) 
	    g_free (self->_priv->data[i]);
      }

    if (self->_priv->data)
      g_free (self->_priv->data); 

    self->_priv->data = NULL;
    image->_priv->width = 0;
    image->_priv->height = 0;
  }
  
  public
  guchar ** 
  get_data(self)
  {
    return self->_priv->data;
  }

  public
  void
  set_data(self, guchar *data)
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;

    gint bpc = gegl_color_model_bytes_per_channel(cm);  
    gint w = image->_priv->width;  
    gint h = image->_priv->height;  
    gint num_channels = gegl_color_model_bytes_per_channel(cm);
    gint channel_bytes = bpc * w * h;

    guchar *s;
    guchar *d;
    gint i,j;

    for(i = 0; i < num_channels; i++)
      {
        d = self->_priv->data[i];
	s = data + i * channel_bytes;

	/* copy in the channel */
	for(j = 0; j < channel_bytes; j++)
	  *d++ = *s++;
      }
  }

  override (Gegl:Image)
  GeglImage * 
  get_pixels (GeglImage *self, 
                   GeglImage *dest, 
		   GeglRect *roi)
  {
    /* check for leaf of chain, just return */
    if (dest == NULL) 
      {
	/*g_print("Found an image node %x\n", self);*/
        return self;
      }

    if (!GEGL_IS_IMAGE_BUFFER(dest))
      {
	g_warning("gegl_image_buffer_get_pixels: dest not image buffer\n");
	return NULL;
      }
   
   /* Just copy the pixels to the dest */ 
   copy_pixels (GEGL_IMAGE_BUFFER(dest), roi, 
                GEGL_IMAGE_BUFFER(self), roi);   
  
   return dest;
  }

  public
  void 
  copy_pixels (GeglImageBuffer *self, 
                    GeglRect *self_rect, 
		    GeglImageBuffer *src, 
		    GeglRect  *src_rect)
  {

    /* 
       This routine will check the rects and do scaling if
       self_rect and src_rect have different sizes. Of course
       the CopyOp will trigger color conversions automatically.
    */ 

    GeglImage * op = GEGL_IMAGE(gegl_copy_op_new (GEGL_IMAGE(src)));
    gegl_image_get_pixels (op, GEGL_IMAGE(self), self_rect);
    gegl_object_destroy (GEGL_OBJECT(op));
  }
}
