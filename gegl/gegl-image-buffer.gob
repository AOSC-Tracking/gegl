%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-object-private.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  protected gint width;
  protected gint height;

  /**
   * new:
   * @cm: a #GeglColorModel.
   * @w: width. 
   * @h: height. 
   * 
   * Creates a #GeglImageBuffer. 
   * 
   * Returns: a new #GeglImageBuffer.
   **/ 
  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, 
      gint w, 
      gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglImageBuffer. 
   * @cm: the #GeglColorModel of the image buffer. 
   * @w: width. 
   * @h: height. 
   *
   * Initializes a #GeglImageBuffer.
   * 
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self, 
              GeglColorModel *cm,  
              gint w, 
              gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self),NULL))
      return FALSE;

    /* ImageBuffers set their color model when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);

    /* Set the size as well */
    self->width = w;
    self->height = h;

    return TRUE;
  }


  /**
   * get_width:
   * @self: a #GeglImageBuffer. 
   * 
   * Gets the width of the image buffer.
   *
   * Returns: width of the image buffer.
   **/ 
  public
  gint 
  get_width (self)
  {
    return self->width;
  }


  /**
   * get_height:
   * @self: a #GeglImageBuffer. 
   * 
   * Gets the height of the image buffer.
   *
   * Returns: height of the image buffer.
   **/ 
  public 
  gint 
  get_height (self)
  {
    return self->height;
  }


  /**
   * compute_have_rect:
   * @self_image: a #GeglImage.
   * @inputs: a #GeglImage list - should be NULL here.
   *
   * The image buffer's have rect is determined by its width, height. 
   *
   **/
  override (Gegl:Image)
  void 
  compute_have_rect (GeglImage *self_image, 
                     GList *inputs)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(self_image);
    self_image->have_rect.x = 0;
    self_image->have_rect.y = 0;
    self_image->have_rect.w = self->width;
    self_image->have_rect.h = self->height;
  }


  /**
   * compute_result_rect:
   * @self_image: a #GeglImage
   * @inputs: a #GeglImage list - should be NULL here.
   *
   * Computes the result_rect of the image buffer. This is just the
   * intersection of have and need rects. 
   *
   **/
  override (Gegl:Image)
  void 
  compute_result_rect (GeglImage *self_image, GList *inputs)
  {
    gegl_rect_intersect (&self_image->result_rect,
                         &self_image->need_rect,
                         &self_image->have_rect);
  }
}
