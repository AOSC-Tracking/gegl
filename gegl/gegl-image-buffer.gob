%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-copy-op.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, 
      gint w, 
      gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglColorModel *cm,  
              gint w, 
              gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self),NULL))
      return FALSE;

    /* ImageBuffers set their color model and allocate data when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);

    return gegl_image_alloc(GEGL_IMAGE(self),w,h);
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public
  void
  set_data(self, 
           guchar *data)
  {
    GeglImage *self_image  = GEGL_IMAGE(self);
    GeglColorModel *cm = gegl_image_color_model(self_image);

    gint bpc = gegl_color_model_bytes_per_channel(cm);  
    gint w = self_image->width;  
    gint h = self_image->height;  
    gint num_channels = gegl_color_model_bytes_per_channel(cm);
    gint channel_bytes = bpc * w * h;

    guchar *s, *d;
    gint i,j;
    guchar **data_ptrs = gegl_image_get_data(self_image);

    for(i = 0; i < num_channels; i++)
      {
        d = data_ptrs[i];
        s = data + i * channel_bytes;

        /* copy in the channel */
        for(j = 0; j < channel_bytes; j++)
	      *d++ = *s++;
      }
  }

  override (Gegl:Image)
  GeglImage * 
  get_pixels (GeglImage *self_image,
              GeglImage *dest,
              GeglRect *roi)
  {
    if (dest && !GEGL_IS_IMAGE_BUFFER(dest))
      {
        g_warning("gegl_image_buffer_get_pixels: dest not image buffer\n");
        return NULL;
      }
    else if (!dest)  /* just a leaf of a tree */
      {
        return self_image;
      }
    else
      copy_pixels (GEGL_IMAGE_BUFFER(dest), roi, 
                   GEGL_IMAGE_BUFFER(self_image), roi);   
  
   return dest;
  }

  public
  void 
  copy_pixels (GeglImageBuffer *self, 
               GeglRect *self_rect, 
               GeglImageBuffer *src, 
               GeglRect  *src_rect)
  {
    GeglImage * op = GEGL_IMAGE(gegl_copy_op_new (GEGL_IMAGE(src)));
    gegl_image_get_pixels (op, GEGL_IMAGE(self), self_rect);
    gtk_object_unref (GTK_OBJECT(op));
  }
}
