%h{

#include "gegl-object.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif

%}
%{

#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-object-private.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"

%}

class Gegl:Image:Buffer from Gegl:Object {

  private GeglColorModel *color_model;
  private gint width;
  private gint height;
  private guchar *data;                    /* The data */    

  public
  GeglImageBuffer *	
  new(GeglColorModel *cm, gint w, gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, GeglColorModel *cm, gint w, gint h)
  {
    gint bytes_per_channel;  
    gint num_channels;
    guint total_bytes;

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
	
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    bytes_per_channel = gegl_color_model_bytes_per_channel(cm);  
    num_channels = gegl_color_model_num_channels(cm);
    total_bytes = num_channels * bytes_per_channel * w * h;

    self->_priv->data = g_new (guchar, total_bytes); 
    if (!self->_priv->data) 
      {
        g_warning ("Couldnt allocate in %s: %d bytes\n", 
                   gtk_type_name(GEGL_TYPE_IMAGE_BUFFER), total_bytes); 
        self->_priv->color_model = NULL;
        self->_priv->width = 0;
        self->_priv->height = 0;
        return FALSE;
      }

    self->_priv->color_model = cm;
    self->_priv->width = w;
    self->_priv->height = h;

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {

    GeglImageBuffer *self = GEGL_IMAGE_BUFFER (object);

    /* Dispose of image memory and scanline pointer array*/
    g_free(self->_priv->data);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public 
  gint 
  get_width (self)
  {
    return self->_priv->width;
  }

  public 
  gint 
  get_height (self)
  {
    return self->_priv->height;
  }

  public
  guchar * 
  get_data (self)
  {
    return self->_priv->data;
  }

  public
  GeglColorModel * 
  color_model(self) 
  { 
    return self->_priv->color_model; 
  }

  public
  void
  set_data(self, guchar *data)
  {
    guint                       i, num;
    GeglImageBufferPrivate      *selfP;

    selfP = (GeglImageBufferPrivate *)(self->_priv);
    num  = gegl_color_model_num_channels(selfP->color_model);
    num *= gegl_color_model_bytes_per_channel(selfP->color_model);
    num *= selfP->width;
    num *= selfP->height;

    for(i=0; i<num; i++)
      selfP->data[i] = data[i];

  }

}
