%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-copy-op.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, gint w, gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, GeglColorModel *cm, gint w, gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self)))
      return FALSE;

    /* ImageBuffers set their color model and allocate data when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);
    return gegl_image_alloc(GEGL_IMAGE(self),w,h);
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public
  void
  set_data(self, guchar *data)
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;

    gint bpc = gegl_color_model_bytes_per_channel(cm);  
    gint w = image->_priv->width;  
    gint h = image->_priv->height;  
    gint num_channels = gegl_color_model_bytes_per_channel(cm);
    gint channel_bytes = bpc * w * h;

    guchar *s;
    guchar *d;
    gint i,j;

    for(i = 0; i < num_channels; i++)
      {
        d = image->_priv->data[i];
	s = data + i * channel_bytes;

	/* copy in the channel */
	for(j = 0; j < channel_bytes; j++)
	  *d++ = *s++;
      }
  }

  override (Gegl:Image)
  GeglImage * 
  get_pixels (GeglImage *image,
              GeglImage *dest,
	      GeglRect *roi)
  {
    if (dest && !GEGL_IS_IMAGE_BUFFER(dest))
      {
	g_warning("gegl_image_buffer_get_pixels: dest not image buffer\n");
	return NULL;
      }
    else if (!dest)  /* just a leaf of a tree */
      {
        return image;
      }
    else
      copy_pixels (GEGL_IMAGE_BUFFER(dest), roi, 
                   GEGL_IMAGE_BUFFER(image), roi);   
  
   return dest;
  }

  public
  void 
  copy_pixels (GeglImageBuffer *self, 
                    GeglRect *self_rect, 
		    GeglImageBuffer *src, 
		    GeglRect  *src_rect)
  {
    GeglImage * op = GEGL_IMAGE(gegl_copy_op_new (GEGL_IMAGE(src)));
    gegl_image_get_pixels (op, GEGL_IMAGE(self), self_rect);
    gegl_object_destroy (GEGL_OBJECT(op));
  }
}
