%h{
#include "gegl-image.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image-buffer.h"
#include "gegl-image-buffer-private.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-copy-op.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Buffer from Gegl:Image {

  private guchar **data;         /* channel data pointers */

  public
  GeglImageBuffer *       
  new(GeglColorModel *cm, gint w, gint h)
  {
    GeglImageBuffer * self = GEGL_IMAGE_BUFFER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, GeglColorModel *cm, gint w, gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self)))
      return FALSE;

    /* ImageBuffers set color model and allocate data when created */
    gegl_image_set_color_model (GEGL_IMAGE(self),cm);
    return alloc(self,w,h);
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImageBuffer *self_image_buffer = GEGL_IMAGE_BUFFER(object);

    free_data (self_image_buffer);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  gboolean 
  alloc(self, 
        gint w,
        gint h)
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;
    gint i;

    if (!cm)
      {
        g_warning("gegl_image_buffer_alloc: color_model unknown\n");
	return FALSE;
      }

    {
      gint bpc = gegl_color_model_bytes_per_channel(cm);  
      gint num_channels = gegl_color_model_bytes_per_channel(cm);
      gint channel_bytes = bpc * w * h;

      self->_priv->data = g_new(guchar *, num_channels);

      for(i = 0; i < num_channels; i++)
	{
          self->_priv->data[i] = g_new (guchar, channel_bytes); 
	  if (!self->_priv->data[i]) 
	    {
	      free_data(self);
	      g_warning ("gegl_image_buffer_alloc: Cant alloc image data.\n"); 
	      return FALSE;
	    }
	}

      image->_priv->width = w;
      image->_priv->height = h;
    }

    return TRUE;
  }

  private
  void
  free_data(self) 
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;
    gint num_channels = gegl_color_model_bytes_per_channel(cm);
    gint i;

    for(i = 0; i < num_channels; i++)
      {
	if (self->_priv->data[i]) 
	    g_free (self->_priv->data[i]);
      }

    if (self->_priv->data)
      g_free (self->_priv->data); 

    self->_priv->data = NULL;
    image->_priv->width = 0;
    image->_priv->height = 0;
  }
  
  override (Gegl:Image)
  gboolean
  is_writable(GeglImage *image)
  {
    return TRUE;
  }

  public
  guchar ** 
  get_data(self)
  {
    return self->_priv->data;
  }

  public
  void
  set_data(self, guchar *data)
  {
    GeglImage *image  = GEGL_IMAGE(self);
    GeglColorModel *cm = image->_priv->color_model;

    gint bpc = gegl_color_model_bytes_per_channel(cm);  
    gint w = image->_priv->width;  
    gint h = image->_priv->height;  
    gint num_channels = gegl_color_model_bytes_per_channel(cm);
    gint channel_bytes = bpc * w * h;

    guchar *s;
    guchar *d;
    gint i,j;

    for(i = 0; i < num_channels; i++)
      {
        d = self->_priv->data[i];
	s = data + i * channel_bytes;

	/* copy in the channel */
	for(j = 0; j < channel_bytes; j++)
	  *d++ = *s++;
      }
  }

  override (Gegl:Image)
  GeglImage * 
  get_pixels (GeglImage *self, 
                   GeglImage *dest, 
		   GeglRect *roi)
  {
    /* check for leaf of chain, just return */
    if (dest == NULL) 
      {
	/*g_print("Found an image node %x\n", self);*/
        return self;
      }

    if (!gegl_image_is_writable(dest))
      {
	g_warning("gegl_image_buffer_get_pixels: dest not writable\n");
	return NULL;
      }

    /* copy pixels from me to dest */
    g_warning("gegl_image_buffer_get_pixels: routine not implemented yet!\n");
      {
#if 1
	gint i, j, k;
	gint x = roi->x;
	gint y = roi->y;
	gint w = roi->w;
	gint h = roi->h;
	guchar *src_d, *dest_d; 
	GeglColorModel *src_cm = self->_priv->color_model;
	GeglColorModel *dest_cm = dest->_priv->color_model;

	gint src_bpc = gegl_color_model_bytes_per_channel(src_cm);
	gint dest_bpc = gegl_color_model_bytes_per_channel(dest_cm);
	gint src_num_channels = gegl_color_model_bytes_per_channel(src_cm);
	gint dest_num_channels = gegl_color_model_bytes_per_channel(dest_cm);
    
	gint src_width = self->_priv->width;  
	gint dest_width = dest->_priv->width;  


	if (src_bpc != dest_bpc || src_num_channels != dest_num_channels)
	  {
	    g_warning("gegl_image_buffer_get_pixels: incompatible images\n");
	    return NULL;
	  }
	
	for (i=0; i<src_num_channels; i++)
	  {
	    for (k=x; k<h+x; k++)
	      {
		src_d = GEGL_IMAGE_BUFFER ((GtkObject*)self)->_priv->data[i] + k * src_width + y;
		dest_d = GEGL_IMAGE_BUFFER ((GtkObject*)dest)->_priv->data[i] + k * dest_width + y; 
		for (j=0; j<w*src_bpc; j++)
		  {

		    *dest_d++ = *src_d++; 
		  }
	      } 
	  }

#endif 	
	
      }

    return dest;
  }

  override (Gegl:Image)
  void 
  copy_pixels (GeglImage *self, 
                    GeglRect *self_rect, 
		    GeglImage *src, 
		    GeglRect  *src_rect)
  {
    GeglImage * op = GEGL_IMAGE (gegl_copy_op_new (src));
    gegl_image_get_pixels (op, self, self_rect);
    gegl_object_destroy (GEGL_OBJECT(op));

  }
}
