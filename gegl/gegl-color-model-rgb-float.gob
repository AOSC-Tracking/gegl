%h{
#include "gegl-color-model-rgb.h"
%}
%{
#include "gegl-color-model-rgb-float.h"
#include "gegl-color-model-rgb-float-private.h"
#include "gegl-color-model-rgb-private.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
#include <string.h>
%}

class Gegl:Color:Model:Rgb:Float from Gegl:Color:Model:Rgb {

  public
  GeglColorModelRgbFloat *       
  new(gboolean has_alpha)
  {
    GeglColorModelRgbFloat * self = GEGL_COLOR_MODEL_RGB_FLOAT(GET_NEW);
  
    /*Call the constructor */
    if (!constructor(self, has_alpha))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }
  
  protected
  gboolean 
  constructor(self, 
              gboolean has_alpha)
  {

    if (GEGL_OBJECT(self)->constructed) 
        return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_rgb_constructor (
         GEGL_COLOR_MODEL_RGB(self), has_alpha))
        return FALSE;

    {
      GeglColorModel *cm = GEGL_COLOR_MODEL (self);
      cm->_priv->data_type = FLOAT;
      cm->_priv->channel_data_type_name = NULL;
      cm->_priv->bytes_per_channel = sizeof(float);
      cm->_priv->bytes_per_pixel = cm->_priv->bytes_per_channel * 
		    cm->_priv->num_channels;

      /* These are the color models we can convert from directly */
      gegl_object_add_interface (GEGL_OBJECT(self), "FromRgbFloat", 
				 gegl_color_model_rgb_float_from_rgb_float);
      gegl_object_add_interface (GEGL_OBJECT(self), "FromRgbU8", 
				 gegl_color_model_rgb_float_from_rgb_u8);
      gegl_object_add_interface (GEGL_OBJECT(self), "FromGrayFloat", 
				 gegl_color_model_rgb_float_from_gray_float);
    }
    return TRUE;
  }
  
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Color:Model) 
  void 
  set_color (GeglColorModel *cm, 
             GeglColor *color, 
             GeglColorConstant constant)
  {
    GeglChannelValue * channel_values = 
                          gegl_color_get_channel_values(color); 
    gboolean has_alpha = gegl_color_model_has_alpha (cm); 
    GeglColorModelRgb * cm_rgb = GEGL_COLOR_MODEL_RGB(cm);
    
    gint r = gegl_color_model_rgb_get_red_index (cm_rgb);
    gint g = gegl_color_model_rgb_get_green_index (cm_rgb);
    gint b = gegl_color_model_rgb_get_blue_index (cm_rgb);
    gint a = gegl_color_model_alpha_channel (GEGL_COLOR_MODEL(cm_rgb));

    switch (constant) 
      { 
        case COLOR_WHITE:
          channel_values[r].f = 1.0;
          channel_values[g].f = 1.0;
          channel_values[b].f = 1.0;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_BLACK:
          channel_values[r].f = 0.0;
          channel_values[g].f = 0.0;
          channel_values[b].f = 0.0;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_RED:
          channel_values[r].f = 1.0;
          channel_values[g].f = 0.0;
          channel_values[b].f = 0.0;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_GREEN:
          channel_values[r].f = 0.0;
          channel_values[g].f = 1.0;
          channel_values[b].f = 0.0;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_BLUE:
          channel_values[r].f = 0.0;
          channel_values[g].f = 0.0;
          channel_values[b].f = 1.0;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_GRAY:
        case COLOR_HALF_WHITE:
          channel_values[r].f = 0.5;
          channel_values[g].f = 0.5;
          channel_values[b].f = 0.5;
          if (has_alpha)
            channel_values[a].f = 1.0;
          break;
        case COLOR_WHITE_TRANSPARENT:
          channel_values[r].f = 1.0;
          channel_values[g].f = 1.0;
          channel_values[b].f = 1.0;
          if (!has_alpha)
            channel_values[a].f = 0.0;
          break;
        case COLOR_TRANSPARENT:
        case COLOR_BLACK_TRANSPARENT:
          channel_values[r].f = 0.0;
          channel_values[g].f = 0.0;
          channel_values[b].f = 0.0;
          if (has_alpha)
            channel_values[a].f = 0.0;
          break;
      }
   }

  override (Gegl:Color:Model) 
  void
  convert_to_xyz (GeglColorModel *cm, 
                  gfloat **dest_data, 
                  guchar **src_data, 
                  gint width)
  {
    /* convert from float rgb to float xyz */

    /*  
      [ X ] [ 0.412453  0.357580  0.180423 ] [ R709 ] 
      [ Y ]=[ 0.212671  0.715160  0.072169 ]*[ G709 ] 
      [ Z ] [ 0.019334  0.119193  0.950227 ] [ B709 ]

    */
    gfloat m00 = 0.412453;
    gfloat m10 = 0.357580;
    gfloat m20 = 0.180423;
    gfloat m01 = 0.212671;
    gfloat m11 = 0.715160;
    gfloat m21 = 0.072169;
    gfloat m02 = 0.019334;
    gfloat m12 = 0.119193;
    gfloat m22 = 0.950227;

    gfloat *src_r, *src_g, *src_b; 
    gfloat *src_a = NULL;
    gfloat *dest_x, *dest_y, *dest_z; 
    gfloat *dest_a = NULL;

    gboolean has_alpha = gegl_color_model_has_alpha(cm);

    src_r = (gfloat*) src_data[0];
    src_g = (gfloat*) src_data[1];
    src_b = (gfloat*) src_data[2];       

    dest_x = dest_data[0];
    dest_y = dest_data[1];
    dest_z = dest_data[2];

    if (has_alpha)
      {
       dest_a = dest_data[3];
       src_a = (gfloat*) src_data[3];
      }

    while (width--)
      {
       *dest_x++ = m00 * *src_r + m10 * *src_g + m20 * *src_b;
       *dest_y++ = m01 * *src_r + m11 * *src_g + m21 * *src_b;
       *dest_z++ = m02 * *src_r++ + m12 * *src_g++ + m22 * *src_b++;
       
       if (has_alpha)
         *dest_a++ = *src_a++;
      }
  }

  override (Gegl:Color:Model) 
  void
  convert_from_xyz (GeglColorModel *cm, 
                    guchar **dest_data, 
                    gfloat **src_data, 
                    gint width)
  {
    /* convert from float xyz to float rgb */

    /*
      [ R709 ] [ 3.240479 -1.53715  -0.498535 ] [ X ] 
      [ G709 ]=[-0.969256  1.875991  0.041556 ]*[ Y ] 
      [ B709 ] [ 0.055648 -0.204043  1.057311 ] [ Z ] 
    */

    gfloat m00 = 3.240479;
    gfloat m10 = -1.53715;
    gfloat m20 = -0.498535;
    gfloat m01 = -0.969256;
    gfloat m11 = 1.875991;
    gfloat m21 = 0.041556; 
    gfloat m02 = 0.055648;
    gfloat m12 = -0.204043;
    gfloat m22 = 1.057311;

    gfloat *src_x, *src_y, *src_z; 
    gfloat *src_a = NULL;
    gfloat *dest_r, *dest_g, *dest_b; 
    gfloat *dest_a = NULL;
    
    gboolean has_alpha = gegl_color_model_has_alpha(cm);

    src_x = src_data[0];
    src_y = src_data[1];
    src_z = src_data[2];

    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];

    if (has_alpha) 
      {
       dest_a = (gfloat*) dest_data[3];
       src_a = src_data[3];
      }

    while (width--)
      {
       *dest_r++ = m00 * *src_x + m10 * *src_y + m20 * *src_z;
       *dest_g++ = m01 * *src_x + m11 * *src_y + m21 * *src_z;
       *dest_b++ = m02 * *src_x++ + m12 * *src_y++ + m22 * *src_z++;
        if (has_alpha)
         *dest_a++ = *src_a++;
      }
  }

  override (Gegl:Color:Model) 
  char * 
  get_converter_interface_name (GeglColorModel *cm) 
  {
    return g_strdup ("FromRgbFloat"); 
  }

  private
  void
  from_rgb_u8(GeglColorModel *dest_cm, 
	      GeglColorModel *src_cm,
	      guchar **dest_data, 
	      guchar **src_data, 
	      gint width)
  {
    gfloat          *dest_r, *dest_g, *dest_b; 
    gfloat          *dest_a = NULL;
    guint8          *src_r, *src_g, *src_b;
    guint8          *src_a = NULL;
    gboolean         dest_has_alpha = gegl_color_model_has_alpha(dest_cm);
    gboolean         src_has_alpha = gegl_color_model_has_alpha(src_cm);
    
    dest_r = (gfloat*)dest_data[0];
    dest_g = (gfloat*)dest_data[1];
    dest_b = (gfloat*)dest_data[2];
    if (dest_has_alpha)
      dest_a = (gfloat*)dest_data[3];
    
    src_r = (guint8*) src_data[0];
    src_g = (guint8*) src_data[1];
    src_b = (guint8*) src_data[2];
    if (src_has_alpha)
      src_a = (guint8*) src_data[3];

    while (width--)
      {
       *dest_r++ = *src_r++ / 255.0;
       *dest_g++ = *src_g++ / 255.0;
       *dest_b++ = *src_b++ / 255.0;

       if (src_has_alpha && dest_has_alpha)
         *dest_a++ = *src_a++ / 255.0;
       else if (dest_has_alpha) 
         *dest_a++ = 1.0;
      } 
  }

  private
  void
  from_gray_float (GeglColorModel *dest_cm, 
			   GeglColorModel *src_cm,
			   guchar **dest_data, 
			   guchar **src_data, 
			   gint width)
  {
    gfloat          *dest_r, *dest_g, *dest_b; 
    gfloat          *dest_a = NULL;
    gfloat          *src_g;
    gfloat          *src_a = NULL;
    gboolean         dest_has_alpha = gegl_color_model_has_alpha(dest_cm);
    gboolean         src_has_alpha = gegl_color_model_has_alpha(src_cm);
    
    dest_r = (gfloat*)dest_data[0];
    dest_g = (gfloat*)dest_data[1];
    dest_b = (gfloat*)dest_data[2];
    if (dest_has_alpha)
      dest_a = (gfloat*)dest_data[3];

    src_g = (gfloat*) src_data[0];
    if (src_has_alpha)
      src_a = (gfloat*) src_data[1];

    while (width--)
      {
       *dest_r++ = *src_g;
       *dest_g++ = *src_g;
       *dest_b++ = *src_g++;

       if (src_has_alpha && dest_has_alpha)
         *dest_a++ = *src_a++;
       else if (dest_has_alpha) 
         *dest_a++ = 1.0;
      } 
  }

  private
  void
  from_rgb_float (GeglColorModel *dest_cm, 
			   GeglColorModel *src_cm,
			   guchar **dest_data, 
			   guchar **src_data, 
			   gint width)
  {
    gfloat          *dest_r, *dest_g, *dest_b; 
    gfloat          *dest_a = NULL;
    gfloat          *src_r, *src_g, *src_b; 
    gfloat          *src_a = NULL;
    gboolean         dest_has_alpha = gegl_color_model_has_alpha(dest_cm);
    gboolean         src_has_alpha = gegl_color_model_has_alpha(src_cm);
    gint             row_bytes = width * gegl_color_model_bytes_per_channel(dest_cm); 
    
    dest_r = (gfloat*)dest_data[0];
    dest_g = (gfloat*)dest_data[1];
    dest_b = (gfloat*)dest_data[2];
    if (dest_has_alpha)
      dest_a = (gfloat*)dest_data[3];

    src_r = (gfloat*)src_data[0];
    src_g = (gfloat*)src_data[1];
    src_b = (gfloat*)src_data[2];
    if (src_has_alpha)
      src_a = (gfloat*)src_data[3];

    if (src_has_alpha && dest_has_alpha)
      {
	memcpy(dest_r, src_r, row_bytes);  
	memcpy(dest_g, src_g, row_bytes);  
	memcpy(dest_b, src_b, row_bytes);  
	memcpy(dest_a, src_a, row_bytes);  
      }
    else if (dest_has_alpha) 
      {
	memcpy(dest_r, src_r, row_bytes);  
	memcpy(dest_g, src_g, row_bytes);  
	memcpy(dest_b, src_b, row_bytes);  

	while(width--)
	  *dest_a++ = 1.0;
      }
    else 
      {
	memcpy(dest_r, src_r, row_bytes);  
	memcpy(dest_g, src_g, row_bytes);  
	memcpy(dest_b, src_b, row_bytes);  
      }
  }
}
