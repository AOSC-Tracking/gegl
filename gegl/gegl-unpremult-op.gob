%h{
#include "gegl-point-op.h"
%}
%{
#include "gegl-unpremult-op.h"
#include "gegl-unpremult-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Unpremult:Op from Gegl:Point:Op {

  
  public 
  GeglUnpremultOp *
  new (GeglImageBuffer *dest,
       GeglRect *dest_rect) 
  {
    GeglUnpremultOp * self = GEGL_UNPREMULT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, dest_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest,
              GeglRect *dest_rect) 
  {
    gboolean	has_alpha;
    GeglColorModel *cm;
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (
         GEGL_POINT_OP(self), &dest, dest_rect, 1))
      return FALSE;

    /*
      Now based on the image buffers's color model(s)/data storage(s)
      choose one of our scanline funcs to install
      This is where some "autogeneration" happens.
    */ 

#if 0
      GeglChannelDataType data_type;
      cm = gegl_image_buffer_color_model (dest);
      data_type = gegl_color_model_data_type (cm);
      switch (data_type)
      {
        case FLOAT:
          point_op_class->scanline_func = gegl_unpremult_op_RGB_FLOAT; 	
          break;
        default:
          g_warning("PrintOp: Color Model data type none or unknown\n");
          point_op_class->scanline_func = NULL; 	
          return FALSE;
      }
#endif

    cm = gegl_image_buffer_color_model (dest);
    has_alpha = gegl_color_model_has_alpha(cm);
    
    if(has_alpha)
      point_op_class->scanline_func = gegl_unpremult_op_RGBA_FLOAT;
    else
      point_op_class->scanline_func = gegl_unpremult_op_RGB_FLOAT;

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  RGB_FLOAT (GeglPointOp *point_op)
  {

  }

  private 
  void
  RGBA_FLOAT (GeglPointOp *point_op)
  {
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    guint width = point_opP->scanline_width;

    gfloat * dest_data[4]; 
    gfloat *r, *g, *b, *a, t;

    /* image_buffers[0] is the dest here */
    gegl_image_iterator_get_scanline_data (
        point_opP->iterators[0], 
	(guchar**)dest_data);

    /* Make r,g,b point to the dest image data */
    r = dest_data[0];
    g = dest_data[1];
    b = dest_data[2];
    a = dest_data[3];

    /* Unpremultipy -- divide by alpha */
    while (width--)
    {
      if(*a)
        {
	  t = 1.0 / *a++;
	  *r++ *= *a;
	  *g++ *= *a;
	  *b++ *= *a++;
        } 
      else 
        {
	  *r++ = 0;
	  *g++ = 0;
	  *b++ = 0;
	   a++; 
        }
    }
  }
}
