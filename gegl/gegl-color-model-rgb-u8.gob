%h{
#include "gegl-color-model-rgb.h"
%}
%{
#include "gegl-color-model-rgb-u8.h"
#include "gegl-color-model-rgb-u8-private.h"
#include "gegl-color-model-rgb-private.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
%}

class Gegl:Color:Model:Rgb:U8 from Gegl:Color:Model:Rgb {

  public
  GeglColorModelRgbU8 *	
  new(gboolean has_alpha, gboolean is_premult)
  {
    GeglColorModelRgbU8 * self = GEGL_COLOR_MODEL_RGB_U8(GET_NEW);
  
    /*Call the constructor */
    if (!constructor(self, has_alpha, is_premult))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }
  
  protected
  gboolean 
  constructor(self, gboolean has_alpha, gboolean is_premult)
  {
    GeglColorModelPrivate *color_modelP = (GeglColorModelPrivate*)
                                  (GEGL_COLOR_MODEL (self)->_priv);

    if (GEGL_OBJECT(self)->constructed) 
        return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_rgb_constructor (
         GEGL_COLOR_MODEL_RGB(self), has_alpha, is_premult))
        return FALSE;

    color_modelP->data_type = U8;
    color_modelP->channel_data_type_name = NULL;
    color_modelP->bytes_per_channel = sizeof(guint8);
    color_modelP->bytes_per_pixel = 
                  color_modelP->bytes_per_channel * 
                  color_modelP->num_channels;
    return TRUE;
  }
  
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Dispose of the data type string here */

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Color:Model) 
  void 
  set_color (GeglColorModel *cm, 
             GeglColor *color, 
             GeglColorConstant constant)
  {
    GeglChannelValue * channel_values = 
                       gegl_color_get_channel_values(color); 
    gboolean has_alpha = gegl_color_model_has_alpha (cm); 
    GeglColorModelRgb * cm_rgb = GEGL_COLOR_MODEL_RGB(cm);
    
    gint r = gegl_color_model_rgb_get_red_index (cm_rgb);
    gint g = gegl_color_model_rgb_get_green_index (cm_rgb);
    gint b = gegl_color_model_rgb_get_blue_index (cm_rgb);
    gint a = gegl_color_model_alpha_channel (GEGL_COLOR_MODEL(cm_rgb));

    switch (constant) 
      { 
        case COLOR_WHITE:
          channel_values[r].u8 = 255;
          channel_values[g].u8 = 255;
          channel_values[b].u8 = 255;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_BLACK:
          channel_values[r].u8 = 0;
          channel_values[g].u8 = 0;
          channel_values[b].u8 = 0;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_RED:
          channel_values[r].u8 = 255;
          channel_values[g].u8 = 0;
          channel_values[b].u8 = 0;
          if (has_alpha)
            channel_values[a].f = 255;
          break;
        case COLOR_GREEN:
          channel_values[r].u8 = 0;
          channel_values[g].u8 = 255;
          channel_values[b].u8 = 0;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_BLUE:
          channel_values[r].u8 = 0;
          channel_values[g].u8 = 0;
          channel_values[b].u8 = 255;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_GRAY:
        case COLOR_HALF_WHITE:
          channel_values[r].u8 = 127;
          channel_values[g].u8 = 127;
          channel_values[b].u8 = 127;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_WHITE_TRANSPARENT:
          channel_values[r].u8 = 255;
          channel_values[g].u8 = 255;
          channel_values[b].u8 = 255;

          if (!has_alpha)
            channel_values[a].u8 = 0;
          break;
        case COLOR_TRANSPARENT:
        case COLOR_BLACK_TRANSPARENT:
          channel_values[r].u8 = 0;
          channel_values[g].u8 = 0;
          channel_values[b].u8 = 0;
          if (has_alpha)
            channel_values[a].u8 = 0;
          break;
      }
   }
}

