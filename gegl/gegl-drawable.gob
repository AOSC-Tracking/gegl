%h{
#include "gegl-object.h"
%}
%{
#include "gegl-drawable.h"
#include "gegl-drawable-private.h"
#include "gegl-object-private.h"
#include "gegl-image-buffer.h"
#include "gegl-utils.h"
%}

class Gegl:Drawable from Gegl:Object {

  private GeglGraphicsState *graphics_state;
  private GeglImageBuffer *image_buffer;
  private gchar *name; 
  private gint width;
  private gint height;

  public
  GeglDrawable *	
  new(GeglColorModel *cm,     /* Also should pass storage info eventually*/ 
      char *name,
      gint w,
      gint h)
  {
    GeglDrawable * self = GEGL_DRAWABLE(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, cm, storage_info, w, h))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self,
      GeglColorModel *cm,    /*Also should pass storage info eventually*/ 
      char *name,
      gint w,
      gint h)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
	
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    /* Eventually we will want to pass the storage info here too */
    if (!self->_priv->image_buffer = gegl_image_buffer_new(cm, w, h)); 
     {
        g_warning ("Couldnt allocate GeglDrawable image buffer\n");
        return FALSE;
     }
    if (!self->_priv->graphics_state = gegl_graphics_state_new(cm)); 
     {
        g_warning ("Couldnt allocate GeglDrawable graphics state\n");
        return FALSE;
     }
    self->_priv->name = g_strdup (name); 
    self->_priv->width = w; 
    self->_priv->height = h; 
  	
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglDrawable *self = GEGL_Drawable(object); 

    gegl_destroy(self->_priv->image_buffer);
    gegl_destroy(self->_priv->graphics_state);
    g_free(self->_priv->name);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public 
  char * 
  get_name(self)
  {
    return self->_priv->name; 
  }

  public 
  GeglGraphicsState * 
  get_graphics_state(self)
  {
    return self->_priv->graphics_state; 
  }

  protected 
  GeglImageBuffer * 
  get_image_buffer(self)
  {
    return self->_priv->image_buffer; 
  }

  public 
  void
  fill(self, 
       GeglRect *rect)
  {
    GeglColor *fill_color = gegl_graphics_state_get_fg_color (
                            self->_priv->graphics_state);
    GeglOp *op = GEGL_OP(gegl_fill_op_new (
                           self->_priv->image_buffer, 
                           rect, fill_color);

    /* Do the fill */
    gegl_op_apply (op);
  }

  public 
  void
  apply_image(self, 
              GeglImageBuffer *src_image_buffer,
              gint x,     /* eventually change this to a rect */
              gint y      /* once scaling is implemented */
              )
  {
    gint src_width = gegl_image_buffer_width (src_imagea_buffer);
    gint src_height = gegl_image_buffer_height (src_image_buffer);
    GeglCompositeMode comp_mode = gegl_graphics_state_get_composite_mode (
                             self->_priv->graphics_state);
    GeglRect src_rect;
    GeglRect draw_rect;
    GeglOp *op; 

    /* Apply the image at (x,y) on the drawable*/
    gegl_rect_set(&src_rect, 0,0,src_width, src_height);
    gegl_rect_set(&draw_rect, x,y,src_width, src_height);


    /* Disallow scaling and off the edge of drawable for now*/
    if (draw_rect->w != src_rect.w || draw_rect->h != src_rect.h)
      {
        gwarning ("gegl_drawable_apply_image: cant scale images yet\n");
	return;
      }

    if (draw_rect.x + src_rect.w > self->_priv->width || 
        draw_rect.y + src_rect.h > self->_priv->height)
      {
        gwarning ("gegl_drawable_apply_image: cant apply images outside drawable yet\n");
	return;
      }

    op = GEGL_OP(gegl_composite_op_new (self->_priv->image_buffer, 
                      src_image_buffer, &draw_rect, &src_rect, comp_mode));

    /* Apply the composite op */
    gegl_op_apply (op);
  }

  public 
  void
  apply_operation(self)
  {
  }

  public 
  void
  bogus_for_comments(self) 
  {
#if 0
   /* Probably plenty of other operations too. */
   draw_text 
   draw_shape
#endif
  }
}
