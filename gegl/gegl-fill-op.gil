%h{
#include "gegl-point-op.h"
%}
%{
#include "gegl-fill-op.h"
#include "gegl-fill-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Fill:Op from Gegl:Point:Op {

  private GeglColor *fill_color;
  
  public 
  GeglFillOp *
  new (GeglColor *fill_color)
  {
    GeglFillOp * self = GEGL_FILL_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor (self,fill_color))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglColor *color)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (GEGL_POINT_OP(self), NULL, 0))
      return FALSE;

    {
      /* Allocate a color and set its channels to the passed one */  
      GeglColorModel *color_cm = gegl_color_get_color_model (color);
      self->_priv->fill_color = gegl_color_new (color_cm); 
      gegl_color_set (self->_priv->fill_color, color);
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglFillOp * self = GEGL_FILL_OP(object); 

    /* Dispose of the fill color*/
    gegl_object_destroy(GEGL_OBJECT(self->_priv->fill_color));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override(Gegl:Op)
  void
  prepare(GeglOp *op,
          GeglImage *dest,
	  GeglRect *dest_rect)
  {
    /* Save these so we can get them quickly in scanline func
       below */
    gegl_op_save_alphas(op);

    {
      GeglPointOp *point_op = GEGL_POINT_OP (op);
      GeglPointOpClass *point_op_class = 
	GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);

      point_op_class->scanline_func = gegl_fill_op_COLORSPACE_DATATYPE;
    }
  } 

  private
  void
  COLORSPACE_DATATYPE (GeglPointOp *point_op,
                       GeglImageIterator *dest_iter, 
		       GeglImageIterator **src_iters)
  {
    GeglOp *op = GEGL_OP(point_op);
    GeglFillOp *self = GEGL_FILL_OP (point_op);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);
    guint width = gegl_image_iterator_scanline_width (dest_iter);

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha,has_alpha);
    GENERIC_IMAGE_DECL_END
 
    dest_has_alpha = op->_priv->has_alpha; 
    
    gegl_image_iterator_get_scanline_data (dest_iter,
                (guchar**)dest_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT

    /* Fill the dest with the fill color */
    while (width--)
    {
      GENERIC_IMAGE_CODE_BEGIN
      dest_color = EXTERNAL_INIT (fill_values);
      if (dest_has_alpha)
	{
	  dest_alpha = EXTERNAL_INIT (fill_values);
        }
      dX(dest,1); 
      GENERIC_IMAGE_CODE_END
    }
  } 
}
