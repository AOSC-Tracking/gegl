%h{
#include "gegl-color-convert-op.h"
%}
%{
#include "gegl-color-convert-to-rgb-u16_4-op.h"
#include "gegl-color-convert-to-rgb-u16_4-op-private.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Color:Convert:To:Rgb:U16_4:Op from Gegl:Color:Convert:Op {

  private gboolean do_color_space;        /* is this a color space conversion? */
  private gboolean do_data;               /* is this a data type conversion? */

  private GeglColorModel *src_u16_4_cm;      /* color model with src color space, but u16_4 data*/ 
  private guint16 **src_u16_4_data;           /* u16_4 data pointers in case we use the above*/ 
  private gint src_num_channels;          /* num of channels in src */ 

  private gint last_width;                /* last scanline width */ 

  public 
  GeglColorConvertToRgbU16_4Op *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src,
       GeglRect *dest_rect,
       GeglRect *src_rect)
  {
    GeglColorConvertToRgbU16_4Op * self = 
       GEGL_COLOR_CONVERT_TO_RGB_U16_4_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src, dest_rect, src_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
       GeglImageBuffer *dest,
       GeglImageBuffer *src, 
       GeglRect *dest_rect,
       GeglRect *src_rect) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
   
    /* Chain up */
    if (!gegl_color_convert_op_constructor ( 
                   GEGL_COLOR_CONVERT_OP (self), 
                   dest,src,dest_rect,src_rect))
      return FALSE;

    {
      GeglPointOp *point_op = GEGL_POINT_OP (self);
      GeglPointOpClass *point_op_class = 
         GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
      GeglColorConvertOpPrivate *color_convert_opP = 
       (GeglColorConvertOpPrivate*)(GEGL_COLOR_CONVERT_OP (self)->_priv);

      GeglColorSpace src_color_space = gegl_color_model_color_space (
                                         color_convert_opP->src_cm); 
      GeglChannelDataType src_data_type = gegl_color_model_data_type ( 
                                            color_convert_opP->src_cm); 
      gint src_num_channels = gegl_color_model_num_channels (
                                color_convert_opP->src_cm); 
      gboolean src_has_alpha = gegl_color_model_has_alpha (
                                color_convert_opP->src_cm); 

      /* 
         Figure out whether we have to color space 
         and/or data conversions
      */
      self->_priv->do_color_space = 
                 (src_color_space == RGB) ? FALSE: TRUE;

      self->_priv->do_data = 
                 (src_data_type == U16_4) ? FALSE: TRUE;

      self->_priv->src_num_channels = src_num_channels;
      self->_priv->last_width = 0;

      /* make these null in case we dont need them */
      self->_priv->src_u16_4_data = NULL;
      self->_priv->src_u16_4_cm = NULL;

      /* 
       If we have to convert src to u16_4 first will need u16_4 buffers
       with num channels of the source.
      */

      if (self->_priv->do_color_space && 
         self->_priv->do_data)
        { 
          gint i;

          /* allocate the u16_4 pointers */
         self->_priv->src_u16_4_data = g_new(guint16*, src_num_channels);

          /* allocate the actual u16_4 data later*/
         for (i = 0; i < src_num_channels; i++)
           self->_priv->src_u16_4_data[i] = NULL;

          
          
          /* This allocates a u16_4 color model with same color space as src*/
         self->_priv->src_u16_4_cm = gegl_color_model_factory (
                                            src_color_space, 
                                            U16_4,
                                            src_has_alpha);
        }
      
      point_op_class->scanline_func = 
           gegl_color_convert_to_rgb_u16_4_op_scanline;
    }
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglColorConvertToRgbU16_4Op *self = 
      GEGL_COLOR_CONVERT_TO_RGB_U16_4_OP (object); 

    if(self->_priv->src_u16_4_data)
      {
       free_u16_4_data(self);
       g_free (self->_priv->src_u16_4_data);  
      }

    /* Free the u16_4 cm */
    if (self->_priv->src_u16_4_data)
      gegl_object_destroy (GEGL_OBJECT (self->_priv->src_u16_4_cm));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  alloc_u16_4_data(self, gint width)
  {
    gint i;
    for (i = 0; i < self->_priv->src_num_channels; i++)
      self->_priv->src_u16_4_data[i] = g_new(guint16, width);
  } 

  private
  void
  free_u16_4_data(self)
  {
    gint i;
    for (i = 0; i < self->_priv->src_num_channels; i++)
      if (!self->_priv->src_u16_4_data[i])
        g_free (self->_priv->src_u16_4_data[i]);
  } 

  private
  void 
  scanline(GeglPointOp *point_op)
  {
    GeglColorConvertToRgbU16_4Op *self = 
      GEGL_COLOR_CONVERT_TO_RGB_U16_4_OP (point_op);
    GeglColorConvertOpPrivate *color_convert_opP = 
      (GeglColorConvertOpPrivate*)(GEGL_COLOR_CONVERT_OP (point_op)->_priv);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);

    gint width = point_opP->scanline_width;

    gboolean color_space_only = self->_priv->do_color_space && !self->_priv->do_data;
    gboolean data_only = self->_priv->do_data && !self->_priv->do_color_space;
 
    /* Make the dest and src point to the data to convert */
    gegl_image_iterator_get_scanline_data (point_opP->iterators[0], 
                                         color_convert_opP->dest_data);

    gegl_image_iterator_get_scanline_data (point_opP->iterators[1], 
                                         color_convert_opP->src_data);

    if (color_space_only) 
      {
       gegl_color_model_convert_to_rgb (color_convert_opP->src_cm,
                                color_convert_opP->dest_data, 
                                color_convert_opP->src_data, 
                                width);
      }
    else if (data_only)
      {
       gegl_color_model_convert_to_u16_4 (color_convert_opP->src_cm,
                                  (guchar**)color_convert_opP->dest_data, 
                                  color_convert_opP->src_data, 
                                  width);
      }
    else
      {
        if (self->_priv->last_width != width) 
          {
           free_u16_4_data (self);
           alloc_u16_4_data (self, width);
         }

        /* convert to a u16_4 src and then to u16_4 rgb */
        gegl_color_model_convert_to_u16_4 (color_convert_opP->src_cm, 
                                   (guchar**)self->_priv->src_u16_4_data, 
                                   color_convert_opP->src_data,
                                   width);

        gegl_color_model_convert_to_rgb (self->_priv->src_u16_4_cm, 
                              color_convert_opP->dest_data, 
                              (guchar**)self->_priv->src_u16_4_data,
                              width);
      }

    self->_priv->last_width = width;
  } 
}
