%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_TILE_ITERATOR__
#define __TYPEDEF_GEGL_TILE_ITERATOR__
typedef struct _GeglTileIterator  GeglTileIterator;
#endif

%}

%{
#include "gegl-statistics-op.h"
#include "gegl-statistics-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-manager.h"
#include "gegl-image-manager-private.h"  /*friend*/
#include "gegl-color-model.h"
#include "gegl-node.h"
#include "gegl-object-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-utils.h"
%}

class Gegl:Statistics:Op from Gegl:Op {

  /**
   * constructor:
   * @self: a #GeglStatisticsOp.
   * @inputs: #GeglImage list.
   *
   * Initialize the #GeglStatisticsOp.
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self, 
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), inputs))
      return FALSE;

    return TRUE;
  }


  /**
   * apply:
   * @self_op: a #GeglOp.
   * @dest: a destination.
   * @roi: a region of interest.
   *
   * This is the main statistics image processing routine. It evaluates the
   * graph rooted on this node for pixels inside the @roi.
   *
   **/ 
  override(Gegl:Op)
  void
  apply(GeglOp *self_op,
        GeglImageBuffer *dest,
        GeglRect *roi)
  {
    /* Get the singleton image manager. */
    GeglImageManager *image_manager = gegl_image_manager_instance();

    /* Call image manager, which calls the pixel processing routines.  */
    gegl_image_manager_apply(image_manager, self_op, dest, roi);
  }


  /**
   * procss:
   * @self_image: a #GeglOp
   * @request_list: #GeglOpRequest list of inputs.
   *
   * For each #GeglTile and desired subportion rect for a #GeglOpRequest, get a
   * #GeglTileIterator. Then iterate through the scanlines and call the
   * installed scanline function of subclass. Pass the tile iterators and width
   * in each scanline function call. 
   * 
   **/
  override (Gegl:Op)
  void  
  process(GeglOp *self_op,
          GList *requests)
  {
    GeglOpRequest * request;
    gint i,j;
    gint width, height;
    GeglStatisticsOp *self =  GEGL_STATISTICS_OP(self_op);
    GeglStatisticsOpClass *self_class = 
        GEGL_STATISTICS_OP_CLASS (GTK_OBJECT(self_op)->klass);
    GeglNode *self_node = GEGL_NODE(self_op);
    gint num_inputs = gegl_node_num_inputs(self_node);
    GeglTileIterator **iters = g_new (GeglTileIterator*, num_inputs);

    LOG_DEBUG("node %x type %s", (guint)self_op,
               gegl_object_type_name(GEGL_OBJECT(self_op)));

    LOG_DEBUG("num_inputs is %d", num_inputs);

    /* Get tile iterators for the sources. */
    for (i = 0; i < num_inputs; i++)
      {
         LOG_DEBUG("getting tile iterator for input %d", i); 

         request = (GeglOpRequest*)g_list_nth_data(requests,i); 

         /* Get the tile, if it is not NULL */ 
         if(request->tile)
           {
             LOG_DEBUG("tile is %x", (guint)request->tile); 
             iters[i] = gegl_tile_iterator_new (request->tile, &request->rect);
             gegl_tile_iterator_first (iters[i]);
           }
         else
           iters[i] = NULL;
      }

    request = (GeglOpRequest*)g_list_nth_data(requests,0); 

    width = request->rect.w;
    height = request->rect.h;

    LOG_DEBUG("width height %d %d", width, height); 

    /* Now iterate over the scanlines in the src[0]. */
    for(j=0; j < height; j++)
      {
        LOG_DEBUG("doing scanline %d", j); 

        /* Call the subclass scanline func. */
        (self_class->scanline_func)(self, iters, width);

        LOG_DEBUG("back from scanline %d", j); 
        /* Advance all the scanlines. */
        for (i = 0; i < num_inputs; i++)
          {
            LOG_DEBUG("advancing %d th iterator", i); 
            if(iters[i])
              gegl_tile_iterator_next(iters[i]);
          }

      } 

    /* Free the iterators */
    for (i = 0; i < num_inputs; i++)
      {
        if (iters[i])
          gegl_object_unref (GEGL_OBJECT (iters[i])); 
      }

    /* Free the array of iterator pointers */
    g_free (iters);
  }


  /**
   * scanline:
   * @self: a #GeglStatisticsOp
   * @iters: #GeglTileIterator array.
   * @width: width of scanline.
   *
   * Subclasses install this function, usually in their prepare routine.
   *
   **/
  virtual private 
  void 
  scanline_func (self, 
                 GeglTileIterator **iters, 
                 gint width);

}
