%h{
#include "gegl-single-src-op.h"
%}
%{
#include "gegl-test-op.h"
#include "gegl-test-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-image-private.h"
#include "gegl-op.h"
#include "gegl-op-private.h"
#include "gegl-object-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Test:Op from Gegl:Single:Src:Op {


  /**
   * new:
   * @src: input #GeglOp.
   * 
   * Creates a new #GeglTestOp. 
   *
   * Returns: a new #GeglTestOp.
   **/ 
  public 
  GeglTestOp *
  new (GeglOp *src)
  {
    GeglTestOp * self = GEGL_TEST_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor: 
   * @self: a #GeglTestOp.
   * @src: input #GeglOp.
   *
   * Initializes a #GeglTestOp.
   * 
   * Returns: TRUE if constructed sucessfully.
   **/
  protected 
  gboolean 
  constructor(self,
              GeglOp *src)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;

    /* Chain up */
    if (!gegl_single_src_op_constructor (GEGL_SINGLE_SRC_OP(self),src))
      return FALSE;

    return TRUE;
  }


  /**
   * prepare:
   * @self_op: a #GeglOp.
   * @requests: #GeglOpRequest list.
   *
   * Prepares for image processing. Installs a scanline function pointer. 
   *
   **/
  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GList * requests)
  {
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_op)->klass);
    GeglOpRequest *dest_request = 
      (GeglOpRequest*)g_list_nth_data(requests,0); 

    GeglTile *dest = dest_request->tile;
    GeglColorModel * dest_cm = gegl_tile_get_color_model (dest);

    g_return_if_fail(dest_cm);

    /* Get correct scanline func for this color model */
    self_point_op_class->scanline_func = scanline;        
  } 


  /**
   * scanline:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline (GeglPointOp *self_point_op,
            GeglTileIterator **iters,
            gint width)
  {
    GeglColorModel *dest_cm = gegl_tile_iterator_get_color_model(iters[0]);
    GeglColorModel *src_cm = gegl_tile_iterator_get_color_model(iters[1]);

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha,has_alpha);
    Pixel src(color,alpha,has_alpha);
    GENERIC_IMAGE_DECL_END

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
    src_has_alpha = gegl_color_model_has_alpha(src_cm); 

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT
    
    while (width--)
      {
        GENERIC_IMAGE_CODE_BEGIN
        dest = .5 * src; 
        dX(dest,1);
        dX(src,1);
        GENERIC_IMAGE_CODE_END
      }
  }
}
