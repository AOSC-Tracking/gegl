%h{
#include "gegl-point-op.h"
%}
%{
#include "gegl-fill-op.h"
#include "gegl-fill-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-image-private.h"
#include "gegl-op-private.h"
#include "gegl-object-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Fill:Op from Gegl:Point:Op {

  private GeglColor *fill_color;

  /**
   * new:
   * @fill_color: a fill #GeglColor.
   * 
   * Creates a new #GeglFillOp. 
   *
   * Returns: a new #GeglFillOp.
   **/ 
  public 
  GeglFillOp *
  new (GeglColor *fill_color)
  {
    GeglFillOp * self = GEGL_FILL_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor (self,fill_color))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglFillOp.
   * @fill_color: a fill #GeglColor.
   * 
   * Initializes a #GeglFillOp. 
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self, 
              GeglColor *fill_color)
  {
    g_return_val_if_fail(fill_color,FALSE);

    if(GEGL_OBJECT(self)->constructed)
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (GEGL_POINT_OP(self), NULL))
      return FALSE;


    /* Keep a reference to the color */
    gegl_object_ref(GEGL_OBJECT(fill_color));
    self->_priv->fill_color = fill_color; 

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Frees memory allocated by this objects. Unrefs the fill color.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *self_object)
  {
    GeglFillOp * self = GEGL_FILL_OP(self_object); 

    /* Delete the reference to the color*/
    gegl_object_unref(GEGL_OBJECT(self->_priv->fill_color));

    /* Chain up on destroy */
    PARENT_HANDLER (self_object)
  }


  /**
   * compute_derived_color_model:
   * @self_image: a #GeglImage
   * @inputs: a #GeglImage list - should be NULL here.
   *
   * Computes a derived color model for this op. Just take the color model of
   * the fill color. 
   * 
   *  
   **/
  override (Gegl:Image)
  void 
  compute_derived_color_model(GeglImage *self_image,
                              GList *inputs) 
  {
    GeglFillOp * self = GEGL_FILL_OP(self_image); 
    GeglColorModel *fill_color_cm = 
          gegl_color_get_color_model(self->_priv->fill_color);

    gegl_image_set_derived_color_model(self_image,fill_color_cm);
  }


  /**
   * prepare:
   * @self_op: a #GeglImage.
   * @requests: #GeglImageRequest list.
   *
   * Prepares for image processing. Installs a scanline function pointer. 
   *
   **/
  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GList * requests)
  {
    GeglFillOp * self = GEGL_FILL_OP(self_op); 
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self)->klass);

    GeglOpRequest *dest_request = 
      (GeglOpRequest*)g_list_nth_data(requests,0); 
    GeglTile *dest = dest_request->tile;
    GeglColorModel * dest_cm = gegl_tile_get_color_model (dest);
    GeglColorModel * fill_cm = 
      gegl_color_get_color_model (self->_priv->fill_color);

    g_return_if_fail (dest_cm == fill_cm);

    {
      GeglColorSpace colorspace = gegl_color_model_color_space(fill_cm);
      GeglChannelDataType data_type = gegl_color_model_data_type (fill_cm);

      switch (colorspace)
        {
          case GEGL_COLOR_SPACE_RGB:
            switch (data_type)
              {
              case GEGL_U8:
                self_point_op_class->scanline_func = scanline_rgb_u8;
                break;
              case GEGL_FLOAT:
                self_point_op_class->scanline_func = scanline_rgb_float;
                break;
              case GEGL_U16:
                self_point_op_class->scanline_func = scanline_rgb_u16;
                break;
              default:
                g_warning("gegl_fill_op_prepare: Can't find data_type\n");    
                break;

              }
            break;
          case GEGL_COLOR_SPACE_GRAY:
            switch (data_type)
              {
              case GEGL_U8:
                self_point_op_class->scanline_func = scanline_gray_u8;
                break;
              case GEGL_FLOAT:
                self_point_op_class->scanline_func = scanline_gray_float;
                break;
              case GEGL_U16:
                self_point_op_class->scanline_func = scanline_gray_u16;
                break;
              default:
                g_warning("gegl_fill_op_prepare: Can't find data_type\n");    
                break;
              }
            break;
          default:
            g_warning("gegl_fill_op_prepare: Can't find colorspace\n");    
            break;
        }
    }
  } 


  /**
   * scanline_rgb_u8:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_rgb_u8 (GeglPointOp *self_point_op,
                   GeglTileIterator **iters,
                   gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    guint8 *dest_data[4];
    gboolean dest_has_alpha;
    guint8 *dest_r, *dest_g, *dest_b, *dest_alpha=NULL;
 
    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
    
    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);

    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];
    if (dest_has_alpha)
      dest_alpha = dest_data[3];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_r = fill_values[0].u8;
        *dest_g = fill_values[1].u8;
        *dest_b = fill_values[2].u8;
        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[3].u8;
          }
        dest_r++;
        dest_g++;
        dest_b++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 


  /**
   * scanline_rgb_float:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_rgb_float (GeglPointOp *self_point_op,
                      GeglTileIterator **iters,
                      gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    gfloat *dest_data[4];
    gboolean dest_has_alpha;
    gfloat *dest_r, *dest_g, *dest_b, *dest_alpha=NULL;

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
    
    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);

    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];
    if (dest_has_alpha)
      dest_alpha = dest_data[3];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_r = fill_values[0].f;
        *dest_g = fill_values[1].f;
        *dest_b = fill_values[2].f;

        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[3].f;
          }
        dest_r++;
        dest_g++;
        dest_b++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 


  /**
   * scanline_rgb_u16:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_rgb_u16 (GeglPointOp *self_point_op,
                    GeglTileIterator **iters,
                    gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    guint16 *dest_data[4];
    gboolean dest_has_alpha;
    guint16 *dest_r, *dest_g, *dest_b, *dest_alpha=NULL;

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
 
    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];
    if (dest_has_alpha)
      dest_alpha = dest_data[3];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_r = fill_values[0].u16;
        *dest_g = fill_values[1].u16;
        *dest_b = fill_values[2].u16;
        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[3].u16;
          }
        dest_r++;
        dest_g++;
        dest_b++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 


  /**
   * scanline_gray_u8:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_gray_u8 (GeglPointOp *self_point_op,
                    GeglTileIterator **iters,
                    gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    guint8 *dest_data[2];
    gboolean dest_has_alpha;
    guint8 *dest_gray, *dest_alpha=NULL;

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
 
    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);

    dest_gray = dest_data[0];
    if (dest_has_alpha)
      dest_alpha = dest_data[1];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_gray = fill_values[0].u8;
        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[1].u8;
          }
        dest_gray++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 


  /**
   * scanline_gray_float:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_gray_float (GeglPointOp *self_point_op,
                       GeglTileIterator **iters,
                       gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    gfloat *dest_data[2];
    gboolean dest_has_alpha;
    gfloat *dest_gray, *dest_alpha=NULL;

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);

    dest_gray = dest_data[0];
    if (dest_has_alpha)
      dest_alpha = dest_data[1];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_gray = fill_values[0].f;
        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[1].f;
          }
        dest_gray++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 


  /**
   * scanline_gray_u16:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterators array. 
   * @width: width of scanline.
   *
   * Processes a scanline.
   *
   **/
  private
  void
  scanline_gray_u16 (GeglPointOp *self_point_op,
                     GeglTileIterator **iters,
                     gint width)
  {
    GeglFillOp *self = GEGL_FILL_OP(self_point_op);
    GeglColorModel *dest_cm = 
      gegl_tile_iterator_get_color_model(iters[0]);
    GeglChannelValue *fill_values = 
      gegl_color_get_channel_values (self->_priv->fill_color);

    guint16 *dest_data[2];
    gboolean dest_has_alpha;
    guint16 *dest_gray, *dest_alpha=NULL;

    dest_has_alpha = gegl_color_model_has_alpha(dest_cm); 
 
    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);

    dest_gray = dest_data[0];
    if (dest_has_alpha)
      dest_alpha = dest_data[1];

    /* Fill the dest with the fill color */
    while (width--)
      { 
        *dest_gray = fill_values[0].u16;
        if (dest_has_alpha)
          { 
            *dest_alpha = fill_values[1].u16;
          }
        dest_gray++;
        if (dest_has_alpha)
          dest_alpha++;
      }
  } 

}
