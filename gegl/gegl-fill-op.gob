%h{
#include "gegl-point-op.h"
#include "gegl-image-buffer.h"
%}
%{
#include "gegl-fill-op.h"
#include "gegl-fill-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Fill:Op from Gegl:Point:Op {

  private GeglColor *fill_color;
  
  public 
  GeglFillOp *
  new (GeglImageBuffer *dest, 
       GeglRect *dest_rect,
       GeglColor *fill_color)
  {
    GeglFillOp * self = GEGL_FILL_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, dest_rect, fill_color))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
	GeglImageBuffer *dest, 
	GeglRect *dest_rect,
	GeglColor *color)
  {

    GeglChannelDataType data_type;
    GeglColorModel *cm; 
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
	GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (
	GEGL_POINT_OP(self), &dest, dest_rect, 1))
      return FALSE;

    /*
	Now based on the image buffers's color model(s)/data storage(s)
	choose one of our scanline funcs to install
	This is where some "autogeneration" happens.
    */ 

    cm = gegl_image_buffer_color_model (dest);
    data_type = gegl_color_model_data_type (cm);
    switch (data_type)
    {
      case FLOAT:
	point_op_class->scanline_func = gegl_fill_op_RGB_FLOAT; 	
	break;
      case U8:
	point_op_class->scanline_func = gegl_fill_op_RGB_U8;
	break;
      default:
	g_warning("PrintOp: Color Model data type none or unknown\n");
	point_op_class->scanline_func = NULL; 	
	return FALSE;
    }


    /* Allocate a color and set its channels to the passed one */  
    {
      GeglColorModel *cm = gegl_color_get_color_model (color);
      self->_priv->fill_color = gegl_color_new (cm); 
      gegl_color_set (self->_priv->fill_color, color);
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglFillOp * self = GEGL_FILL_OP(object); 

    /* Dispose of the fill color*/
    g_free(self->_priv->fill_color);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  RGB_FLOAT (GeglPointOp *point_op)
  {
    /*
	Whats the algorithm for this code?	
	DEST = CONST

    */ 
    guint width;
    gfloat * dest_data[3]; 
    gfloat *r, *g, *b;
    gfloat color_r, color_g, color_b; 
    GeglFillOp *self = GEGL_FILL_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 
    GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv); 

    GeglChannelValue *fill_values = gegl_color_get_channel_values(
					self->_priv->fill_color);
    /* Get the fill color r,g,b */
    color_r = fill_values[0].f;
    color_g = fill_values[1].f;
    color_b = fill_values[2].f;

    width = point_opP->scanline_width;

    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (opP->image_buffers[0], 
		(guchar**)dest_data);

    /* Make r,g,b point to the dest image data */
    r = dest_data[0];
    g = dest_data[1];
    b = dest_data[2];

    /* Fill the dest with the fill color */
    while (width--)
    {
      *r++ = color_r;
      *g++ = color_g;
      *b++ = color_b;
    }
  }

  private
  void
  RGB_U8 (GeglPointOp *point_op)
  {
    /*
        Whats the algorithm for this code?
        DEST = CONST

    */
    guint width;
    guchar *dest_data[3];
    guchar *r, *g, *b;
    guchar color_r, color_g, color_b;
    GeglFillOp *self = GEGL_FILL_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);
    GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

    GeglChannelValue *fill_values = gegl_color_get_channel_values(
                                        self->_priv->fill_color);
    /* Get the fill color r,g,b */
    color_r = fill_values[0].f;
    color_g = fill_values[1].f;
    color_b = fill_values[2].f;

    width = point_opP->scanline_width;

    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                (guchar**)dest_data);

    /* Make r,g,b point to the dest image data */
    r = dest_data[0];
    g = dest_data[1];
    b = dest_data[2];

    /* Fill the dest with the fill color */
    while (width--)
    {
      *r++ = color_r;
      *g++ = color_g;
      *b++ = color_b;
    }
  } 
}
