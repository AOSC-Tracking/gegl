%h{
#include "gegl-single-src-op.h"
%}

%privateheader{
#include "gegl-color-model.h"
%}

%{
#include "gegl-copy-op.h"
#include "gegl-copy-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-op-private.h"
#include "gegl-node.h"
#include "gegl-image-private.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Copy:Op from Gegl:Single:Src:Op {
  
  private ConvertFunc copy_func;

  public 
  GeglCopyOp *
  new (GeglImage *src)
  {
    GeglCopyOp * self = GEGL_COPY_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor (self, src))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gtk_object_ref(GTK_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImage *src)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    self->_priv->copy_func = NULL;

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GeglImage *dest,
          GeglRect *dest_rect)
  {
    GeglCopyOp *self = SELF (self_op);
    GeglNode *self_node = GEGL_NODE(self_op);
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_op)->klass);

    GeglImage *input0 = GEGL_IMAGE(gegl_node_get_nth_input(self_node,0));

    GeglColorModel * dest_cm = gegl_image_color_model (dest);
    GeglColorModel * src_cm = gegl_image_color_model (input0); 

    /* At this point the colormodels should match */

    /* Get the name of the interface that converts(ie copies) from src cm */ 
    gchar *converter_name = 
      gegl_color_model_get_converter_interface_name (src_cm); 

    /* Now get the copy func*/ 
    self->_priv->copy_func = 
      (ConvertFunc)gegl_object_query_interface (GEGL_OBJECT(dest_cm), 
						converter_name);   
    g_free (converter_name);

    /* Set the scanline version of this class to be called */
    self_point_op_class->scanline_func = gegl_copy_op_scanline;
  }

  private 
  void
  scanline(GeglPointOp *self_point_op,
           GeglImageIterator *dest_iter, 
           GeglImageIterator **src_iters)
  {
    GeglCopyOp *self = SELF(self_point_op);
    GeglImage * dest_image = gegl_image_iterator_get_image(dest_iter);
    GeglImage * src_image = gegl_image_iterator_get_image(src_iters[0]);
    GeglColorModel * dest_cm = gegl_image_color_model(dest_image);
    GeglColorModel * src_cm = gegl_image_color_model(src_image);
    guint dest_nchans = gegl_color_model_num_channels (dest_cm);
    guint src_nchans = gegl_color_model_num_channels (src_cm);

    guint width = gegl_image_iterator_scanline_width (dest_iter);

    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_nchans);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_nchans);

    gegl_image_iterator_get_scanline_data (dest_iter, dest_data);
    gegl_image_iterator_get_scanline_data (src_iters[0], src_data);

    (self->_priv->copy_func) (dest_cm, src_cm, dest_data, src_data, width); 

    g_free (dest_data);
    g_free (src_data);
  }
}
