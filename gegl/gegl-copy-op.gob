%h{
#include "gegl-single-src-op.h"
%}

%privateheader{
#include "gegl-color-model.h"
%}

%{
#include "gegl-copy-op.h"
#include "gegl-copy-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-image-private.h"
#include "gegl-op-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Copy:Op from Gegl:Single:Src:Op {
  
  private ConvertFunc copy_func;


  /**
   * new: 
   * @src: an input #GeglOp.
   * 
   * Creates a new #GeglCopyOp.
   * 
   * Returns: a new #GeglCopyOp.
   **/
  public 
  GeglCopyOp *
  new (GeglOp *src)
  {
    GeglCopyOp * self = GEGL_COPY_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor (self, src))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglCopyOp.
   * @src: an input #GeglOp.
   *
   * Initializes a #GeglCopyOp.
   * 
   * Returns: TRUE if constructed successfully. 
   **/
  protected 
  gboolean 
  constructor(self, 
              GeglOp *src)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    self->_priv->copy_func = NULL;

    return TRUE;
  }


  /**
   * prepare:
   * @self_op: a #GeglImage.
   * @requests: #GeglOpRequest list.
   *
   * Prepares for image processing. Finds a copy converter from the input to
   * output. Input and output color models should match at this point. Sets up
   * scanline function pointer.
   *
   **/
  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GList * requests)
  {
    GeglCopyOp *self = GEGL_COPY_OP(self_op);
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_op)->klass);
    GeglOpRequest *dest_request = 
      (GeglOpRequest*)g_list_nth_data(requests,0); 
    GeglColorModel * dest_cm =
      gegl_tile_get_color_model (dest_request->tile);
    GeglOpRequest *src_request =
      (GeglOpRequest*)g_list_nth_data(requests,1); 
    GeglColorModel * src_cm =
      gegl_tile_get_color_model (src_request->tile);

    g_return_if_fail(dest_cm);
    g_return_if_fail(src_cm);

    /* The ColorModels should match now. */
    g_return_if_fail(dest_cm == src_cm);

      {
        /* Get the name of the interface that converts
           (ie copies) from src cm */ 
        gchar *converter_name = 
          gegl_color_model_get_convert_interface_name (src_cm); 

        /* Now get the copy func*/ 
        self->_priv->copy_func =
          (ConvertFunc)gegl_object_query_interface (GEGL_OBJECT(dest_cm), 
                                                    converter_name);   
        g_free (converter_name);

        /* Set the scanline version of this class to be called */
        self_point_op_class->scanline_func = scanline;
      }
  }


  /**
   * scanline:
   * @self_point_op: a #GeglPointOp.
   * @iters: #GeglTileIterator array. 
   * @width: width of scanline. 
   *
   * Processes a scanline. Calls the installed copy_func.
   *
   **/
  private 
  void
  scanline(GeglPointOp *self_point_op,
           GeglTileIterator **iters,
           gint width)
  {
    GeglCopyOp *self = GEGL_COPY_OP (self_point_op);
    GeglColorModel *dest_cm = gegl_tile_iterator_get_color_model(iters[0]);
    GeglColorModel *src_cm = gegl_tile_iterator_get_color_model(iters[1]);
    guint dest_nchans = gegl_color_model_num_channels (dest_cm);
    guint src_nchans = gegl_color_model_num_channels (src_cm);
    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_nchans);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_nchans);

    gegl_tile_iterator_get_current(iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current(iters[1], (gpointer*)src_data);

    (self->_priv->copy_func) (dest_cm, src_cm, dest_data, src_data, width); 

    g_free (dest_data);
    g_free (src_data);
  }
}
