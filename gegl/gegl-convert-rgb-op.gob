%h{
#include "gegl-point-op.h"
#include "gegl-image-buffer.h"
%}
%{
#include "gegl-convert-rgb-op.h"
#include "gegl-convert-rgb-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:ConvertRGB:Op from Gegl:Point:Op {

  
  public 
  GeglConvertRGBOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src,
       GeglRect *dest_rect,
       GeglRect *src_rect)
  {
    GeglConvertRGBOp * self = GEGL_CONVERT_RGB_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src, dest_rect, src_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
	GeglImageBuffer *dest,
	GeglImageBuffer *src, 
	GeglRect *dest_rect,
	GeglRect *src_rect) 
  {

    GeglImageBuffer *image_buffers[2];
    GeglRect rects[2]; 
    GeglChannelDataType dest_data_type, src_data_type;
    GeglColorModel *dest_cm, *src_cm; 
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
        GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
   
    image_buffers[0] = dest;
    image_buffers[1] = src;
    rects[0] = dest_rect;
    rects[1] = src_rect;
 
    /* Chain up */
    if (!gegl_point_op_constructor (
         GEGL_POINT_OP(self), image_buffers, rects, 2))
      return FALSE;

    /*
      Now based on the image buffers's color model(s)/data storage(s)
      choose one of our scanline funcs to install
      This is where some "autogeneration" happens.
    */ 

    dest_cm = gegl_image_buffer_color_model (dest);
    src_cm = gegl_image_buffer_color_model (src);
    dest_data_type = gegl_color_model_data_type (dest_cm);
    src_data_type = gegl_color_model_data_type (src_cm);
    dest_cs = gegl_color_model_color_space(dest_cm);
    src_cs = gegl_color_model_color_space(src_cm);

    switch(src_cs){
      case RGB:
/* converting from rgb to rgb */
      switch(src_data_type){
        case FLOAT:
          point_op_class->scanline_func = gegl_convert_op_RGB_FLOAT;
          break;
        case U8:
          point_op_class->scanline_func = gegl_convert_op_RGB_U8;
          break;
        default:
          break;
         }
      break;
      case HSV:
      switch(src_data_type){
            /* confert from hsv to rgb */ 
        case FLOAT:
          point_op_class->scanline_func = gegl_convert_op_HSV_FLOAT;
          break;  
        case U8:
          point_op_class->scanline_func = gegl_convert_op_HSV_U8;
          break;  
        default:
          break; 
         }
      break;
      default:
        /* convert from unknown to rgb */
        point_op_class->scanline_func = gegl_convert_op_UNKNOWN;
      break;
    }

    /* Allocate a color and set its channels to the passed one */  
    {
#if 0
      GeglColorModel *cm = gegl_color_get_color_model (color);
      self->_priv->convert->rgb_color = gegl_color_new (cm); 
      gegl_color_set (self->_priv->convert-rgb_color, color);
#endif
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglConvertRGBOp * self = GEGL_CONVERT_RGB_OP(object); 

    /* Dispose of the convert-rgb color*/
    g_free(self->_priv->convert-rgb_color);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  RGB_FLOAT (GeglPointOp *point_op)
  {
  /* Ok, we are converting from a RGB FLOAT image buffer
     to an RGB some data type image buffer
  */
  gboolean has_alpha;
  guint width;
  guchar *dest_data[4], *src_data[4];
  guchar *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b;
  GeglFillOp *self = GEGL_FILL_OP (point_op);
  GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_pr iv);  
  GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

  has_alpha = gegl_color_model_has_alpha(gegl_image_buffer_color_model (opP->image_buffers[0])) &&
              gegl_color_model_has_alpha(gegl_image_buffer_color_model (opP->image_buffers[1]));

  width = point_opP->scanline_width;

  gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                                 (guchar**)dest_data);
  gegl_image_buffer_get_scanline_data (opP->image_buffers[1],
                                 (guchar**)src_data);

  dest_r = dest_data[0];
  dest_g = dest_data[1];
  dest_b = dest_data[2];
  src_r = src_data[0];
  src_g = src_data[1];
  src_b = src_data[2];

  /* find out what is the final data type */
  dest_cm = gegl_image_buffer_color_model (opP->image_buffers[0]);
  dest_data_type = gegl_color_model_data_type (dest_cm);

  /* lets case on the dest data type */
  switch(dest_data_type){
    case FLOAT:
      /* we done have to do anything, just put src into dest */
      while(width--){
                      *dest_r++ = *src_r++;
                      *dest_g++ = *src_g++;
                      *dest_b++ = *src_b++;
        if(has_alpha) *(dest_data[3])++ = *(src_data[3])++;
      }
    break;
    case U8:
      while(width--){
                      *dest_r++ = (float) *src_r++ / 255.0;
                      *dest_g++ = (float) *src_g++ / 255.0;
                      *dest_b++ = (float) *src_b++ / 255.0;
                      if(has_alpha) *(dest_data[3])++ = (float) *(src_data[3])++ / 255.0;
      }
    break;
    default:
    break;
  }
  }

  private
  void
  RGB_U8 (GeglPointOp *point_op)
  {
  /* Ok, we are converting from a RGB U8 image buffer
     to an RGB some data type image buffer
  */
  gboolean has_alpha;
  guint width;
  guchar *dest_data[4], *src_data[4];
  guchar *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b;
  GeglFillOp *self = GEGL_FILL_OP (point_op);
  GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_pr iv);
  GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

  gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                  (guchar**)dest_data);
  gegl_image_buffer_get_scanline_data (opP->image_buffers[1],
                  (guchar**)src_data);

  has_alpha = gegl_color_model_has_alpha(gegl_image_buffer_color_model (opP->image_buffers[0])) &&
              gegl_color_model_has_alpha(gegl_image_buffer_color_model (opP->image_buffers[1]));

  width = point_opP->scanline_width;

  dest_r = dest_data[0];
  dest_g = dest_data[1];
  dest_b = dest_data[2];
  src_r = src_data[0];
  src_g = src_data[1];
  src_b = src_data[2];

  /* find out what is the final data type */
  dest_cm = gegl_image_buffer_color_model (opP->image_buffers[0]);
  dest_data_type = gegl_color_model_data_type (dest_cm);

  /* lets case on the dest data type */
  switch(dest_data_type){
    case FLOAT:
      /* we done have to do anything, just put src into dest */
      while(width--){
        *dest_r++ = *src_r++ * 255.0;
        *dest_g++ = *src_g++ * 255.0;
        *dest_b++ = *src_b++ * 255.0;
        if(has_alpha) *(dest_data[3])++ = *(src_data[3])++ * 255.0;
      }
    break;
    case U8:
      while(width--){
        *dest_r++ = *src_r++;
        *dest_g++ = *src_g++;
        *dest_b++ = *src_b++;
        if(has_alpha) *(dest_data[3])++ = *(src_data[3])++;
      }
    break;
    default:
    break;
  }
  }

  private
  void
  HSV_FLOAT (GeglPointOp *point_op)
  {
  /* Ok, we are converting from a HSV FLOAT image buffer
     to an RGB some data type image buffer
  */
  guint width;
  guchar *dest_data[4], *src_data[4];
  guchar *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b;
  GeglFillOp *self = GEGL_FILL_OP (point_op);
  GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_pr iv);
  GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

  width = point_opP->scanline_width;

  gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                  (guchar**)dest_data);
  gegl_image_buffer_get_scanline_data (opP->image_buffers[1],
                  (guchar**)src_data);

  dest_r = dest_data[0];
  dest_g = dest_data[1];
  dest_b = dest_data[2];
  src_r = src_data[0];
  src_g = src_data[1];
  src_b = src_data[2];

  /* find out what is the final data type */
  dest_cm = gegl_image_buffer_color_model (opP->image_buffers[0]);
  dest_data_type = gegl_color_model_data_type (dest_cm);

  /* lets case on the dest data type */
  switch(dest_data_type){
    case FLOAT:
      while(width--){
        *dest_r++ = *src_r++;
        *dest_g++ = *src_g++;
        *dest_b++ = *src_b++;
      }
    break;
    case U8:
      while(width--){
        *dest_r++ = *src_r++ / 255.0;
        *dest_g++ = *src_g++ / 255.0;
        *dest_b++ = *src_b++ / 255.0;
      }
    break;
    default:
    break;
  }
  }

  private
  void
  HSV_U8 (GeglPointOp *point_op)
  {
  /* Ok, we are converting from a HSV U8 image buffer
     to an RGB some data type image buffer
  */
  guint width;
  guchar *dest_data[4], *src_data[4];
  guchar *dest_r, *dest_g, *dest_b, *src_r, *src_g, *src_b;
  GeglFillOp *self = GEGL_FILL_OP (point_op);
  GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_pr iv);
  GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

  width = point_opP->scanline_width;

  gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                  (guchar**)dest_data);
  gegl_image_buffer_get_scanline_data (opP->image_buffers[1],
                  (guchar**)src_data);

  dest_r = dest_data[0];
  dest_g = dest_data[1];
  dest_b = dest_data[2];
  src_r = src_data[0];
  src_g = src_data[1];
  src_b = src_data[2];

  /* find out what is the final data type */
  dest_cm = gegl_image_buffer_color_model (opP->image_buffers[0]);
  dest_data_type = gegl_color_model_data_type (dest_cm);

  /* lets case on the dest data type */
  switch(dest_data_type){
    case FLOAT:
      /* we done have to do anything, just put src into dest */
      while(width--){
        *dest_r++ = *src_r++ * 255.0;
        *dest_g++ = *src_g++ * 255.0;
        *dest_b++ = *src_b++ * 255.0;
      }
    break;
    case U8:
      while(width--){
        *dest_r++ = *src_r++;
        *dest_g++ = *src_g++;
        *dest_b++ = *src_b++;
      }
    break;
    default:
    break;
  }
  }

  private
  void
  UNKNOWN (GeglPointOp *point_op)
  {
  /* Ok, we are converting from a UNKNOWN image buffer
     to an RGB some data type image buffer
  */
  guint width;
  guchar *dest_data[4], *src_data[4];
  gfloat *tmp_data; 
  GeglFillOp *self = GEGL_FILL_OP (point_op);
  GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_pr iv);
  GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

  width = point_opP->scanline_width;

  tmp_data = (gfloat*) g_malloc(sizeof(gfloat)*width*3);

  gegl_image_buffer_get_scanline_data (opP->image_buffers[0], 
                (guchar**)dest_data);

  gegl_image_buffer_get_scanline_data (opP->image_buffers[1], 
                (guchar**)src_data);

  dest_cm = gegl_image_buffer_color_model (opP->image_buffers[0]);
  src_cm = gegl_image_buffer_color_model (opP->image_buffers[1]);

  gegl_color_model_convert_to_xyz (src_cm, tmp_data, src_data);
  gegl_color_model_convert_from_xyz (dest_cm, dest_data, tmp_data);

  /* do the alpha */
  if(gegl_color_model_has_alpha(dest_cm) && gegl_color_model_has_alpha(src_cm)){
    if(gegl_color_model_data_type (dest_cm) == gegl_color_model_data_type (src_cm)){
      while(width--)
        *(dest_data[3])++ = *(src_data[3])++;
    }
    else if(gegl_color_model_data_type (dest_cm) == FLOAT &&
             gegl_color_model_data_type (src_cm)  == U8){
       while(width--)
        *(dest_data[3])++ = (float) *(src_data[3])++ / 255.0; 
    }
    else if(gegl_color_model_data_type (dest_cm) == U8 &&
             gegl_color_model_data_type (src_cm)  == FLOAT){
       while(width--)
        *(dest_data[3])++ = *(src_data[3])++ * 255;
    }
  } 
   
  
  }

}
