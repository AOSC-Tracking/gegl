%h{
#include "gegl-color-model.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor GeglColor;
#endif
%}
%{
#include "gegl-color-model-gray.h"
#include "gegl-color-model-gray-private.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
%}

class Gegl:Color:Model:Gray from Gegl:Color:Model {

  protected gint gray_index;

  protected 
  gboolean 
  constructor(self, 
              gboolean has_alpha)
  {
    GeglColorModel *self_color_model = GEGL_COLOR_MODEL (self);

    if (GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_constructor (self_color_model, has_alpha))
      return FALSE;

    if (self_color_model->has_alpha)
     {
       self_color_model->alpha_channel = 1;
       self_color_model->num_channels = 2;
     }
    else
     {
       self_color_model->alpha_channel = -1;
       self_color_model->num_channels = 1;
     }

    /* We can set these here */
    self_color_model->colorspace = GEGL_COLOR_SPACE_GRAY;
    self_color_model->is_additive = TRUE;
    self_color_model->color_space_name = NULL;
    
    /* Allocate memory for these then --will need a destroy then */
    self_color_model->channel_names = NULL;
    self_color_model->color_space_name = NULL;

    /* Right now just do the typical gray */ 

    self->gray_index = 0;

    return TRUE;
  }
  
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Dispose of the all the strings here */

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Color:Model)
  GeglColorAlphaSpace
  color_alpha_space(GeglColorModel *self_color_model)
  {
    if (self_color_model->has_alpha)
      return GEGL_COLOR_ALPHA_SPACE_GRAYA;
    else
      return GEGL_COLOR_ALPHA_SPACE_GRAY;
  }

  public
  gint 
  get_gray_index (self) 
  { 
    return self->gray_index; 
  }
}
