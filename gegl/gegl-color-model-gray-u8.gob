%h{
#include "gegl-color-model-gray.h"
%}
%{
#include "gegl-color-model-gray-u8.h"
#include "gegl-color-model-gray-u8-private.h"
#include "gegl-color-model-gray-private.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
%}

class Gegl:Color:Model:Gray:U8 from Gegl:Color:Model:Gray {

  public
  GeglColorModelGrayU8 *	
  new(gboolean has_alpha, gboolean is_premult)
  {
    GeglColorModelGrayU8 * self = GEGL_COLOR_MODEL_GRAY_U8(GET_NEW);
  
    /*Call the constructor */
    if (!constructor(self, has_alpha, is_premult))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }
  
  protected
  gboolean 
  constructor(self, gboolean has_alpha, gboolean is_premult)
  {
    GeglColorModelPrivate *color_modelP = (GeglColorModelPrivate*)
                                  (GEGL_COLOR_MODEL (self)->_priv);

    if (GEGL_OBJECT(self)->constructed) 
        return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_gray_constructor (
         GEGL_COLOR_MODEL_GRAY(self), has_alpha, is_premult))
        return FALSE;

    color_modelP->data_type = U8;
    color_modelP->channel_data_type_name = NULL;
    color_modelP->bytes_per_channel = sizeof(guint8);
    color_modelP->bytes_per_pixel = 
                  color_modelP->bytes_per_channel * 
                  color_modelP->num_channels;
    return TRUE;
  }
  
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Dispose of the data type string here */

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Color:Model) 
  void 
  set_color (GeglColorModel *cm, 
             GeglColor *color, 
             GeglColorConstant constant)
  {
    GeglChannelValue * channel_values = 
                       gegl_color_get_channel_values(color); 
    gboolean has_alpha = gegl_color_model_has_alpha (cm); 
    GeglColorModelGray * cm_gray = GEGL_COLOR_MODEL_GRAY(cm);
    
    gint g = gegl_color_model_gray_get_green_index (cm_gray);
    gint a = gegl_color_model_alpha_channel (GEGL_COLOR_MODEL(cm_gray));

    switch (constant) 
      { 
        case COLOR_WHITE:
          channel_values[g].u8 = 255;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_BLACK:
          channel_values[g].u8 = 0;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_RED:
          channel_values[g].u8 = 0.3 * 255;
          if (has_alpha)
            channel_values[a].f = 255;
          break;
        case COLOR_GREEN:
          channel_values[g].u8 = 0.6 * 255;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_BLUE:
          channel_values[g].u8 = 0.1 * 255;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_GRAY:
        case COLOR_HALF_WHITE:
          channel_values[g].u8 = 127;
          if (has_alpha)
            channel_values[a].u8 = 255;
          break;
        case COLOR_WHITE_TRANSPARENT:
          channel_values[r].u8 = 255;
          channel_values[g].u8 = 255;
          channel_values[b].u8 = 255;

          if (!has_alpha)
            channel_values[a].u8 = 0;
          break;
        case COLOR_TRANSPARENT:
        case COLOR_BLACK_TRANSPARENT:
          channel_values[r].u8 = 0;
          channel_values[g].u8 = 0;
          channel_values[b].u8 = 0;
          if (has_alpha)
            channel_values[a].u8 = 0;
          break;
      }
   }

  override (Gegl:Color:Model)
  void
  convert_to_xyz (GeglColorModel *cm, gfloat *dest_data, guchar **src_data, gint width)
  {
    /* the color datat in src_data is gray_float */
    /*
      __  __      __                                                          __  __  __
      | X  |      | 0.38106149108714790 0.32025712365352110 0.24834578525933100 | | R  |
      | Y  |   =  | 0.20729745115140850 0.68054638776373240 0.11215616108485920 | | G  |
      | Z  |      | 0.02133944350088028 0.14297193020246480 1.24172892629665500 | | B  |
      --  --      ---                                                        ---- --  --
    */
    gfloat m00 = 0.38106149108714790;
    gfloat m10 = 0.32025712365352110;
    gfloat m20 = 0.24834578525933100;
    gfloat m01 = 0.20729745115140850;
    gfloat m11 = 0.68054638776373240;
    gfloat m21 = 0.11215616108485920;
    gfloat m02 = 0.02133944350088028;
    gfloat m12 = 0.14297193020246480;
    gfloat m22 = 1.24172892629665500;

    guint8 *g, *a;
    gfloat G, A;
    gint i=0;
    gfloat tmp= 1.0/255.0;

    gboolean has_alpha = gegl_color_model_has_alpha(cm);

    g = src_data[0];
    
    if(has_alpha){

    a = src_data[1];

    while(width--)
    {
      G = *g++ * tmp;
      A = *a++ * tmp;
      dest_data[i++] = (m00 + m10 + m20) * G;
      dest_data[i++] = (m01 + m11 + m21) * G;
      dest_data[i++] = (m02 + m12 + m22) * G;
      dest_data[i++] = A;
    }
    } else {
    while(width--)
    {
      G = *g++ * tmp;
      dest_data[i++] = (m00 + m10 + m20) * G;
      dest_data[i++] = (m01 + m11 + m21) * G;
      dest_data[i++] = (m02 + m12 + m22) * G;
    }
    }
  }

  override (Gegl:Color:Model)
  void
  convert_from_xyz (GeglColorModel *cm, guchar **dest_data, gfloat *src_data, gint width)
  {
    /* the color datat in src_data is xyz_float */
    /*
      __  __      __                                __  __  __
      | R  |      | 3.240479   -1.537150   -0.498535 | | X  |
      | G  |   =  |-0.969256    1.875992    0.041556 | | Y  |
      | B  |      | 0.055648   -0.204043    1.057311 | | Z  |
      --  --      ---                              ---- --  --
    */
    gfloat m00 =  3.48340481253539000;
    gfloat m10 = -1.07152751306193600;
    gfloat m20 =  0.06351179790497788;
    gfloat m01 = -1.52176374927285200;
    gfloat m11 =  1.96593795204372400;
    gfloat m21 = -0.20020501000496480;
    gfloat m02 = -0.55923133354049780;
    gfloat m12 =  0.03673691339553462;
    gfloat m22 =  0.81070942031648220;

    guint8 *g, *a;
    gint i=0;

    gboolean has_alpha = gegl_color_model_has_alpha(cm);

    r = dest_data[0];
    g = dest_data[1];
    b = dest_data[2];
    if(has_alpha){
    a = dest_data[3];

    while(width--)
    {
      *g    = (m00 * src_data[i*4] + m10 * src_data[i*4+1] + m20 * src_data[i*4+2]) * 255 * 0.3;
      *g   += (m01 * src_data[i*4] + m11 * src_data[i*4+1] + m21 * src_data[i*4+2]) * 255 * 0.6;
      *g++ += (m02 * src_data[i*4] + m12 * src_data[i*4+1] + m22 * src_data[i*4+2]) * 255 * 0.1;
      *a++  = (src_data[i*4+3]) * 255;
      i++;
    }
    } else {
    while(width--)
    {
      *g   += (m00 * src_data[i*3] + m10 * src_data[i*3+1] + m20 * src_data[i*3+2]) * 255 * 0.3;
      *g   += (m01 * src_data[i*3] + m11 * src_data[i*3+1] + m21 * src_data[i*3+2]) * 255 * 0.6;
      *g++ += (m02 * src_data[i*3] + m12 * src_data[i*3+1] + m22 * src_data[i*3+2]) * 255 * 0.1;
      i++;
    }
    }
  }

}

