%h{
#include "gegl-single-src-op.h"
%}
%{
#include "gegl-premult-op.h"
#include "gegl-premult-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Premult:Op from Gegl:Single:Src:Op {

  
  public 
  GeglPremultOp *
  new (GeglImage *src)
  {
    GeglPremultOp * self = GEGL_PREMULT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src)) 
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImage *src)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override(Gegl:Image)
  void
  prepare(GeglImage *self_image,
          GList * requests)
  {
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_image)->klass);
    GeglImageRequest *dest_request = 
      (GeglImageRequest*)g_list_nth_data(requests,0); 
    GeglTile *dest = dest_request->tile;
    GeglColorModel * dest_cm = gegl_tile_get_color_model (dest);
    g_return_if_fail(dest_cm);

    {
      gboolean dest_has_alpha = gegl_color_model_has_alpha(dest_cm);
      if(dest_has_alpha)
        self_point_op_class->scanline_func = 
	        gegl_premult_op_scanline_COLORSPACE_DATATYPE;
      else
        {
          self_point_op_class->scanline_func = NULL;
          g_warning("gegl_premult_op_prepare: dest has no alpha channel\n");
        } 
    }
  } 

  private
  void
  scanline_COLORSPACE_DATATYPE (GeglPointOp *self_point_op,
                                GeglTileIterator **iters,
                                gint width)
  {
    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha);
    Pixel src(color,alpha);
    GENERIC_IMAGE_DECL_END

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT 

    while (width--)
      {
        GENERIC_IMAGE_CODE_BEGIN

        if (src_alpha == ZERO)
          {
            dest_color = ZERO;
          }
        else if (src_alpha == WP)
          {
            dest_color = src_color;
          }
        else
          {
            dest_color = src_alpha * src_color;
          }

        dest_alpha = src_alpha;

        dX(dest,1);
        dX(src,1);  

        GENERIC_IMAGE_CODE_END
      }
  }
}
