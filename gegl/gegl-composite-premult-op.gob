%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-composite-premult-op.h"
#include "gegl-composite-premult-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h> 
%}

class Gegl:Composite:Premult:Op from Gegl:Dual:Src:Op {

  private GeglCompositeMode        comp_mode;

  public 
  GeglCompositePremultOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src1,
       GeglImageBuffer *src2,       
       GeglRect *dest_rect,
       GeglRect *src1_rect,
       GeglRect *src2_rect,
       GeglCompositeMode mode)
  {
    GeglCompositePremultOp * self = GEGL_COMPOSITE_PREMULT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src1, src2, 
                     dest_rect, src1_rect, src2_rect, mode))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
             GeglImageBuffer *dest, 
             GeglImageBuffer *src1,
             GeglImageBuffer *src2,       
             GeglRect *dest_rect,
             GeglRect *src1_rect,
             GeglRect *src2_rect,
             GeglCompositeMode mode)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;

    /* Chain up */
    if (!gegl_dual_src_op_constructor ( 
           GEGL_DUAL_SRC_OP(self),dest, src1, src2, 
           dest_rect, src1_rect, src2_rect))
      return FALSE;

    {
      GeglPointOpClass *point_op_class = 
         GEGL_POINT_OP_CLASS(GTK_OBJECT(self)->klass);

      GeglColorModel              *src1_cm, *src2_cm;
      gboolean                    src1_has_alpha, src2_has_alpha;
       
      src1_cm = gegl_image_buffer_color_model (src1);
      src1_has_alpha = gegl_color_model_has_alpha (src1_cm);

      src2_cm = gegl_image_buffer_color_model (src2);
      src2_has_alpha = gegl_color_model_has_alpha (src2_cm);

      if ( src2_has_alpha && src1_has_alpha)
       point_op_class->scanline_func = gegl_composite_premult_op_RGBA_op_RGBA_FLOAT;
      else if ( src2_has_alpha && !src1_has_alpha )
       point_op_class->scanline_func = gegl_composite_premult_op_RGBA_op_RGB_FLOAT;
      else if ( !src2_has_alpha && src1_has_alpha )
       point_op_class->scanline_func = gegl_composite_premult_op_RGB_op_RGBA_FLOAT;
      else if ( !src2_has_alpha && !src1_has_alpha )
       point_op_class->scanline_func = gegl_composite_premult_op_RGB_op_RGB_FLOAT;

      self->_priv->comp_mode = mode;
    }
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  RGBA_op_RGBA_FLOAT (GeglPointOp *point_op)
  {
    GeglCompositePremultOp * self = GEGL_COMPOSITE_PREMULT_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    gfloat *dest_data[4], *src1_data[4], *src2_data[4]; 
    gfloat *dest_r, *dest_g, *dest_b, *dest_a=NULL;
    gfloat *src1_r, *src1_g, *src1_b, *src1_a=NULL;
    gfloat *src2_r, *src2_g, *src2_b, *src2_a=NULL;
    gfloat a,b;
    guint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];
    dest_a = dest_data[3];

    src1_r = src1_data[0];
    src1_g = src1_data[1];
    src1_b = src1_data[2];
    src1_a = src1_data[3];

    src2_r = src2_data[0];
    src2_g = src2_data[1];
    src2_b = src2_data[2];
    src2_a = src2_data[3];

    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
       while (width--)
         {
           *dest_r++ = *src2_r++;
           *dest_g++ = *src2_g++;
           *dest_b++ = *src2_b++;
           *dest_a++ = *src2_a++;
         }
       break;
      case COMPOSITE_OVER:
       while (width--)
         {
           a = 1.0 - *src2_a;
           *dest_r++ = a * *src1_r++ + *src2_r++;
           *dest_g++ = a * *src1_g++ + *src2_g++;
           *dest_b++ = a * *src1_b++ + *src2_b++;
           *dest_a++ = a * *src1_a++ + *src2_a++;
         } 
       break;
      case COMPOSITE_IN:
       while (width--)
         {
           b = *src1_a++;
           *dest_r++ = b * *src2_r++;
           *dest_g++ = b * *src2_g++;
           *dest_b++ = b * *src2_b++;
           *dest_a++ = b * *src2_a++;  
         }
       break;
      case COMPOSITE_OUT:
       while (width--)
         {
           b = 1.0 - *src1_a++;
           *dest_r++ = b * *src2_r++;
           *dest_g++ = b * *src2_g++;
           *dest_b++ = b * *src2_b++;
           *dest_a++ = b * *src2_a++;  
         }
       break;
      case COMPOSITE_ATOP:
       while (width--)
         {
           a = 1.0 - *src2_a++; 
           b = *src1_a++; 
           *dest_r++ = a * *src1_r++ + b * *src2_r++;
           *dest_g++ = a * *src1_g++ + b * *src2_g++;
           *dest_b++ = a * *src1_b++ + b * *src2_b++;
           *dest_a++ = b;
         }
       break;
      case COMPOSITE_XOR:
       while (width--)
         {
           a = 1.0 - *src2_a;
           b = 1.0 - *src1_a; 
           *dest_r++ = a * *src1_r++ + b * *src2_r++;
           *dest_g++ = a * *src1_g++ + b * *src2_g++;
           *dest_b++ = a * *src1_b++ + b * *src2_b++;
           *dest_a++ = a * *src1_a++ + b * *src2_a++;
         }
       break;
      default:
       break;
      }       
  }
 
  private
  void
  RGBA_op_RGB_FLOAT (GeglPointOp *point_op)
  {
    GeglCompositePremultOp * self = GEGL_COMPOSITE_PREMULT_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    gfloat *dest_data[3], *src1_data[3], *src2_data[4]; 
    gfloat *dest_r, *dest_g, *dest_b; 
    gfloat *src1_r, *src1_g, *src1_b;
    gfloat *src2_r, *src2_g, *src2_b, *src2_a=NULL;
    gfloat a;
    guint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
 
    src1_r = (gfloat*) src1_data[0];
    src1_g = (gfloat*) src1_data[1];
    src1_b = (gfloat*) src1_data[2];

    src2_r = (gfloat*) src2_data[0];
    src2_g = (gfloat*) src2_data[1];
    src2_b = (gfloat*) src2_data[2];
    src2_a = (gfloat*) src2_data[3];

    switch(self->_priv->comp_mode)
      {
       case COMPOSITE_REPLACE:
         while (width--)
           {
             *dest_r++ = *src2_r++;
             *dest_g++ = *src2_g++;
             *dest_b++ = *src2_b++;
           }
         break;
       case COMPOSITE_OVER:
         while (width--)
           {
             a = 1.0 - *src2_a++;
             *dest_r++ = a * *src1_r++ + *src2_r++;
             *dest_g++ = a * *src1_g++ + *src2_g++;
             *dest_b++ = a * *src1_b++ + *src2_b++;
           } 
         break;
       case COMPOSITE_IN:
         while (width--)
           {
             *dest_r++ = *src2_r++;
             *dest_g++ = *src2_g++;
             *dest_b++ = *src2_b++;
           }
         break;
       case COMPOSITE_OUT:
         while (width--)
           {
             *dest_r++ = 0.0; 
             *dest_g++ = 0.0;
             *dest_b++ = 0.0;
           }
         break;
       case COMPOSITE_ATOP:
         while (width--)
           {
             a = 1.0 - *src2_a++; 
             *dest_r++ = a * *src1_r++ + *src2_r++;
             *dest_g++ = a * *src1_g++ + *src2_g++;
             *dest_b++ = a * *src1_b++ + *src2_b++;
           }
         break;
       case COMPOSITE_XOR:
         while (width--)
           {
             a = 1.0 - *src2_a++; 
             *dest_r++ = a * *src1_r++;
             *dest_g++ = a * *src1_g++;
             *dest_b++ = a * *src1_b++;
           }
         break;
       default:
         break;
      }  
  }

  private
  void
  RGB_op_RGBA_FLOAT (GeglPointOp *point_op)
  {
    GeglCompositePremultOp * self = GEGL_COMPOSITE_PREMULT_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    gfloat *dest_data[4], *src1_data[4], *src2_data[3]; 
    gfloat *dest_r, *dest_g, *dest_b, *dest_a=NULL;
    gfloat *src1_r, *src1_g, *src1_b, *src1_a=NULL;
    gfloat *src2_r, *src2_g, *src2_b;
    gfloat b;
    guint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
    dest_a = (gfloat*) dest_data[3];
 
    src1_r = (gfloat*) src1_data[0];
    src1_g = (gfloat*) src1_data[1];
    src1_b = (gfloat*) src1_data[2];
    src1_a = (gfloat*) src1_data[3];

    src2_r = (gfloat*) src2_data[0];
    src2_g = (gfloat*) src2_data[1];
    src2_b = (gfloat*) src2_data[2];

    switch(self->_priv->comp_mode)
      {
       case COMPOSITE_REPLACE:
         while (width--)
           {
             *dest_r++ = *src2_r++;
             *dest_g++ = *src2_g++;
             *dest_b++ = *src2_b++;
             *dest_a++ = 1.0;
           }
         break;
       case COMPOSITE_OVER:
         while (width--)
           {
             *dest_r++ = *src2_r++;
             *dest_g++ = *src2_g++;
             *dest_b++ = *src2_b++;
             *dest_a++ = 1.0;
           } 
         break;
       case COMPOSITE_IN:
         while (width--)
           {
             b = *src1_a++;
             *dest_r++ = b * *src2_r++;
             *dest_g++ = b * *src2_g++;
             *dest_b++ = b * *src2_b++;
             *dest_a++ = b;  
           }
         break;
       case COMPOSITE_OUT:
         while (width--)
           {
             b = 1.0 - *src1_a++;
             *dest_r++ = b * *src2_r++;
             *dest_g++ = b * *src2_g++;
             *dest_b++ = b * *src2_b++;
             *dest_a++ = b;  
           }
         break;
       case COMPOSITE_ATOP:
         while (width--)
           {
             b = *src1_a++; 
             *dest_r++ =  b * *src2_r++;
             *dest_g++ =  b * *src2_g++;
             *dest_b++ =  b * *src2_b++;
             *dest_a++ =  b;
           }
         break;
       case COMPOSITE_XOR:
         while (width--)
           {
             b = 1.0 - *src1_a++;
             *dest_r++ = b * *src2_r++;
             *dest_g++ = b * *src2_g++;
             *dest_b++ = b * *src2_b++;
             *dest_a++ = b;
           }
         break;
       default:
         break;
      }  
  }

  private 
  void
  RGB_op_RGB_FLOAT (GeglPointOp *point_op)
  {
    GeglCompositePremultOp * self = GEGL_COMPOSITE_PREMULT_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)
                                    (point_op->_priv); 

    gfloat *dest_data[3], *src1_data[3], *src2_data[3]; 
    gfloat *dest_r, *dest_g, *dest_b;
    gfloat *src1_r, *src1_g, *src1_b;
    gfloat *src2_r, *src2_g, *src2_b;
    guint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data); 
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    dest_r = (gfloat*) dest_data[0];
    dest_g = (gfloat*) dest_data[1];
    dest_b = (gfloat*) dest_data[2];
 
    src1_r = (gfloat*) src2_data[0];
    src1_g = (gfloat*) src2_data[1];
    src1_b = (gfloat*) src2_data[2];

    src2_r = (gfloat*) src2_data[0];
    src2_g = (gfloat*) src2_data[1];
    src2_b = (gfloat*) src2_data[2];

    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
      case COMPOSITE_OVER:
      case COMPOSITE_IN:
      case COMPOSITE_ATOP:
        while (width--)
         {
           *dest_r++ = *src2_r++;
           *dest_g++ = *src2_g++;
           *dest_b++ = *src2_b++;
         }
        break;
      case COMPOSITE_OUT:
      case COMPOSITE_XOR:
        while (width--)
         {
           *dest_r++ = 0.0; 
           *dest_g++ = 0.0;
           *dest_b++ = 0.0;
         }
        break;
      default:
        break;
      }
  }
}
