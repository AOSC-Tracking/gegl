%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-composite-op.h"
#include "gegl-composite-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-image-private.h"
#include "gegl-op-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h> 
%}

class Gegl:Composite:Op from Gegl:Dual:Src:Op {

  private GeglCompositeMode        comp_mode;


  /**
   * new:
   * @src1: first input.
   * @src2: second input.
   * @mode: replace, over, in, out, atop, or xor.
   *
   * Creates a new #GeglCompositeOp.
   * 
   * Returns: a new #GeglCompositeOp.
   **/ 
  public 
  GeglCompositeOp *
  new (GeglOp *src1,
       GeglOp *src2,       
       GeglCompositeMode mode)
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src1, src2, mode))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglCompositeOp.
   * @src1: first input.
   * @src2: second input.
   * @mode: replace, over, in, out, atop, or xor.
   *
   * Initializes a #GeglCompositeOp.
   * 
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self, 
              GeglOp *src1,
              GeglOp *src2,       
              GeglCompositeMode mode)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;

    /* Chain up */
    if (!gegl_dual_src_op_constructor ( 
           GEGL_DUAL_SRC_OP(self), src1, src2))
      return FALSE;

    self->_priv->comp_mode = mode;
    return TRUE;
  }


  /**
   * prepare: 
   * @self_image: a #GeglOp.
   * @requests: #GeglOpRequest list.
   *
   * Prepare for image processing. Set up scanline function pointers based on
   * color models of inputs. 
   *
   **/
  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GList * requests)
  {
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_op)->klass);

    GeglOpRequest *dest_request = 
      (GeglOpRequest*)g_list_nth_data(requests,0); 
    GeglTile *dest = dest_request->tile;
    GeglColorModel * dest_cm = gegl_tile_get_color_model (dest);

    GeglOpRequest *s1_request = 
      (GeglOpRequest*)g_list_nth_data(requests,1); 
    GeglTile *s1 = s1_request->tile;
    GeglColorModel * s1_cm = gegl_tile_get_color_model (s1);

    GeglOpRequest *s2_request = 
      (GeglOpRequest*)g_list_nth_data(requests,2); 
    GeglTile *s2 = s2_request->tile;
    GeglColorModel * s2_cm = gegl_tile_get_color_model (s2);

    g_return_if_fail (dest_cm);
    g_return_if_fail (s1_cm);
    g_return_if_fail (s2_cm);

      {
        gboolean  s1_has_alpha = gegl_color_model_has_alpha(s1_cm);
        gboolean  s2_has_alpha = gegl_color_model_has_alpha(s2_cm); 

        /* dest = src2 op src1 */ 

        if ( s2_has_alpha && s1_has_alpha)
          self_point_op_class->scanline_func = scanline_ca_op_ca;
        else if ( s2_has_alpha && !s1_has_alpha )
          self_point_op_class->scanline_func = scanline_ca_op_c;
        else if ( !s2_has_alpha && s1_has_alpha )
          self_point_op_class->scanline_func = scanline_c_op_ca;
        else if ( !s2_has_alpha && !s1_has_alpha )
          self_point_op_class->scanline_func = scanline_c_op_c;
     }
  } 


  /**
   * scanline_ca_op_ca:
   * @self_point_op: #a GeglPointOp. 
   * @iters: array of TileIterators. 
   * @width: width of scanline. 
   *
   * Process an color_alpha op color_alpha scanline. 
   *
   **/
  private 
  void
  scanline_ca_op_ca(GeglPointOp *self_point_op,
                    GeglTileIterator **iters,
                    gint width)
  {
    GeglCompositeOp *self = GEGL_COMPOSITE_OP(self_point_op);
    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha);
    Pixel src1(color,alpha);
    Pixel src2(color,alpha);
    Channel a, b, alpha;
    GENERIC_IMAGE_DECL_END

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src1_data);
    gegl_tile_iterator_get_current (iters[2], (gpointer*)src2_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case GEGL_COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            alpha = src2_alpha;
            dest_alpha = src2_alpha;

	    if (alpha)
	      {
		dest_color = src2_color;
	      }
	    else
	      {
		dest_color = src1_color;
	      }

            dX(dest,1);
	    dX(src1,1);
            dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      case GEGL_COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            a = (WP - src2_alpha) * src1_alpha;
            b = src2_alpha;
            alpha = a + b;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = (a * src1_color + b * src2_color)/alpha;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      case GEGL_COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            alpha = src1_alpha * src2_alpha;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      case GEGL_COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            alpha = (WP - src1_alpha) * src2_alpha;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      case GEGL_COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            a = WP - src2_alpha;
            b = src2_alpha;
            alpha = src1_alpha;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = a * src1_color + b * src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      case GEGL_COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN

            a = (WP - src2_alpha) * src1_alpha;
            b = (WP - src1_alpha) * src2_alpha;
            alpha = a + b;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = (a * src1_color + b * src2_color) / alpha;
              }
            else 
              {
               dest_color = src1_color; 
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END
          }
        break;
      default:
        break;
      }
  }

 
  /**
   * scanline_ca_op_c:
   * @self_point_op: #a GeglPointOp.
   * @iters: array of TileIterators. 
   * @width: width of scanline. 
   *
   * Process color_alpha op color scanline. 
   *
   **/
  private 
  void
  scanline_ca_op_c(GeglPointOp *self_point_op,
                   GeglTileIterator **iters,
                   gint width)
  {
    GeglCompositeOp *self = GEGL_COMPOSITE_OP(self_point_op);
    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color); 
    Pixel src1(color);
    Pixel src2(color,alpha);
    Channel a, b;
    GENERIC_IMAGE_DECL_END

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src1_data);
    gegl_tile_iterator_get_current (iters[2], (gpointer*)src2_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case GEGL_COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

	    dest_color = src2_color * src2_alpha;

            dX(dest,1);
	    dX(src1,1);
            dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
	  }
        break;
      case GEGL_COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            a = (WP - src2_alpha);
            b = src2_alpha;

            dest_color = (a * src1_color + b * src2_color);

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

	    dest_color = src2_color * src2_alpha;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            dest_color = ZERO;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1);

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            a = WP - src2_alpha;
            b = src2_alpha;

            dest_color = (a * src1_color + b * src2_color);

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
       break;
      case GEGL_COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            a = (WP - src2_alpha);

            dest_color = a * src1_color;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      default:
        break;
      }
  }


  /**
   * scanline_c_op_ca:
   * @self_point_op: #a GeglPointOp.
   * @iters: array of TileIterators. 
   * @width: width of scanline. 
   *
   * Process color op color_alpha scanline. 
   *
   **/
  private 
  void
  scanline_c_op_ca(GeglPointOp *self_point_op,
                   GeglTileIterator **iters,
                   gint width)
  {
    GeglCompositeOp *self = GEGL_COMPOSITE_OP(self_point_op);
    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha);
    Pixel src1(color,alpha);
    Pixel src2(color);
    Channel alpha;
    GENERIC_IMAGE_DECL_END 

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src1_data);
    gegl_tile_iterator_get_current (iters[2], (gpointer*)src2_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case GEGL_COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            dest_color = src2_color;
            dest_alpha = WP;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            dest_color = src2_color;
            dest_alpha = WP;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            alpha = src1_alpha;
            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
       break;
      case GEGL_COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            alpha = WP - src1_alpha;
            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

       	    dX(dest,1);
            dX(src1,1);
            dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      case GEGL_COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            alpha = src1_alpha;
            dest_alpha = alpha;

	    if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1);

            GENERIC_IMAGE_CODE_END 
          }
       break;
      case GEGL_COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            alpha = WP - src1_alpha;
            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
          }
        break;
      default:
        break;
      }
  }


  /**
   * scanline_c_op_c:
   * @self_point_op: #a GeglPointOp.
   * @iters: array of TileIterators. 
   * @width: width of scanline. 
   *
   * Process color op color scanline. 
   *
   **/
  private 
  void
  scanline_c_op_c (GeglPointOp *self_point_op,
                   GeglTileIterator **iters,
                   gint width)
  {
    GeglCompositeOp *self = GEGL_COMPOSITE_OP(self_point_op);
    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color);
    Pixel src1(color);
    Pixel src2(color);
    GENERIC_IMAGE_DECL_END

    gegl_tile_iterator_get_current (iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current (iters[1], (gpointer*)src1_data);
    gegl_tile_iterator_get_current (iters[2], (gpointer*)src2_data);

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case GEGL_COMPOSITE_REPLACE:
      case GEGL_COMPOSITE_OVER:
      case GEGL_COMPOSITE_IN:
      case GEGL_COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

	    dest_color = src2_color;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_CODE_END 
       	  }
        break;
      case GEGL_COMPOSITE_OUT:
      case GEGL_COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_CODE_BEGIN 

            dest_color = ZERO;

	    dX(dest,1);
	    dX(src1,1); 
	    dX(src2,1);

            GENERIC_IMAGE_CODE_END 
          }
        break;
      default:
        break;
      }
  }
}
