%h{
#include "gegl-color-convert-op.h"
#include "gegl-image-buffer.h"
%}
%{
#include "gegl-color-convert-to-gray-float-op.h"
#include "gegl-color-convert-to-gray-float-op-private.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Color:Convert:To:Gray:Float:Op from Gegl:Color:Convert:Op {

  private gboolean do_color_space;        /* is this a color space conversion? */
  private gboolean do_data;               /* is this a data type conversion? */

  private GeglColorModel *src_float_cm;   /* color model with src color space, but float data*/ 
  private gfloat **src_float_data;        /* float data pointers in case we use the above*/ 
  private gint src_num_channels;          /* num of channels in src */ 

  private gint last_width;                /* last scanline width */ 

  public 
  GeglColorConvertToGrayFloatOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src,
       GeglRect *dest_rect,
       GeglRect *src_rect)
  {
    GeglColorConvertToGrayFloatOp * self = 
       GEGL_COLOR_CONVERT_TO_GRAY_FLOAT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src, dest_rect, src_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
	GeglImageBuffer *dest,
	GeglImageBuffer *src, 
	GeglRect *dest_rect,
	GeglRect *src_rect) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
   
    /* Chain up */
    if (!gegl_color_convert_op_constructor ( 
		     GEGL_COLOR_CONVERT_OP (self), 
		     dest,src,dest_rect,src_rect))
      return FALSE;

    {
      GeglPointOp *point_op = GEGL_POINT_OP (self);
      GeglPointOpClass *point_op_class = 
	  GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
      GeglColorConvertOpPrivate *color_convert_opP = 
       (GeglColorConvertOpPrivate*)(GEGL_COLOR_CONVERT_OP (self)->_priv);

      GeglColorSpace src_color_space = gegl_color_model_color_space (
                                         color_convert_opP->src_cm); 
      GeglChannelDataType src_data_type = gegl_color_model_data_type ( 
                                            color_convert_opP->src_cm); 
      gint src_num_channels = gegl_color_model_num_channels (
                                color_convert_opP->src_cm); 
      gboolean src_has_alpha = gegl_color_model_has_alpha (
                                color_convert_opP->src_cm); 

      /* 
         Figure out whether we have to color space 
         and/or data conversions
      */
      self->_priv->do_color_space = 
                 (src_color_space == GRAY) ? FALSE: TRUE;

      self->_priv->do_data = 
                 (src_data_type == FLOAT) ? FALSE: TRUE;

      self->_priv->src_num_channels = src_num_channels;
      self->_priv->last_width = 0;

      self->_priv->src_float_data = NULL;
      self->_priv->src_float_cm = NULL; 

      /* 
	If we have to convert src to float first will need float buffers
	with num channels of the source.
      */

      if (self->_priv->do_color_space && 
	  self->_priv->do_data)
        { 
          gint i;

          /* allocate the float pointers */
	  self->_priv->src_float_data = g_new(gfloat*, src_num_channels);

          /* allocate the actual float data later*/
	  for (i = 0; i < src_num_channels; i++)
	    self->_priv->src_float_data[i] = NULL;

          
          /* This allocates a float color model with same color space as src*/
	  self->_priv->src_float_cm = gegl_make_color_model (
                                            src_color_space, 
                                            FLOAT,
                                            src_has_alpha);
        }
      
      point_op_class->scanline_func = 
           gegl_color_convert_to_gray_float_op_scanline;
    }
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglColorConvertToGrayFloatOp *self = 
      GEGL_COLOR_CONVERT_TO_GRAY_FLOAT_OP (object); 

    if (self->_priv->src_float_data)	
      {
        free_float_data(self);
        g_free (self->_priv->src_float_data);  
      }

    /* Free the float cm */
    if (self->_priv->src_float_cm)
      gegl_object_destroy (GEGL_OBJECT (self->_priv->src_float_cm));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  alloc_float_data(self, gint width)
  {
    gint i;
    for (i = 0; i < self->_priv->src_num_channels; i++)
      self->_priv->src_float_data[i] = g_new(gfloat, width);
  } 

  private
  void
  free_float_data(self)
  {
    gint i;
    for (i = 0; i < self->_priv->src_num_channels; i++)
      if (!self->_priv->src_float_data[i])
        g_free (self->_priv->src_float_data[i]);
  } 

  private
  void 
  scanline(GeglPointOp *point_op)
  {
    GeglColorConvertToGrayFloatOp *self = 
      GEGL_COLOR_CONVERT_TO_GRAY_FLOAT_OP (point_op);
    GeglColorConvertOpPrivate *color_convert_opP = 
      (GeglColorConvertOpPrivate*)(GEGL_COLOR_CONVERT_OP (point_op)->_priv);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv);
    GeglOpPrivate *opP = (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

    gint width = point_opP->scanline_width;

    gboolean color_space_only = self->_priv->do_color_space && !self->_priv->do_data;
    gboolean data_only = self->_priv->do_data && !self->_priv->do_color_space;
 
    /* Make the dest and src point to the data to convert */
    gegl_image_buffer_get_scanline_data (opP->image_buffers[0], 
                                         color_convert_opP->dest_data);

    gegl_image_buffer_get_scanline_data (opP->image_buffers[1], 
                                         color_convert_opP->src_data);

    if (color_space_only) 
      {
       gegl_color_model_convert_to_gray (color_convert_opP->src_cm,
                                color_convert_opP->dest_data, 
                                color_convert_opP->src_data, 
                                width);
      }
    else if (data_only)
      {
       gegl_color_model_convert_to_float (color_convert_opP->src_cm,
                                  (gfloat**)color_convert_opP->dest_data, 
                                  color_convert_opP->src_data, 
                                  width);
      }
    else
      {
        if (self->_priv->last_width != width) 
          {
	    free_float_data (self);
	    alloc_float_data (self, width);
	  }

        /* convert to a float src and then to float gray */
        gegl_color_model_convert_to_float (color_convert_opP->src_cm, 
                                   (gfloat**)self->_priv->src_float_data, 
                                   color_convert_opP->src_data,
                                   width);

        gegl_color_model_convert_to_gray (self->_priv->src_float_cm, 
				  color_convert_opP->dest_data, 
				  (guchar**)self->_priv->src_float_data,
				  width);
      }

    self->_priv->last_width = width;
  } 
}
