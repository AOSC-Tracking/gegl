%h{
#include "gegl-single-src-op.h"
%}
%{
#include "gegl-premult-op.h"
#include "gegl-premult-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Premult:Op from Gegl:Single:Src:Op {

  
  public 
  GeglPremultOp *
  new (GeglImageBuffer *dest,
       GeglImageBuffer *src,
       GeglRect *dest_rect,
       GeglRect *src_rect)
  {
    GeglPremultOp * self = GEGL_PREMULT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src, dest_rect, src_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest,
              GeglImageBuffer *src,
              GeglRect *dest_rect,
             GeglRect *src_rect) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), dest, src, dest_rect, src_rect))
      return FALSE;
   {
     GeglPointOpClass *point_op_class = 
       GEGL_POINT_OP_CLASS(GTK_OBJECT(self)->klass);
     GeglColorModel *cm = gegl_image_buffer_color_model (dest);
     gboolean has_alpha = gegl_color_model_has_alpha(cm);
      
     if(has_alpha)
       point_op_class->scanline_func = gegl_premult_op_RGBA_FLOAT;
     else
       {
         g_warning("GeglPremultOp: dest has no alpha channel\n");
         return FALSE;
       } 
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  RGBA_FLOAT (GeglPointOp *point_op)
  {
     /*
     Whats the algorithm for this code?       
     {
       Chan dest;
       Chan src;

         if (src_a == 0.0)
          {
            dest = CHAN_ZERO;
           }
         else if (src_a == WP);
          {
             dest = src;
           }
         else
          {
             dest = src_a * src;
           }
        dest_a = src_a;
      }
      */

    GeglPointOpPrivate *point_opP = 
        (GeglPointOpPrivate *)(point_op->_priv); 

    guint width = point_opP->scanline_width;
    gfloat * dest_data[4]; 
    gfloat * src_data[4]; 
    gfloat *dest_r, *dest_g, *dest_b, *dest_a;
    gfloat *src_r, *src_g, *src_b, *src_a;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src_data);

    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];
    dest_a = dest_data[3];

    src_r = src_data[0];
    src_g = src_data[1];
    src_b = src_data[2];
    src_a = src_data[3];

    while (width--)
      {
         if (*src_a == 0.0)
          {
            *dest_r++ = 0.0;
            *dest_g++ = 0.0;
            *dest_b++ = 0.0;
           }
         else if (*src_a == 1.0)
          {
            *dest_r++ = *src_r++;
            *dest_g++ = *src_g++;
            *dest_b++ = *src_b++;
           }
         else
          {
            *dest_r++ = *src_a * *src_r++;
            *dest_g++ = *src_a * *src_g++;
            *dest_b++ = *src_a * *src_b++;
           }

        *dest_a++ = *src_a++; 
      }
  }
}
