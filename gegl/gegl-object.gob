%h{
#include <stdio.h>
#include <gtk/gtk.h>
#include "gegl-types.h"
#include "gegl-utils.h"

#define gegl_object_ref(o) gegl_object_ref_debug(o,__FILE__,__LINE__)
#define gegl_object_unref(o) gegl_object_unref_debug(o,__FILE__,__LINE__)

/*Short forms for logging output */ 

#define LOG_DEBUG(args...)  gegl_object_log(GEGL_OBJECT(self), \
                                            G_LOG_LEVEL_DEBUG, \
                                            __FILE__, \
                                            __LINE__, \
                                            __GOB_FUNCTION__, \
                                            ##args)

#define LOG_INFO(args...)  gegl_object_log(GEGL_OBJECT(self), \
                                           G_LOG_LEVEL_INFO, \
                                           __FILE__, \
                                           __LINE__, \
                                           __GOB_FUNCTION__, \
                                           ##args)

#define LOG_MSG(args...)  gegl_object_log(GEGL_OBJECT(self), \
                                          G_LOG_LEVEL_MESSAGE, \
                                          __FILE__, \
                                          __LINE__, \
                                          __GOB_FUNCTION__, \
                                          ##args)

%}

%{
#include "gegl-object.h"
#include "gegl-object-private.h"
%}


class Gegl:Object from Gtk:Object {

  protected gboolean constructed;
  private gboolean trace_refs = FALSE;
  private gboolean logging = TRUE;

  /**
   * init:
   * @object:
   *
   * Init the Object class.
   **/ 
  init(object)
  {
    object->constructed = FALSE;
  }


  /**
   * constructor:
   * @self: a #GeglObject.
   *
   * Initialize the #GeglObject.
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected
  gboolean       
  constructor(self)
  {
    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Free memory allocated by this object.
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * set_trace_refs:
   * @self: a #GeglObject.
   * @trace: TRUE for tracing refs on.
   * 
   * Set trace_refs on this object.
   **/ 
  public 
  void 
  set_trace_refs (self,
                  gboolean trace)
  {
    self->_priv->trace_refs = trace;
  }


  /**
   * get_trace_refs:
   * @self: a #GeglObject.
   *
   * Gets trace_ref.
   *
   * Returns: a gboolean. 
   **/
  public 
  gboolean 
  get_trace_refs (self)
  {
    return self->_priv->trace_refs;
  }


  /**
   * ref_debug:
   * @self: a #GeglObject.
   * @func:
   * @line:
   * 
   **/ 
  public 
  void 
  ref_debug (self,
             const gchar *func,
             guint line)
  {
    if (self->_priv->trace_refs)
      trace_referencing(self, func, line, TRUE);
    else
      gtk_object_ref(GTK_OBJECT(self));
  }


  /**
   * unref_debug:
   * @self: a #GeglObject.
   * @func:
   * @line:
   * 
   **/ 
  public 
  void 
  unref_debug (self,
               const gchar *func,
               guint line)
  {
    if (self->_priv->trace_refs)
      trace_referencing(self, func, line, FALSE);
    else
      gtk_object_unref(GTK_OBJECT(self));
  }


  /**
   * trace_referencing:
   * @self: a #GeglObject.
   * @func: 
   * @line:
   * @do_ref:
   * 
   **/
  private 
  void
  trace_referencing(self,
                    const gchar *func,
                    guint line, 
                    gboolean do_ref)
  {
    fprintf (stdout, "trace: object_%s: (%s:%p)->ref_count=%d %s (%s:%d)\n",
            do_ref ? "ref" : "unref",
            gtk_type_name (GTK_OBJECT_TYPE (self)),
            self,
            GTK_OBJECT(self)->ref_count,
            do_ref ? "+ 1" : "- 1",
            func,
            line);

     if (do_ref) 
       gtk_object_ref(GTK_OBJECT(self));
     else
       gtk_object_unref(GTK_OBJECT(self));
  }
                        

  /**
   * add_interface:
   * @self: a #GeglObject.
   * @interface_name: A string for the interface name. 
   * @interface: An interface (function) pointer.
   *
   * This adds an interface which can be retrieved by name.
   **/
  public
  void 
  add_interface(self,
                const gchar* interface_name, 
                gpointer interface) 
  {
    gtk_object_set_data((GtkObject*)self, interface_name, interface);
  }
							                    

  /**
   * query_interface:
   * @self: a #GeglObject.
   * @interface_name: The interface name to look for. 
   *
   * Retreive an interface based on the name.
   * 
   * Returns: a gpointer which represents the interface or NULL.
   **/
  public
  gpointer 
  query_interface(self, 
		          const gchar* interface_name)
  {       
    return gtk_object_get_data((GtkObject*)self, interface_name);
  }


  /**
   * type_name:
   * @self: a #GeglObject.
   *
   * Get Gtk type name of this object.
   * 
   * Returns: a string.
   **/
  public 
  gchar * 
  type_name (self)
  {
     return gtk_type_name (GTK_OBJECT_TYPE (self));
  }

  protected 
  void
  log(self,
      GLogLevelFlags level,
      gchar *file,
      gint line,
      gchar *function,
      gchar *format,
      ...)
  {
    if (self->_priv->logging)
      {
        va_list args;
        va_start(args,format);
        gegl_logv(level, file, line, function, format, args);
        va_end(args);
      }
  }
}
