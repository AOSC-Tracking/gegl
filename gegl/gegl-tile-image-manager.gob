%h{
#include "gegl-image-manager.h"
#ifndef __TYPEDEF_GEGL_IMAGE__
#define __TYPEDEF_GEGL_IMAGE__
typedef struct _GeglImage  GeglImage;
#endif

#ifndef __TYPEDEF_GEGL_CACHE__
#define __TYPEDEF_GEGL_CACHE__
typedef struct _GeglCache  GeglCache;
#endif

#ifndef __TYPEDEF_GEGL_TILE__
#define __TYPEDEF_GEGL_TILE__
typedef struct _GeglTile GeglTile;
#endif

#ifndef __TYPEDEF_GEGL_TILE_KEY__
#define __TYPEDEF_GEGL_TILE_KEY__
typedef struct _GeglTileKey GeglTileKey;
#endif

struct _GeglTileKey 
{
  GeglImage *image;      
};

%}
%{
#include "gegl-tile-image-manager.h"
#include "gegl-tile-image-manager-private.h"
#include "gegl-image-manager-private.h"
#include "gegl-object-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-private.h"     /* friend access */
#include "gegl-node.h"
#include "gegl-cache.h"
#include "gegl-tile.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Tile:Image:Manager from Gegl:Image:Manager {

  private GeglCache *cache;    /*A cache for tiles*/
  private GeglImage *root;     /*The root of graph*/
  private GeglImage *dest;     /*The dest of graph*/

  public
  GeglTileImageManager *
  new(void)
  {
    GeglTileImageManager * self = GEGL_TILE_IMAGE_MANAGER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self))
      return NULL;

    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self)
  {
    g_return_val_if_fail (!(GEGL_OBJECT(self)->constructed), FALSE);

    /* Chain up */
    if (!gegl_image_manager_constructor (GEGL_IMAGE_MANAGER(self)))
      return FALSE;

    /* Create the cache. */
    self->_priv->cache = gegl_cache_new();

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(object);
    g_return_if_fail (object != NULL);

    /*gegl_cache_print(self->_priv->cache);*/
    gegl_object_unref(GEGL_OBJECT(self->_priv->cache));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Image:Manager)
  void 
  get_pixels (GeglImageManager *self_image_manager,
              GeglImage *root,
              GeglImage *dest,
              GeglRect *roi)
  {
    GeglTileImageManager *self = 
        GEGL_TILE_IMAGE_MANAGER(self_image_manager);
    g_return_if_fail(root);

    /* Save the root and dest */
    self->_priv->root = root;
    self->_priv->dest = dest;

    /* Traverse breadth first, compute need rects,
       init derived color models. */
    gegl_node_traverse_breadth_first(GEGL_NODE(root), 
                                     breadth_first_visit, 
                                     (gpointer)self);

    /* Traverse depth first, compute have rects, result rects,
       derived colormodels and do the image operation. */
    gegl_node_traverse_depth_first(GEGL_NODE(root),
                                   depth_first_visit,
                                   (gpointer)self,
                                   TRUE);

    self->_priv->root = NULL;
    self->_priv->dest = NULL;
  }

  private
  gboolean 
  breadth_first_visit(GeglNode *node,
                      gpointer data)
  {
    gint i;
    gint num_inputs = gegl_node_num_inputs(node);

    /* Compute the need rect */
    for(i = 0; i < num_inputs; i++)
        gegl_image_compute_need_rect(GEGL_IMAGE(node), i);

    /* Initialize derived color models  */
    gegl_image_set_derived_color_model(GEGL_IMAGE(node), NULL);

    return FALSE;
  }

  private
  gboolean 
  depth_first_visit(GeglNode *node,
                    gpointer data)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(data);

    /* Compute the have rect */
    gegl_image_compute_have_rect(GEGL_IMAGE(node));

    /* Compute the result rect */
    gegl_image_compute_result_rect(GEGL_IMAGE(node));

    /* Compute the derived color model */
    gegl_image_compute_derived_color_model(GEGL_IMAGE(node));

    /* Compute the image */
    compute_image(self,GEGL_IMAGE(node));
    return FALSE;
  }

  private
  void 
  compute_image(self,
                GeglImage *image)
  {
    gint i;
    GeglRect result_rect;
    GeglTile *output_tile;
    GList *request_list = NULL;
    gint num_inputs = gegl_node_num_inputs(GEGL_NODE(image));
    GeglImageRequest *requests = g_new(GeglImageRequest,num_inputs+1);

    g_print("compute_image: %s\n", gtk_type_name(GTK_OBJECT_TYPE(image)));

    /* Get the desired result rect for this op. */
    gegl_image_get_result_rect(image, &result_rect);

    /*g_print("Fetch dest tile\n"); */

    if (image == self->_priv->root && self->_priv->dest)
      output_tile = fetch_output_tile(self, self->_priv->dest, &result_rect);
    else
      output_tile = fetch_output_tile(self, image, &result_rect);

    set_request(self, &requests[0], &result_rect, output_tile);

    /* Put request on the list of requests to pass back to op. */
    request_list = g_list_append(request_list, (gpointer)&requests[0]);

    for(i = 0 ; i < num_inputs; i++)
      {
        GeglImage *input = GEGL_IMAGE(gegl_node_get_nth_input(GEGL_NODE(image),i));
        GeglRect preimage_rect;
        GeglTile *input_tile;

        /* Compute the ith inputs preimage. */
        gegl_image_compute_preimage(image,
                                    &result_rect, 
                                    &preimage_rect,
                                    i);

        /* Set the request rect */
        /* g_print("Fetching src tile: %d\n", i); */ 
        input_tile = fetch_input_tile(self, input, &preimage_rect);
        set_request(self, &requests[i+1], &preimage_rect, input_tile);

        /* Put the request on the list of requests */
        request_list = g_list_append(request_list, (gpointer)&requests[i+1]);
      }

    /* g_print("compute_image: calling prepare\n"); */
    gegl_image_prepare(image, request_list);

    /* g_print("compute_image: calling apply\n"); */
    gegl_image_apply(image, request_list);

    /* g_print("compute_image: calling finish\n"); */
    gegl_image_finish(image, request_list);

    /* Release all tiles. */
    /* g_print("compute_image: releasing tiles\n"); */
    release_tiles(self, request_list);
    /* gegl_cache_print(self->_priv->cache); */

    /* Free the requests  */ 
    g_free(requests);
    g_list_free(request_list);
  }

  private
  GeglTile *
  fetch_output_tile(self,
                    GeglImage * image,
                    GeglRect *rect)
  {
    GeglTileKey key;
    GeglTile * tile;
    GeglColorModel *image_cm = gegl_image_color_model(image); 

    g_return_val_if_fail(image, NULL);
    g_return_val_if_fail(rect, NULL);

    /* Lookup the tile for this image. */ 
    key.image = image;
    tile = gegl_cache_lookup_tile(self->_priv->cache,&key);

    if(tile)
      {
        GeglRect tile_rect;
        GeglColorModel *tile_cm = gegl_tile_get_color_model(tile);
        gegl_tile_get_area(tile, &tile_rect);

        /* Its the wrong size or color model, remove it */
        if(!gegl_rect_equal (&tile_rect, rect) || 
           tile_cm != image_cm)
          {
            gegl_cache_remove_tile(self->_priv->cache,&key);
            gegl_object_unref(GEGL_OBJECT(tile));
            tile = NULL;
          }
      }

    /* If needed, make a new tile, size of the desired area, 
       put it in the cache. */
    if (!tile)
      {
        tile = gegl_tile_new(rect,image_cm);
        gegl_cache_insert_tile(self->_priv->cache, &key, tile);
      }

    gegl_object_ref(GEGL_OBJECT(tile));
    return tile;
  }

  private
  GeglTile *
  fetch_input_tile(self,
                   GeglImage * image,
                   GeglRect * rect)  
  {
    GeglTileKey key;
    GeglTile * tile;
    GeglColorModel *image_cm = gegl_image_color_model(image); 

    g_return_val_if_fail(image, NULL);
    g_return_val_if_fail(rect, NULL);

    /* Lookup the tile for this image. */ 
    key.image = image;
    tile = gegl_cache_lookup_tile(self->_priv->cache,&key);

    if (tile)
      {
        GeglRect tile_rect;
        GeglColorModel *tile_cm = gegl_tile_get_color_model(tile); 
        gegl_tile_get_area(tile, &tile_rect);

        /*If the tile rect doesnt contain the requested rect,
          then preimage is computed incorrectly. */
        if(!gegl_rect_contains(&tile_rect, rect) || 
            tile_cm != image_cm)
          {
            tile = NULL;
          }
      }

    if (!tile)
      {
        g_warning("GeglTileImageManager:fetch_input_tile: input tile NULL");  
        return NULL;
      }

    gegl_object_ref(GEGL_OBJECT(tile));
    return tile;
  }

  override (Gegl:Image:Manager) 
  void 
  delete_image (GeglImageManager *self_image_manager,
                GeglImage *image)
  {
    GeglTileImageManager *self = 
      GEGL_TILE_IMAGE_MANAGER(self_image_manager);
    GeglTileKey key;
    GeglTile * tile = NULL;

    key.image = image;

    /* Remove the tile for this image from cache. */ 
    tile = gegl_cache_remove_tile(self->_priv->cache,&key);

    if(tile)
      gegl_object_unref(GEGL_OBJECT(tile));
  }

  public
  void
  print_key(self,
            GeglTileKey *k)
  {
    g_print("key is [%x]\n", (guint)(k->image)); 
  }

  private
  void
  release_tiles(self,
                GList *request_list)
                 
  {
    g_list_foreach(request_list, release_tile, NULL);
  }

  private
  void 
  release_tile(gpointer data,
               gpointer user_data)
                 
  {
    GeglImageRequest *request = (GeglImageRequest*)data;

    /* Just unref the tile for now */
    if(request->tile)
      gegl_object_unref(GEGL_OBJECT(request->tile));
  }

  private
  void
  set_request(self,
              GeglImageRequest *request,
              GeglRect *rect, 
              GeglTile *tile)
  {               
    gegl_rect_copy(&request->rect,rect);
    request->tile = tile;
  }
}
