%h{
#include "gegl-image-manager.h"

#ifndef __TYPEDEF_GEGL_IMAGE_BUFFER__
#define __TYPEDEF_GEGL_IMAGE_BUFFER__
typedef struct _GeglImageBuffer  GeglImageBuffer;
#endif

#ifndef __TYPEDEF_GEGL_CACHE__
#define __TYPEDEF_GEGL_CACHE__
typedef struct _GeglCache  GeglCache;
#endif

#ifndef __TYPEDEF_GEGL_TILE__
#define __TYPEDEF_GEGL_TILE__
typedef struct _GeglTile GeglTile;
#endif

#ifndef __TYPEDEF_GEGL_TILE_KEY__
#define __TYPEDEF_GEGL_TILE_KEY__
typedef struct _GeglTileKey GeglTileKey;
#endif

struct _GeglTileKey 
{
  GeglImage *image;      
};

%}

%{
#include "gegl-tile-image-manager.h"
#include "gegl-tile-image-manager-private.h"
#include "gegl-image-manager-private.h"
#include "gegl-object-private.h"
#include "gegl-image-private.h"    
#include "gegl-image-buffer.h"
#include "gegl-statistics-op-private.h"    
#include "gegl-op-private.h" 
#include "gegl-node.h"
#include "gegl-node-private.h" 
#include "gegl-cache.h"
#include "gegl-tile.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Tile:Image:Manager from Gegl:Image:Manager {

  private GeglCache *cache;    /*A cache for tiles*/

  /**
   * new:
   *
   * Creates a new #GeglTileImageManager.
   * 
   * Returns: a new #GeglTileImageManager.
   **/ 
  public
  GeglTileImageManager *
  new(void)
  {
    GeglTileImageManager * self = GEGL_TILE_IMAGE_MANAGER(GET_NEW);

    /*Call the constructor */
    if (!constructor(self))
      return NULL;

    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglTileImageManager
   *
   * Initializes a #GeglTileImageManager.
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self)
  {
    g_return_val_if_fail (!(GEGL_OBJECT(self)->constructed), FALSE);

    /* Chain up */
    if (!gegl_image_manager_constructor (GEGL_IMAGE_MANAGER(self)))
      return FALSE;

    /* Create the cache. */
    self->_priv->cache = gegl_cache_new();

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Frees memory allocated by this object. Unrefs the cache.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(object);
    g_return_if_fail (object != NULL);

    gegl_object_unref(GEGL_OBJECT(self->_priv->cache));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * apply:
   * @self_image_manager: a #GeglImageManager
   * @root: root node of graph.
   * @dest: an optional destination #GeglImage for result.
   * @roi: an optional region of interest.
   *
   * This evaluates the image graph. The graph is traversed breadth-first to
   * set up need rects. Then depth-first to set up have rects, result rects,
   * and derived color models. Finally each op is called to do its operation. 
   *
   **/ 
  override (Gegl:Image:Manager)
  void 
  apply(GeglImageManager *self_image_manager,
        GeglOp *root,
        GeglImageBuffer *dest,
        GeglRect *roi)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(self_image_manager);
    GeglImage *root_image = NULL;
    GeglRect need_rect;
    g_return_if_fail(root);

    /* Save the dest and the roi */
    LOG_DEBUG("node %x type %s", (guint)root, 
               gegl_object_type_name(GEGL_OBJECT(root)));

    /* Find the descendant of root that is an image */ 
    if (!GEGL_IS_IMAGE(root))
      {
        gint index = gegl_node_get_alt_input(GEGL_NODE(root));
        root_image = get_image_input(self, GEGL_NODE(root), index);
      }
    else
      root_image = GEGL_IMAGE(root);

    /* Figure out what roi to use. */
    if (roi)
      gegl_rect_copy(&need_rect,roi);
    else if(dest)
      {
        gint width = gegl_image_buffer_get_width(dest);
        gint height = gegl_image_buffer_get_height(dest);
        gegl_rect_set(&need_rect,0,0,width,height);
      }
    else
      gegl_rect_set(&need_rect,0,0,G_MAXINT,G_MAXINT);

    gegl_image_set_need_rect(root_image,&need_rect);
    if(dest)
      gegl_image_set_dest(root_image,GEGL_IMAGE(dest));

    LOG_DEBUG("calling traverse_breadth_first"); 
    /* Traverse breadth first, compute need rects,
       init derived color models. */
    gegl_node_traverse_breadth_first(GEGL_NODE(root), 
                                     breadth_first_visit, 
                                     (gpointer)self);

    LOG_DEBUG("calling traverse_depth_first"); 
    /* Traverse depth first, compute have rects, result rects,
       derived colormodels and do the image operation. */
    gegl_node_traverse_depth_first(GEGL_NODE(root),
                                   depth_first_visit,
                                   (gpointer)self,
                                   TRUE);

  }


  /**
   * get_image_inputs:
   * @self: a #GeglTileImageManager.
   * @node: #GeglNode to process.
   * 
   * Constructs an image inputs list for this #GeglNode. 
   *
   * Returns: a #GeglImage list, must be freed. 
   **/ 
  private 
  GList *
  get_image_inputs(self,
                   GeglNode *node)
  {
     GList *list = NULL;
     gint num_inputs = gegl_node_num_inputs(node);
     gint i;

     /* Look down the graph and find images to use for each input. */
     for(i = 0; i < num_inputs; i++)
       {
           /* Find an image to use for ith input. */
           GeglImage *image_input = get_image_input(self,node,i);
           list = g_list_append (list, image_input);
       }

     return list;
  }


  /**
   * get_image_input:
   * @self: a #GeglTileImageManager.
   * @node: #GeglNode to process.
   * @i: which input to look for.
   * 
   * Finds an image input for the @i input of @node. 
   *
   * Returns: a #GeglImage, or NULL if not found. 
   **/ 
  private
  GeglImage*
  get_image_input(self,
                  GeglNode *node,
                  gint i)
  {
    GeglNode *input = gegl_node_get_nth_input(node,i);

    while(input && !GEGL_IS_IMAGE(input)) 
      { 
        gint index = gegl_node_get_alt_input(input);
        input = gegl_node_get_nth_input(input,index);
      }

    return input ? GEGL_IMAGE(input): NULL;
  }


  /**
   * breadth_first_visit:
   * @node: #GeglNode to process.
   * @data: the #GeglTileImageManager.
   * 
   * Compute need rects and initialize the derived color model flag to NULL for
   * each node.
   *
   * Returns: FALSE to continue traversal. 
   **/ 
  private
  gboolean 
  breadth_first_visit(GeglNode *node,
                      gpointer data)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(data);

    /* Get the list of image inputs for this node. */
    GList * image_inputs = get_image_inputs(self, node); 

    LOG_DEBUG("node %x type %s", (guint)node, 
               gegl_object_type_name(GEGL_OBJECT(node)));

    /* Check to see if its an Image node. */
    if (GEGL_IS_IMAGE(node))
      {
        gint i;
        gint num_image_inputs = g_list_length(image_inputs);

        /* Compute the need rect of each image input. */
        for(i = 0; i < num_image_inputs; i++)
          {
            GeglRect preimage_rect;
            GeglRect need_rect;
            GeglImage *image_input = GEGL_IMAGE(g_list_nth_data(image_inputs,i));

            /* Get the need rect of the current node. */
            gegl_image_get_need_rect(GEGL_IMAGE(node), &need_rect);

            /* Get the preimage of the need rect on ith input */
            gegl_image_compute_preimage(GEGL_IMAGE(node),
                                        image_inputs,
                                        &need_rect,
                                        &preimage_rect,
                                        i);

            /* Set the need_rect of the input_image */
            gegl_image_set_need_rect(image_input, &preimage_rect);


            /*LOG_DEBUG("computed preimage_rect for %d th input: %d %d %d %d", i, 
                       preimage_rect.x, preimage_rect.y,
                       preimage_rect.w, preimage_rect.h); */


          }


        /* Initialize derived color models  */
        gegl_image_set_derived_color_model(GEGL_IMAGE(node), NULL);

      }
    else
      {
        LOG_DEBUG("not an Image node, nothing to do");
      }

    /* Free the image inputs list. */
    g_list_free(image_inputs);

    return FALSE;
  }


  /**
   * depth_first_visit:
   * @node: #GeglNode to process.
   * @data: the #GeglTileImageManager.
   *
   * Computes have rects, result rects, derived color models and then the image
   * result for each @node.  
   *
   * Returns: FALSE to continue traversal. 
   **/ 
  private
  gboolean 
  depth_first_visit(GeglNode *node,
                    gpointer data)
  {
    GeglTileImageManager *self = GEGL_TILE_IMAGE_MANAGER(data);

    /* Get the list of image inputs for this node. */
    GList * image_inputs = get_image_inputs(self, node); 

    LOG_DEBUG("node %x type %s", (guint)node, 
               gegl_object_type_name(GEGL_OBJECT(node)));


    if (GEGL_IS_IMAGE(node))
      {
        /* Compute the have rect */
        gegl_image_compute_have_rect(GEGL_IMAGE(node), image_inputs);

        /* Compute the result rect */
        gegl_image_compute_result_rect(GEGL_IMAGE(node), image_inputs);

        /* Compute the derived color model */
        gegl_image_compute_derived_color_model(GEGL_IMAGE(node), image_inputs);

        /* Compute the image */
        compute_image(self,GEGL_IMAGE(node), image_inputs);

      }
    else if (GEGL_IS_STATISTICS_OP(node))
      {
        LOG_DEBUG("its a statistics op");
        compute_statistics_op(self, GEGL_STATISTICS_OP(node), image_inputs);
      }
    else
      {
        LOG_DEBUG("neither statistics or image, need to call prepare,process,finish");
      }


    /* Free the list of image inputs. */
    g_list_free(image_inputs);

    return FALSE;
  }


  /**
   * compute_statistics_op:
   * @self: a #GeglTileImageManager 
   * @statistics_op: #GeglStatisticsOp to compute.
   * @image_inputs: #GeglImage list.
   *
   * Retrieve the tiles from the cache to use for sources for this statistics
   * operation.  Set up an #GeglOpRequest for each, and pass the list of
   * requests to @statistics_op in the prepare, process, and finish routines.
   * Release the tiles after processing. 
   *
   **/ 
  private
  void 
  compute_statistics_op(self,
                        GeglStatisticsOp *statistics_op, 
                        GList *image_inputs)
  {
    gint i;
    GList *request_list = NULL;
    gint num_image_inputs = g_list_length(image_inputs);
    GeglOpRequest *requests = g_new(GeglOpRequest,num_image_inputs);

    LOG_DEBUG("node %x type %s", (guint)statistics_op,
               gegl_object_type_name(GEGL_OBJECT(statistics_op)));

    for(i = 0 ; i < num_image_inputs; i++)
      {
        GeglImage *image_input = GEGL_IMAGE(g_list_nth_data(image_inputs,i));
        GeglRect result_rect;
        GeglTile *input_tile;

        /* Just get the result rect of the input. */
        gegl_image_get_result_rect(image_input, &result_rect);

        /*LOG_DEBUG("Fetching src tile for %d the input", i);*/ 

        /* Set the request rect */
        input_tile = fetch_input_tile(self, image_input, &result_rect);

        /*LOG_DEBUG("got src tile %x", (guint)input_tile); */ 

        set_request(self, &requests[i], &result_rect, input_tile);

        /* Put the request on the list of requests */
        request_list = g_list_append(request_list, (gpointer)&requests[i]);
      }

    /* LOG_DEBUG("Request list is"); 
    print_request_list(self,request_list); */

    LOG_DEBUG("%s", "Calling prepare"); 
    gegl_op_prepare(GEGL_OP(statistics_op), request_list);

    LOG_DEBUG("%s", "Calling process"); 
    gegl_op_process(GEGL_OP(statistics_op), request_list);

    LOG_DEBUG("%s", "Calling finish"); 
    gegl_op_finish(GEGL_OP(statistics_op), request_list);

    /* Release all tiles. */
    release_tiles(self, request_list);

    /* Free the requests  */ 
    g_free(requests);
    g_list_free(request_list);
  }


  /**
   * compute_image:
   * @self: a #GeglTileImageManager 
   * @image: #GeglImage to compute.
   * @image_inputs: #GeglImage list.
   *
   * Retrieve the tiles from the cache to use for dest and sources for this
   * image operation.  Set up an #GeglOpRequest for each, and pass the list of
   * requests to @image in prepare, process, and finish routines.  Release the
   * tiles after processing. 
   *
   **/ 
  private
  void 
  compute_image(self,
                GeglImage *image, 
                GList *image_inputs)
  {
    gint i;
    GeglRect result_rect;
    GeglTile *output_tile;
    GeglImage *dest = NULL;
    GList *request_list = NULL;
    gint num_image_inputs = g_list_length(image_inputs);
    GeglOpRequest *requests = g_new(GeglOpRequest,num_image_inputs+1);

    LOG_DEBUG("node %x type %s", (guint)image, 
               gegl_object_type_name(GEGL_OBJECT(image)));

    /* Get the desired result rect for this op. */
    gegl_image_get_result_rect(image, &result_rect);
    
    /* Get the destination from the image. */
    dest = gegl_image_get_dest(image);

    if(dest == NULL)
      dest = image;

    /* LOG_DEBUG("dest image is: %x", (guint)dest); */ 
    /* LOG_DEBUG("fetching dest tile"); */ 

    output_tile = fetch_output_tile(self, dest, &result_rect);

    /* LOG_DEBUG("got dest tile %x", (guint)output_tile); */ 

    set_request(self, &requests[0], &result_rect, output_tile);

    /* Put request on the list of requests to pass back to op. */
    request_list = g_list_append(request_list, (gpointer)&requests[0]);

    for(i = 0 ; i < num_image_inputs; i++)
      {
        GeglImage *image_input = GEGL_IMAGE(g_list_nth_data(image_inputs,i));
        GeglRect preimage_rect;
        GeglTile *input_tile;

        /* Compute the ith inputs preimage. */
        gegl_image_compute_preimage(image,
                                    image_inputs,
                                    &result_rect, 
                                    &preimage_rect,
                                    i);

        /* LOG_DEBUG("Fetching src tile for %d the input", i); */ 

        /* Set the request rect */
        input_tile = fetch_input_tile(self, image_input, &preimage_rect);

        /* LOG_DEBUG("got src tile %x", (guint)input_tile); */ 

        set_request(self, &requests[i+1], &preimage_rect, input_tile);

        /* Put the request on the list of requests */
        request_list = g_list_append(request_list, (gpointer)&requests[i+1]);
      }

    /* LOG_DEBUG("Request list is"); 
    print_request_list(self,request_list); */

    LOG_DEBUG("%s", "Calling prepare"); 
    gegl_op_prepare(GEGL_OP(image), request_list);

    LOG_DEBUG("%s", "Calling process"); 
    gegl_op_process(GEGL_OP(image), request_list);

    LOG_DEBUG("%s", "Calling finish"); 
    gegl_op_finish(GEGL_OP(image), request_list);

    /* Release all tiles. */
    release_tiles(self, request_list);

    /* Free the requests  */ 
    g_free(requests);
    g_list_free(request_list);
  }


  /**
   * fetch_output_tile:
   * @self: a #GeglTileImageManager 
   * @image: output #GeglImage to fetch a #GeglTile for.
   * @rect: area needed.
   *
   * Fetch a tile to use for output. 
   *
   * Returns: a #GeglTile to use for output.
   **/ 
  private
  GeglTile *
  fetch_output_tile(self,
                    GeglImage * image,
                    GeglRect *rect)
  {
    GeglTileKey key;
    GeglTile * tile;
    GeglColorModel *image_cm = gegl_image_color_model(image); 

    g_return_val_if_fail(image, NULL);
    g_return_val_if_fail(rect, NULL);

    /* Lookup the tile for this image. */ 
    key.image = image;
    tile = gegl_cache_lookup_tile(self->_priv->cache,&key);

    if(tile)
      {
        GeglRect tile_rect;
        GeglColorModel *tile_cm = gegl_tile_get_color_model(tile);
        gegl_tile_get_area(tile, &tile_rect);

        /* Its the wrong size or color model, remove it */
        if(!gegl_rect_equal (&tile_rect, rect) || 
           tile_cm != image_cm)
          {
            gegl_cache_remove_tile(self->_priv->cache,&key);
            gegl_object_unref(GEGL_OBJECT(tile));
            tile = NULL;
          }
      }

    /* If needed, make a new tile, size of the desired area, 
       put it in the cache. */
    if (!tile)
      {
        tile = gegl_tile_new(rect,image_cm);
        gegl_cache_insert_tile(self->_priv->cache, &key, tile);
      }

    gegl_object_ref(GEGL_OBJECT(tile));
    return tile;
  }


  /**
   * fetch_input_tile:
   * @self: a #GeglTileImageManager 
   * @image: input #GeglImage to fetch a #GeglTile for.
   * @rect: area needed.
   *
   * Fetch a tile to use for input.
   *
   * Returns: a #GeglTile to use for input.
   **/ 
  private
  GeglTile *
  fetch_input_tile(self,
                   GeglImage * image,
                   GeglRect * rect)  
  {
    GeglTileKey key;
    GeglTile * tile;
    GeglColorModel *image_cm = gegl_image_color_model(image); 

    g_return_val_if_fail(image, NULL);
    g_return_val_if_fail(rect, NULL);

    /* Lookup the tile for this image. */ 
    key.image = image;
    tile = gegl_cache_lookup_tile(self->_priv->cache,&key);

    if (tile)
      {
        GeglRect tile_rect;
        GeglColorModel *tile_cm = gegl_tile_get_color_model(tile); 
        gegl_tile_get_area(tile, &tile_rect);

        /*If the tile rect doesnt contain the requested rect,
          then preimage is computed incorrectly. */
        if(!gegl_rect_contains(&tile_rect, rect) || 
            tile_cm != image_cm)
          {
            tile = NULL;
          }
      }

    if (!tile)
      {
        g_warning("GeglTileImageManager:fetch_input_tile: input tile NULL");  
        return NULL;
      }

    gegl_object_ref(GEGL_OBJECT(tile));
    return tile;
  }


  /**
   * delete_image:
   * @self_image_manager: a #GeglImageManager. 
   * @image: #GeglImage to delete tiles for.
   * @rect: area needed.
   *
   * Delete an image's tile(s) from the cache.
   *
   **/ 
  override (Gegl:Image:Manager) 
  void 
  delete_image (GeglImageManager *self_image_manager,
                GeglImage *image)
  {
    GeglTileImageManager *self = 
      GEGL_TILE_IMAGE_MANAGER(self_image_manager);
    GeglTileKey key;
    GeglTile * tile = NULL;

    key.image = image;

    /* Remove the tile for this image from cache. */ 
    tile = gegl_cache_remove_tile(self->_priv->cache,&key);

    if(tile)
      gegl_object_unref(GEGL_OBJECT(tile));
  }


  /**
   * release_tiles:
   * @self: a #GeglTileImageManager. 
   * @request_list: #GeglOpRequest list. 
   *
   * Release all the tiles on @request_list after image processing.
   *
   **/ 
  private
  void
  release_tiles(self,
                GList *request_list)
                 
  {
    g_list_foreach(request_list, release_tile, NULL);
  }


  /**
   * release_tile:
   * @data: an #GeglOpRequest 
   * @user_data:
   *
   * Release the tile of this #GeglOpRequest. 
   *
   **/ 
  private
  void 
  release_tile(gpointer data,
               gpointer user_data)
                 
  {
    GeglOpRequest *request = (GeglOpRequest*)data;

    /* Just unref the tile for now */
    if(request->tile)
      gegl_object_unref(GEGL_OBJECT(request->tile));
  }


  /**
   * set_request:
   * @self: a #GeglTileImageManager
   * @request: the #GeglOpRequest to set. 
   * @rect: a rect.
   * @tile: a #GeglTile.
   *
   * Put @rect and @tile into @request. 
   *
   **/ 
  private
  void
  set_request(self,
              GeglOpRequest *request,
              GeglRect *rect, 
              GeglTile *tile)
  {               
    gegl_rect_copy(&request->rect,rect);
    request->tile = tile;
  }

  public
  void
  print_request_list(self, 
                     GList *requests)
  {
    g_list_foreach(requests, print_request, NULL);
  }

  public
  void
  print_request(gpointer data,
                gpointer user_data)
  {
    GeglOpRequest *request = (GeglOpRequest*)data;

    g_log("Gegl", G_LOG_LEVEL_DEBUG,
          "request: rect %d %d %d %d, tile: %x",
           request->rect.x, request->rect.y, request->rect.w, request->rect.h,
           (guint)request->tile);
  }

  public
  void
  print_key(self,
            GeglTileKey *k)
  {
    g_print("key is [%x]\n", (guint)(k->image)); 
  }
}
