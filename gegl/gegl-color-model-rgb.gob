%h{
#include "gegl-color-model.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor GeglColor;
#endif
%}
%{
#include "gegl-color-model-rgb.h"
#include "gegl-color-model-rgb-private.h"
#include "gegl-color-model-private.h"
#include "gegl-object-private.h"
#include "gegl-color.h"
%}

class Gegl:Color:Model:Rgb from Gegl:Color:Model {

  protected gint red_index;
  protected gint green_index;
  protected gint blue_index;

  /**
   * constructor: 
   * @self: a #GeglColorModelRgb
   * @has_alpha: TRUE if the color model has an alpha channel.  
   *
   * Initializes a #GeglColorModelRgb.
   * 
   * Returns: TRUE if constructed successfully.
   **/
  protected 
  gboolean 
  constructor(self, 
              gboolean has_alpha)
  {
    GeglColorModel*self_color_model = GEGL_COLOR_MODEL (self);

    if (GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_constructor (self_color_model, has_alpha))
      return FALSE;

    if (self_color_model->has_alpha)
     {
       self_color_model->alpha_channel = 3;
       self_color_model->num_channels = 4;
     }
    else
     {
       self_color_model->alpha_channel = -1;
       self_color_model->num_channels = 3;
     }

    /* We can set these here */
    self_color_model->colorspace = GEGL_COLOR_SPACE_RGB;
    self_color_model->is_additive = TRUE;
    self_color_model->color_space_name = NULL;
    
    /* Allocate memory for these then --will need a destroy then */
    self_color_model->channel_names = NULL;
    self_color_model->color_space_name = NULL;

    /* Right now just do the typical rgb */ 

    self->red_index = 0;
    self->green_index = 1;
    self->blue_index = 2;

    return TRUE;
  }
  
  /**
   * destroy:
   * @object:
   * 
   * Frees memory allocated by this object. Free the name strings.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Dispose of the all the strings here */

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  /**
   * color_alpha_space: 
   * @self_color_model: a #GeglColorModel
   *
   * Gets the #GeglColorAlphaSpace of the color model.(eg RGB, RGBA, GRAY,
   * GRAYA).
   *
   * Returns: The #GeglColorAlphaSpace of this color model.
   **/
  override (Gegl:Color:Model)
  GeglColorAlphaSpace
  color_alpha_space(GeglColorModel *self_color_model)
  {
    if (self_color_model->has_alpha)
      return GEGL_COLOR_ALPHA_SPACE_RGBA;
    else
      return GEGL_COLOR_ALPHA_SPACE_RGB;
  }


  /**
   * get_red_index:
   * @self: a #GeglColorModelRgb.
   *
   * Gets the index of the red channel.
   *
   * Returns: The index of of red channel.
   **/
  public
  gint 
  get_red_index (self) 
  { 
    return self->red_index; 
  }

  /**
   * get_green_index:
   * @self: a #GeglColorModelRgb.
   *
   * Gets the index of the green channel.
   *
   * Returns: The index of of green channel.
   **/
  public 
  gint 
  get_green_index (self)
  { 
    return self->green_index; 
  }

  /**
   * get_blue_index:
   * @self: a #GeglColorModelRgb.
   *
   * Gets the index of the blue channel.
   *
   * Returns: The index of of blue channel.
   **/
  public
  gint 
  get_blue_index (self)
  { 
    return self->blue_index; 
  }

}
