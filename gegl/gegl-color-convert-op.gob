%h{
#include "gegl-single-src-op.h"
%}

%privateheader{
#include "gegl-color-model.h"
%}

%{
#include "gegl-color-convert-op.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Color:Convert:Op from Gegl:Single:Src:Op {

  private gfloat *float_xyz_data[4];
  private ConvertFunc convert_func;

  private GeglColorSpace color_space;       /* Convert to this space */
  private GeglChannelDataType data_type;    /* or this data type */

  public 
  GeglColorConvertOp *
  new (GeglImage *src,
       GeglColorModel *color_model)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src, color_model))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self,
              GeglImage *src,
              GeglColorModel *color_model)
  {
    g_return_val_if_fail(color_model, FALSE);
    return common_constructor(self,src,color_model, 
                GEGL_COLOR_SPACE_NONE, GEGL_NONE);
  }

  public
  GeglColorConvertOp *
  new1 (GeglImage *src,
        GeglColorSpace color_space)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor1(self, src, color_space))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }
  
  protected 
  gboolean 
  constructor1(self,
               GeglImage *src,
               GeglColorSpace color_space)
  {
    return common_constructor(self,src,NULL, 
        color_space, GEGL_NONE);
  }

  public
  GeglColorConvertOp *
  new2 (GeglImage *src,
        GeglChannelDataType data_type)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor2(self, src, data_type))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }
  
  protected 
  gboolean 
  constructor2(self,
               GeglImage *src,
               GeglChannelDataType data_type)
  {
    return common_constructor(self,src,NULL,
        GEGL_COLOR_SPACE_NONE, data_type);
  }

  private 
  gboolean 
  common_constructor(self,
                     GeglImage *src,
                     GeglColorModel *color_model,
                     GeglColorSpace color_space,
                     GeglChannelDataType data_type)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    {
      gint i;
      GeglImage *self_image = GEGL_IMAGE(self); 

      /* Will set the convert_func in prepare */ 
      self->_priv->convert_func = NULL;

      /* Set the color model for this op, we know what it is already.*/ 
      if (color_model)
        {
          gegl_image_set_color_model(self_image,color_model);

          self->_priv->color_space = gegl_color_model_color_space(color_model);
          self->_priv->data_type = gegl_color_model_data_type(color_model);
        }
      else
        {
          self->_priv->color_space = color_space;
          self->_priv->data_type = data_type;
        }

      for(i = 0; i < 4; i++)
        self->_priv->float_xyz_data[i] = NULL;
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(object);
    free_xyz_data (self);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override(Gegl:Image)
  void
  compute_derived_color_model(GeglImage *self_image)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(self_image);
    if (!gegl_image_color_model(self_image))
      {
        GeglColorModel *derived= NULL;

        GeglImage *src = GEGL_IMAGE(gegl_node_get_nth_input(GEGL_NODE(self_image),0));
        GeglColorModel *src_cm = gegl_image_color_model(src);
        GeglColorSpace src_space = gegl_color_model_color_space(src_cm); 
        GeglChannelDataType src_type = gegl_color_model_data_type(src_cm); 
        gboolean src_has_alpha = gegl_color_model_has_alpha(src_cm); 

        /* Set the derived color model based on colorspace/data type of input */
        if (self->_priv->color_space != GEGL_COLOR_SPACE_NONE &&
            self->_priv->data_type == GEGL_NONE)
          derived = gegl_color_model_instance2(self->_priv->color_space,
                                               src_type,
                                               src_has_alpha);
        else if (self->_priv->data_type != GEGL_NONE &&
                 self->_priv->color_space == GEGL_COLOR_SPACE_NONE)
          derived = gegl_color_model_instance2(src_space,
                                               self->_priv->data_type,
                                               src_has_alpha);
        else
          g_warning("GeglColorConvertOp: cant derive color model");

        /* Set the derived color model. */ 
        gegl_image_set_derived_color_model (self_image,derived);
      }
  }

  private
  void
  allocate_xyz_data (self,
      		     gint width)
  {
    gint i;
    for(i = 0; i < 4; i++)
      self->_priv->float_xyz_data[i] = 
    g_malloc (sizeof(gfloat) * width); 
  }

  private
  void
  free_xyz_data (self)
  {
    gint i;
    for(i = 0; i < 4; i++)
      {
        if (self->_priv->float_xyz_data[i]) 
            g_free (self->_priv->float_xyz_data[i]);

        self->_priv->float_xyz_data[i] = NULL; 
      }	
  }

  override (Gegl:Image) 
  void
  prepare(GeglImage *self_image,
          GList *requests)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(self_image);
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_image)->klass);
    GeglImageRequest *dest_request = 
      (GeglImageRequest*)g_list_nth_data(requests,0); 
    GeglColorModel * dest_cm =
      gegl_tile_get_color_model (dest_request->tile);
    GeglImageRequest *src_request =
      (GeglImageRequest*)g_list_nth_data(requests,1); 
    GeglColorModel * src_cm =
      gegl_tile_get_color_model (src_request->tile);

    g_return_if_fail(dest_cm);
    g_return_if_fail(src_cm);

      {
        /* Get the name of the interface that converts from src cm */ 
        gchar *converter_name =
            gegl_color_model_get_converter_interface_name (src_cm); 

        /* Check to see if the dest cm implements this conversion*/ 
        self->_priv->convert_func = 
          (ConvertFunc)gegl_object_query_interface (GEGL_OBJECT(dest_cm), 
                                                    converter_name);   

        g_free (converter_name);

        if (!self->_priv->convert_func)
          {
            /* Allocate scanlines for the XYZ data */
            free_xyz_data (self);
            allocate_xyz_data (self, dest_request->rect.w); 
          }

        /* Set the scanline version of this class to be called */
        self_point_op_class->scanline_func = gegl_color_convert_op_scanline;
      }
  } 

  private 
  void
  scanline(GeglPointOp *self_point_op,
           GeglTileIterator **iters, 
           gint width)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP (self_point_op);
    GeglColorModel *dest_cm = gegl_tile_iterator_get_color_model(iters[0]);
    GeglColorModel *src_cm = gegl_tile_iterator_get_color_model(iters[1]);
    guint dest_nchans = gegl_color_model_num_channels (dest_cm);
    guint src_nchans = gegl_color_model_num_channels (src_cm);
    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_nchans);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_nchans);

    gegl_tile_iterator_get_current(iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current(iters[1], (gpointer*)src_data);

    /* Call the converter if installed, else do XYZ conversion */ 
       
    if (self->_priv->convert_func)
        (self->_priv->convert_func) (dest_cm, src_cm, 
                                     dest_data, src_data, 
                                     width); 
    else
      {
        gegl_color_model_convert_to_xyz (src_cm, 
           self->_priv->float_xyz_data, src_data, width);

        gegl_color_model_convert_from_xyz (dest_cm, 
           dest_data, self->_priv->float_xyz_data , width);
      }

    g_free (dest_data);
    g_free (src_data);
  }
}
