%h{
#include "gegl-single-src-op.h"
%}

%privateheader{
#include "gegl-color-model.h"
%}

%{
#include "gegl-color-convert-op.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Color:Convert:Op from Gegl:Single:Src:Op {

  private gfloat *float_xyz_data[4];
  private ConvertFunc convert_func;
  
  protected 
  gboolean 
  constructor(self, 
              GeglImage *src) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    {
      gint i;
      self->_priv->convert_func = NULL;

      for(i = 0; i < 4; i++)
	self->_priv->float_xyz_data[i] = NULL;
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    free_xyz_data (GEGL_COLOR_CONVERT_OP(object));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  allocate_xyz_data (self,
      		     gint width)
  {
    gint i;
    for(i = 0; i < 4; i++)
      self->_priv->float_xyz_data[i] = 
	g_malloc (sizeof(gfloat) * width); 
  }

  private
  void
  free_xyz_data (self)
  {
    gint i;
    for(i = 0; i < 4; i++)
      {
	if (self->_priv->float_xyz_data[i]) 
	  g_free (self->_priv->float_xyz_data[i]);

        self->_priv->float_xyz_data[i] = NULL; 
      }	
  }

  override (Gegl:Op) 
  void
  prepare(GeglOp *self_op,
          GeglImage *dest,
          GeglRect *dest_rect)
  {
    GeglColorConvertOp *self = SELF (self_op);
    GeglPointOp *self_point_op = GEGL_POINT_OP (self);
    GeglNode * self_node = GEGL_NODE(self);
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_point_op)->klass);

    GeglImage *input0 = GEGL_IMAGE(gegl_node_get_nth_input(self_node,0));
    GeglColorModel * dest_cm = gegl_image_color_model (dest);
    GeglColorModel * src_cm = gegl_image_color_model (input0); 

    /* Get the name of the interface that converts from src cm */ 
    gchar *converter_name = 
      gegl_color_model_get_converter_interface_name (src_cm); 

    /* Check to see if the dest cm implements this conversion*/ 
    self->_priv->convert_func = 
      (ConvertFunc)gegl_object_query_interface (GEGL_OBJECT(dest_cm), 
						converter_name);   
    g_free (converter_name);

    if (!self->_priv->convert_func)
      {
        /* Allocate scanlines for the XYZ data */
        free_xyz_data (self);
        allocate_xyz_data (self, dest_rect->w); 
      }

    /* Set the scanline version of this class to be called */
    self_point_op_class->scanline_func = gegl_color_convert_op_scanline;
  } 

  private 
  void
  scanline(GeglPointOp *point_op,
           GeglImageIterator *dest_iter, 
           GeglImageIterator **src_iters)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP (point_op);
    GeglImage * dest_image = gegl_image_iterator_get_image (dest_iter);
    GeglImage * src_image  = gegl_image_iterator_get_image (src_iters[0]);
    GeglColorModel * dest_cm = gegl_image_color_model (dest_image);
    GeglColorModel * src_cm = gegl_image_color_model (src_image);
    guint dest_nchans = gegl_color_model_num_channels (dest_cm);
    guint src_nchans = gegl_color_model_num_channels (src_cm);

    guint width = gegl_image_iterator_scanline_width (dest_iter);

    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_nchans);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_nchans);

    gegl_image_iterator_get_scanline_data (dest_iter, dest_data);
    gegl_image_iterator_get_scanline_data (src_iters[0], src_data);

    /* Call the converter if installed, else do XYZ conversion */ 
       
    if (self->_priv->convert_func)
        (self->_priv->convert_func) (dest_cm, src_cm, dest_data, src_data, width); 
    else
      {
        gegl_color_model_convert_to_xyz (src_cm, 
           self->_priv->float_xyz_data, src_data, width);

        gegl_color_model_convert_from_xyz (dest_cm, 
           dest_data, self->_priv->float_xyz_data , width);
      }

    g_free (dest_data);
    g_free (src_data);
  }
}
