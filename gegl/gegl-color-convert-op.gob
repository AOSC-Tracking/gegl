%h{
#include "gegl-single-src-op.h"
%}

%privateheader{
#include "gegl-color-model.h"
%}

%{
#include "gegl-color-convert-op.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-utils.h"
#include <stdio.h>
%}

class Gegl:Color:Convert:Op from Gegl:Single:Src:Op {

  private gfloat *float_xyz_data[4];
  private ConvertFunc convert_func;

  private GeglColorSpace color_space;       /* Convert to this space */
  private GeglChannelDataType data_type;    /* or this data type */


  /**
   * new: 
   * @src: an input #GeglOp.
   * @color_model: a #GeglColorModel to convert to.
   *
   * Creates a new #GeglColorConvertOp which converts to @color_model.
   * 
   * Returns: a new #GeglColorConvertOp.
   **/
  public 
  GeglColorConvertOp *
  new (GeglOp *src,
       GeglColorModel *color_model)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src, color_model))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglConvertOp.
   * @src: an input #GeglOp.
   * @color_model: a #GeglColorModel to convert to.
   *
   * Initializes a #GeglConvertOp.
   * 
   * Returns: TRUE if constructed successfully. 
   **/
  protected 
  gboolean 
  constructor(self,
              GeglOp *src,
              GeglColorModel *color_model)
  {
    g_return_val_if_fail(color_model, FALSE);
    return common_constructor(self,src,color_model, 
                GEGL_COLOR_SPACE_NONE, GEGL_NONE);
  }


  /**
   * new1: 
   * @src: an input #GeglOp.
   * @color_space: a #GeglColorSpace to convert to.
   *
   * Creates a new #GeglColorConvertOp which converts to @color_space.
   * 
   * Returns: a new #GeglColorConvertOp.
   **/
  public
  GeglColorConvertOp *
  new1 (GeglOp *src,
        GeglColorSpace color_space)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor1(self, src, color_space))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }
  

  /**
   * constructor1:
   * @self: a #GeglConvertOp.
   * @src: an input #GeglOp.
   * @color_space: a #GeglColorSpace to convert to.
   * 
   * Initializes a #GeglConvertOp.
   *
   * Returns: TRUE if constructed successfully. 
   **/
  protected 
  gboolean 
  constructor1(self,
               GeglOp *src,
               GeglColorSpace color_space)
  {
    return common_constructor(self,src,NULL, 
        color_space, GEGL_NONE);
  }


  /**
   * new2: 
   * @src: an input #GeglOp.
   * @data_type: a #GeglChannelDataType to convert to.
   *
   * Creates a new #GeglColorConvertOp which converts to @data_type.
   * 
   * Returns: a new #GeglColorConvertOp.
   **/
  public
  GeglColorConvertOp *
  new2 (GeglOp *src,
        GeglChannelDataType data_type)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor2(self, src, data_type))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }
  

  /**
   * constructor2:
   * @self: a #GeglConvertOp.
   * @src: an input #GeglOp.
   * @data_type: a #GeglChannelDataType to convert to.
   *
   * Initializes a #GeglConvertOp. 
   * 
   * Returns: TRUE if constructed successfully. 
   **/
  protected 
  gboolean 
  constructor2(self,
               GeglOp *src,
               GeglChannelDataType data_type)
  {
    return common_constructor(self,src,NULL,
        GEGL_COLOR_SPACE_NONE, data_type);
  }


  /**
   * common_constructor:
   * @self: a #GeglConvertOp.
   * @src: an input #GeglOp.
   * @color_model: a #GeglColorModel to convert to.
   * @color_space: a #GeglColorSpace to convert to.
   * @data_type: a #GeglChannelDataType to convert to.
   *
   * Initializes a #GeglConvertOp using @color_model if set, otherwise it uses
   * @color_space and @data_type 
   * 
   * Returns: TRUE if constructed successfully. 
   **/
  private 
  gboolean 
  common_constructor(self,
                     GeglOp *src,
                     GeglColorModel *color_model,
                     GeglColorSpace color_space,
                     GeglChannelDataType data_type)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    {
      gint i;
      GeglImage *self_image = GEGL_IMAGE(self); 

      /* Will set the convert_func in prepare */ 
      self->_priv->convert_func = NULL;

      if (color_model)
        {
          /* Set the color model in this case, we know what it is already.*/ 
          gegl_image_set_color_model(self_image,color_model);

          self->_priv->color_space = gegl_color_model_color_space(color_model);
          self->_priv->data_type = gegl_color_model_data_type(color_model);
        }
      else
        {
          /* Still dont know if it will have alpha or not */
          self->_priv->color_space = color_space;
          self->_priv->data_type = data_type;
        }

      for(i = 0; i < 4; i++)
        self->_priv->float_xyz_data[i] = NULL;
    }

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Frees xyz_data if used. 
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(object);
    free_xyz_data (self);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * compute_derived_color_model:
   * @self_image: #a GeglImage.
   * @inputs: #a GeglImage list.
   *
   * If the color model is set for this op already, just return. Otherwise
   * determine the color model from the input and the specified #GeglColorSpace
   * and #GeglChannelDataType.
   *  
   **/
  override(Gegl:Image)
  void
  compute_derived_color_model(GeglImage *self_image, 
                              GList *inputs)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(self_image);

    /* If the ColorModel is set already, just return */
    if (!gegl_image_color_model(self_image))
      {
        GeglColorModel *derived= NULL;

        GeglImage *src = GEGL_IMAGE(g_list_nth_data(inputs,0));
        GeglColorModel *src_cm = gegl_image_color_model(src);
        GeglColorSpace src_space = gegl_color_model_color_space(src_cm); 
        GeglChannelDataType src_type = gegl_color_model_data_type(src_cm); 
        gboolean src_has_alpha = gegl_color_model_has_alpha(src_cm); 

        /* Set the derived color model based on colorspace/data type of input */
        if (self->_priv->color_space != GEGL_COLOR_SPACE_NONE &&
            self->_priv->data_type == GEGL_NONE)
          derived = gegl_color_model_instance2(self->_priv->color_space,
                                               src_type,
                                               src_has_alpha);
        else if (self->_priv->data_type != GEGL_NONE &&
                 self->_priv->color_space == GEGL_COLOR_SPACE_NONE)
          derived = gegl_color_model_instance2(src_space,
                                               self->_priv->data_type,
                                               src_has_alpha);
        else
          g_warning("GeglColorConvertOp: cant derive color model");

        /* Set the derived color model. */ 
        gegl_image_set_derived_color_model (self_image,derived);
      }
  }


  /**
   * allocate_xyz_data:
   * @self: a #GeglConvertOp.
   * @width: scanline width.
   *
   * Allocate a scanline of xyz data.
   *  
   **/
  private
  void
  allocate_xyz_data (self,
      		     gint width)
  {
    gint i;
    for(i = 0; i < 4; i++)
      self->_priv->float_xyz_data[i] = 
    g_malloc (sizeof(gfloat) * width); 
  }


  /**
   * free_xyz_data:
   * @self: a #GeglConvertOp.
   *
   * Free the scanline of xyz data.
   *  
   **/
  private
  void
  free_xyz_data (self)
  {
    gint i;
    for(i = 0; i < 4; i++)
      {
        if (self->_priv->float_xyz_data[i]) 
            g_free (self->_priv->float_xyz_data[i]);

        self->_priv->float_xyz_data[i] = NULL; 
      }	
  }

  
  /**
   * prepare:
   * @self_op:
   * @requests: #GegOpRequest list
   *
   * Prepare for image processing. Try to find a converter from the input color
   * model to the output color model. If there isnt one, convert to the desired
   * color model using XYZ conversion.
   *
   **/
  override (Gegl:Op) 
  void
  prepare(GeglOp *self_op,
          GList *requests)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP(self_op);
    GeglPointOpClass *self_point_op_class =
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_op)->klass);
    GeglOpRequest *dest_request =
      (GeglOpRequest*)g_list_nth_data(requests,0); 
    GeglColorModel * dest_cm =
      gegl_tile_get_color_model (dest_request->tile);
    GeglOpRequest *src_request =
      (GeglOpRequest*)g_list_nth_data(requests,1);
    GeglColorModel * src_cm =
      gegl_tile_get_color_model (src_request->tile);

    g_return_if_fail(dest_cm);
    g_return_if_fail(src_cm);

      {
        /* Get the name of the interface that converts from src cm */
        gchar *converter_name =
            gegl_color_model_get_convert_interface_name (src_cm);

        /* Check to see if the dest cm implements the converter */
        self->_priv->convert_func =
          (ConvertFunc)gegl_object_query_interface (GEGL_OBJECT(dest_cm),
                                                    converter_name);

        g_free (converter_name);

        if (!self->_priv->convert_func)
          {
            /* Allocate scanlines for the XYZ data */
            free_xyz_data (self);
            allocate_xyz_data (self, dest_request->rect.w);
          }

        /* Set the scanline version of this class to be called */
        self_point_op_class->scanline_func = scanline;
      }
  } 


  /**
   * scanline:
   * @self_point_op: a #GeglPointOp.
   * @iters: a #GeglTileIterator array. 
   * @width: width of scanline.
   *
   * Process a scanline.
   *
   **/
  private 
  void
  scanline(GeglPointOp *self_point_op,
           GeglTileIterator **iters, 
           gint width)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP (self_point_op);
    GeglColorModel *dest_cm = gegl_tile_iterator_get_color_model(iters[0]);
    GeglColorModel *src_cm = gegl_tile_iterator_get_color_model(iters[1]);
    guint dest_nchans = gegl_color_model_num_channels (dest_cm);
    guint src_nchans = gegl_color_model_num_channels (src_cm);
    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_nchans);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_nchans);

    gegl_tile_iterator_get_current(iters[0], (gpointer*)dest_data);
    gegl_tile_iterator_get_current(iters[1], (gpointer*)src_data);

    /* Call the converter if installed, else do XYZ conversion */ 
       
    if (self->_priv->convert_func)
        (self->_priv->convert_func) (dest_cm, src_cm, 
                                     dest_data, src_data, 
                                     width); 
    else
      {
        gegl_color_model_convert_to_xyz (src_cm, 
           self->_priv->float_xyz_data, src_data, width);

        gegl_color_model_convert_from_xyz (dest_cm, 
           dest_data, self->_priv->float_xyz_data , width);
      }

    g_free (dest_data);
    g_free (src_data);
  }
}
