%h{
#include "gegl-single-src-op.h"
%}
%{
#include "gegl-color-convert-op.h"
#include "gegl-color-convert-op-private.h"
#include "gegl-single-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}


class Gegl:Color:Convert:Op from Gegl:Single:Src:Op {

  private gfloat *float_xyz_data[4];
  private gint scanline_width; 

  public 
  GeglColorConvertOp *
  new (GeglImage *src)
  {
    GeglColorConvertOp * self = 
       GEGL_COLOR_CONVERT_OP (GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImage *src) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_single_src_op_constructor (
          GEGL_SINGLE_SRC_OP(self), src))
      return FALSE;

    {
      gint i;
      for(i = 0; i < 4; i++)
	self->_priv->float_xyz_data[i] = NULL;
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    free_xyz_data (GEGL_COLOR_CONVERT_OP(object));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  allocate_xyz_data (self)
  {
    gint i;
    for(i = 0; i < 4; i++)
      self->_priv->float_xyz_data[i] = 
	g_malloc (sizeof(float) * self->_priv->scanline_width); 
  }

  private
  void
  free_xyz_data (self)
  {
    gint i;
    for(i = 0; i < 4; i++)
      {
	if (self->_priv->float_xyz_data[i]) 
	  g_free (self->_priv->float_xyz_data[i]);

        self->_priv->float_xyz_data[i] = NULL; 
      }	
  }

  virtual
  void
  install_converter (self, 
                     GeglImage *dest)
  {
    /* Default converter for CIE_XYZ is already installed */

    /* Subclasses will install their converter if they can find one */

    /* Allocate a scanline to hold intermediate XYZ float data */
    free_xyz_data (self);
    allocate_xyz_data (self); 
  }

  virtual 
  protected
  void
  converter (self,
	     GeglColorModel *src_cm, 
	     GeglColorModel *dest_cm, 
	     guchar **src_data,
	     guchar **dest_data,
	     gint width)
  {
    gegl_color_model_convert_to_xyz (src_cm, 
	self->_priv->float_xyz_data, src_data, width);
    gegl_color_model_convert_from_xyz (dest_cm, 
	dest_data, self->_priv->float_xyz_data , width);
  }

  override (Gegl:Op) 
  void
  prepare(GeglOp *op,
          GeglImage *dest,
	  GeglRect *dest_rect)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP (op);
    GeglPointOp *point_op = GEGL_POINT_OP (op);
    GeglPointOpClass *point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);

    /* Save the width */
    self->_priv->scanline_width = dest_rect->w;

    /* Set the scanline version of this class to be called */
    point_op_class->scanline_func = gegl_color_convert_op_scanline;

    /* Let subclass install its converter, or use default */
    install_converter (self,dest);
  } 

  private 
  void
  scanline(GeglPointOp *point_op,
           GeglImageIterator *dest_iter, 
           GeglImageIterator **src_iters)
  {
    GeglColorConvertOp *self = GEGL_COLOR_CONVERT_OP (point_op);
    GeglImageBuffer * dest_image_buffer = 
      gegl_image_iterator_get_image_buffer(dest_iter);
    GeglImageBuffer * src_image_buffer =
      gegl_image_iterator_get_image_buffer(src_iters[0]);
    GeglColorModel * dest_cm = 
      gegl_image_color_model(GEGL_IMAGE(dest_image_buffer));
    GeglColorModel * src_cm = 
      gegl_image_color_model(GEGL_IMAGE(src_image_buffer));
    guint dest_num_channels = 
      gegl_color_model_num_channels (dest_cm);
    guint src_num_channels = 
      gegl_color_model_num_channels (src_cm);
    guint width = gegl_image_iterator_scanline_width (dest_iter);

    guchar ** dest_data = g_malloc (sizeof(guchar*) * dest_num_channels);
    guchar ** src_data = g_malloc (sizeof(guchar*) * src_num_channels);

    gegl_image_iterator_get_scanline_data (
	dest_iter, dest_data);
    gegl_image_iterator_get_scanline_data (
	src_iters[0], src_data);

    /* Calls the subclass converter if installed, 
       otherwise defaults to the converter in this class */
    converter (self,src_cm,dest_cm,src_data,dest_data,width); 

    g_free (dest_data);
    g_free (src_data);
  }
}
