%h{
#include "gegl-object.h"

#ifndef __TYPEDEF_GEGL_TILE__
#define __TYPEDEF_GEGL_TILE__
typedef struct _GeglTile GeglTile;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__ 
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-tile-iterator.h"
#include "gegl-tile-iterator-private.h"
#include "gegl-object-private.h"
#include "gegl-tile.h"
#include "gegl-utils.h"
%}

class Gegl:Tile:Iterator from Gegl:Object {

  private GeglTile *tile;           /* The tile we iterate over */
  private GeglRect rect;            /* The subportion of tile we want - in image coords */
  private gint current;             /* The current index in [0,rect.height-1] */

  /**
   * new: 
   * @tile: #GeglTile to use.
   * @rect: subportion of the #GeglTile to iterate over.
   * 
   * Creates a new #GeglTileIterator.
   *
   * Returns: a new #GeglTileIterator.
   **/ 
  public
  GeglTileIterator *
  new(GeglTile *tile,
      GeglRect *rect)
  {
    GeglTileIterator * self = GEGL_TILE_ITERATOR(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, tile, rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglTileIterator.
   * @tile: the #GeglTile to use.
   * @rect: subportion of the #GeglTile to iterate over.
   * 
   * Initializes a #GeglTileIterator.
   *
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor (self, 
               GeglTile *tile,
	           GeglRect *rect)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    {
      self->_priv->current = 0;
      gegl_rect_copy(&self->_priv->rect, rect);
      self->_priv->tile = tile;

      /* Ref the tile */
      gegl_object_ref(GEGL_OBJECT(tile));

    }
    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Free memory allocated by this object. Unref the #GeglTile.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglTileIterator *self = GEGL_TILE_ITERATOR (object);

    /* Unref the tile */
    gegl_object_unref(GEGL_OBJECT(self->_priv->tile));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * get_tile:
   * @self: a #GeglTileIterator
   *
   * Gets the #GeglTile this iterator uses.
   * 
   * Returns: a #GeglTile this iterator uses. 
   **/ 
  public
  GeglTile *
  get_tile(self)
  {
    return self->_priv->tile;
  }


  /**
   * get_color_model:
   * @self: a #GeglTileIterator.
   *
   * Gets the color model of the tile.
   * 
   * Returns: the #GeglColorModel of the tile. 
   **/
  public
  GeglColorModel *
  get_color_model(self)
  {
    return gegl_tile_get_color_model(self->_priv->tile);
  }


  /**
   * first:
   * @self: a #GeglTileIterator.
   * 
   * Makes the iterator point to the first scanline.
   *
   **/ 
  public
  void
  first(self)
  {
    self->_priv->current = 0;
  }


  /**
   * next:
   * @self: a #GeglTileIterator.
   * 
   * Makes iterator point to the next scanline. 
   *
   **/ 
  public
  void 
  next(self)
  {
    self->_priv->current++;
  }


  /**
   * is_done:
   * @self: a #GeglTileIterator.
   * 
   * Checks if there are more scanlines. 
   * 
   * Returns: TRUE if there are more scanlines.
   **/ 
  public
  gboolean 
  is_done(self)
  {
    if (self->_priv->current < self->_priv->rect.h) 
      return FALSE;
    else
      return TRUE;
  }
  

  /**
   * get_current:
   * @self: a #GeglTileIterator.
   * @data_pointers: array of data pointers.
   * 
   * Makes @data_pointers point to the current scanline data. 
   *
   **/ 
  public
  void 
  get_current (self,
               gpointer* data_pointers) 
  {
    /* Just pass the data pointers through to the tile data*/
    gegl_tile_get_data_at(self->_priv->tile, 
                          data_pointers, 
                          self->_priv->rect.x, 
                          self->_priv->rect.y + self->_priv->current);  

  }
}
