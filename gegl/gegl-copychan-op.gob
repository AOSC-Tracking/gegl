%h{
#include "gegl-point-op.h"
#define GEGL_COPY_CHAN_OP_CHANNEL_NONE -1
%}
%{
#include "gegl-copychan-op.h"
#include "gegl-copychan-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:CopyChan:Op from Gegl:Point:Op {

  private gint *copychan_index;
  private gint num;

  public 
  GeglCopyChanOp *
  new (gint *copychan_index, 
       gint num)
  {
    GeglCopyChanOp * self = GEGL_COPYCHAN_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor (self, copychan_index, num))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gtk_object_ref(GTK_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              gint *copychan_index,
              gint num)
  {
    int i;

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (GEGL_POINT_OP(self), NULL))
      return FALSE;

    {
      GeglPointOp *point_op = GEGL_POINT_OP (self);
      GeglPointOpClass *point_op_class = 
	  GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);

      point_op_class->scanline_func = gegl_copychan_op_COLORSPACE_DATATYPE;

    }

    self->_priv->copychan_index = (gint*) g_malloc (sizeof(gint) *num);
    self->_priv->num = num;
    
    for (i=0; i<num; i++)
      self->_priv->copychan_index[i] = copychan_index[i]; 

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglCopyChanOp * self = GEGL_COPYCHAN_OP(object);
    g_free(self->_priv->copychan_index);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private
  void
  COLORSPACE_DATATYPE (GeglPointOp *point_op,
                       GeglImageIterator *dest_iter, 
                       GeglImageIterator **src_iters)
  {
    gint i, j, k=0; 
    gchar *dest_data[4], *dest_indexed[4];
    GeglCopyChanOp *self = GEGL_COPYCHAN_OP (point_op);
    GeglImage *dest = gegl_image_iterator_get_image(dest_iter);
    GeglColorModel *dest_cm = gegl_image_color_model (dest);
    guint width = gegl_image_iterator_scanline_width (dest_iter);

    gint bpc = gegl_color_model_bytes_per_channel (dest_cm);
    gint dest_nchans = gegl_color_model_num_channels (dest_cm); 
    gint *index = self->_priv->copychan_index;
  
    gegl_image_iterator_get_scanline_data (dest_iter,
                (guchar**)dest_data);

    for (i = 0; i<dest_nchans; i++)
      { 
        if (index[i] != GEGL_COPY_CHAN_OP_CHANNEL_NONE)
          dest_indexed[i] = dest_data[index[i]];  
        else 
          dest_indexed[i] = NULL;  
      }

    /* CopyChan the dest with the copychan color */
    while (width--)
      {
        for (i = 0; i < dest_nchans; i++)
          {
            if (index[i] != GEGL_COPY_CHAN_OP_CHANNEL_NONE)
              for (j = 0; j < bpc; j++); 
              { 
                dest_data[i][k]  = dest_indexed[i][k];  
                k++; 
              }
          }
      }
  }
}
