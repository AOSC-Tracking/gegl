%h{
#include "gegl-point-op.h"
#include "gegl-image-buffer.h"
%}
%{
#include <stdio.h>
#include "gegl-print-op.h"
#include "gegl-print-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-utils.h"
%}

class Gegl:Print:Op from Gegl:Point:Op {

  public 
  GeglPrintOp *
  new (GeglImageBuffer *dest, 
       GeglRect *dest_rect
       )
  {
    GeglPrintOp * self = GEGL_PRINT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, dest_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest, 
              GeglRect *dest_rect)
  {
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (
          GEGL_POINT_OP(self), 
          &dest, dest_rect, 1))
      return FALSE;

    /*
      Now based on the image buffer color model(s)/data storage
      choose one of our scanline funcs to install
      This is where some "autogeneration" happens.
    */ 

   {
      GeglColorModel *cm;
      GeglChannelDataType data_type;
      cm = gegl_image_buffer_color_model (dest);
      data_type = gegl_color_model_data_type (cm);

      switch (data_type)
      {
        case FLOAT:
          point_op_class->scanline_func = gegl_print_op_RGB_FLOAT; 	
          break;
        case U8:
          point_op_class->scanline_func = gegl_print_op_RGB_U8;
          break;
        default:
          g_warning("PrintOp: Color Model data type none or unknown\n");
          point_op_class->scanline_func = NULL; 	
          return FALSE;
      }
    }

    return TRUE;
  }

  private 
  void
  RGB_FLOAT (GeglPointOp *point_op)
  {
     /*
        Whats the algorithm for this code?	
        PRINT DEST 

     */

    guint width;
    gfloat * channels[3]; 
    gfloat *r, *g, *b;
	
    GeglPointOpPrivate *point_opP = 
      (GeglPointOpPrivate *)(point_op->_priv); 
    GeglOpPrivate *opP = 
      (GeglOpPrivate *)(GEGL_OP(point_op)->_priv); 

    width = point_opP->scanline_width;

    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (opP->image_buffers[0], 
       (guchar**)channels);

    /* Make r,g,b point to the dest image data */

    r = channels[0];
    g = channels[1];
    b = channels[2];

    while (width--)
      printf("(%.2f %0.2f %0.2f) "  , *r++, *g++, *b++);

    printf("\n");
  }

  private
  void
  RGB_U8 (GeglPointOp *point_op)
  {
     /*
        Whats the algorithm for this code?
        PRINT DEST

     */

    guint width;
    guint8 *channels[3];
    guint8 *r, *g, *b;

    GeglPointOpPrivate *point_opP =
        (GeglPointOpPrivate *)(point_op->_priv);
    GeglOpPrivate *opP =
        (GeglOpPrivate *)(GEGL_OP(point_op)->_priv);

    width = point_opP->scanline_width;

    /* image_buffers[0] is the dest here */
    gegl_image_buffer_get_scanline_data (opP->image_buffers[0],
                                        (guchar**)channels);

    /* Make r,g,b point to the dest image data */

    r = channels[0];
    g = channels[1];
    b = channels[2];

    while (width--)
      printf("(%d %d %d) "  , *r++, *g++, *b++);

    printf("\n");
  }

}
