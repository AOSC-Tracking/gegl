%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-diff-op.h"
#include "gegl-diff-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Diff:Op from Gegl:Dual:Src:Op {

  public 
  GeglDiffOp *
  new (GeglImage *src1,
       GeglImage *src2)       
  {
    GeglDiffOp * self = GEGL_DIFF_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, src1, src2))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImage *src1,
              GeglImage *src2)
  {
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_dual_src_op_constructor (
	  GEGL_DUAL_SRC_OP(self),src1, src2))
      return FALSE;

    return TRUE;
  }

  override(Gegl:Op)
  void
  prepare(GeglOp *self_op,
          GeglImage *dest,
          GeglRect *dest_rect)
  {
    GeglPointOp *self_point_op = GEGL_POINT_OP (self_op);
    GeglPointOpClass *self_point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_point_op)->klass);

    /* Save the alphas so we can get them quickly in 
       in the scanline func */
    gegl_op_save_alphas(self_op);

    /* Now make sure the correct scanline func is installed */
    self_point_op_class->scanline_func = 
      gegl_diff_op_scanline_COLORSPACE_DATATYPE;        
  } 

  private 
  void
  scanline_COLORSPACE_DATATYPE (GeglPointOp *self_point_op,
                                GeglImageIterator *dest_iter, 
                                GeglImageIterator **src_iters)
  {
    GeglOp *self_op = GEGL_OP(self_point_op);
    guint width = gegl_image_iterator_scanline_width (dest_iter);

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha,has_alpha);
    Pixel src1(color,alpha,has_alpha);
    Pixel src2(color,alpha,has_alpha);
    GENERIC_IMAGE_DECL_END 

    dest_has_alpha = self_op->has_alpha; 
    src1_has_alpha = self_op->input_has_alpha[0]; 
    src2_has_alpha = self_op->input_has_alpha[1]; 

    gegl_image_iterator_get_scanline_data (
	dest_iter, (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data (
	src_iters[0], (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data (
	src_iters[1], (guchar**)src2_data);
    
    GENERIC_IMAGE_IMAGE_DATA_INIT
      
    while (width--)
      {
        GENERIC_IMAGE_CODE_BEGIN  

        dest_color = ABS(src1_color - src2_color);

        if (dest_has_alpha)
          {
            if (src1_has_alpha && src2_has_alpha)
              {
                dest_alpha = MIN(src1_alpha, src2_alpha);
              }
            else if (src1_has_alpha)
              {
                dest_alpha = src1_alpha;
              }
            else if (src2_has_alpha)
              {
                dest_alpha = src2_alpha;
              }
          }

        dX(dest,1);
        dX(src1,1);
        dX(src2,1);

        GENERIC_IMAGE_CODE_END
      }               
  }
}
