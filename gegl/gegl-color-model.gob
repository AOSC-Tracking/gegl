%h{
#include "gegl-object.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
typedef void (*ConvertFunc)(GeglColorModel *, 
                    GeglColorModel *, 
                    guchar **,
                    guchar **,
                    gint);
%}
%{
#include "gegl-color-model.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
#include "gegl-object-private.h"
%}

class Gegl:Color:Model from Gegl:Object {

  private GeglColorSpace  colorspace;       /*RGB, GRAY, CMYK, etc*/
  private GeglChannelDataType data_type;    /*FLOAT, U8, U16, etc*/

  private gint       bytes_per_channel;
  private gint       bytes_per_pixel;  
  private gint       num_channels;     /* total number of channels */
  private gint       num_colors;       /* number of color channels */
  private gboolean   has_alpha;        /* is there an alpha   */ 
  private gint       alpha_channel;    /* alpha channel index */
  private gboolean   is_premultiplied; /* model represents premultiplied*/

  private gboolean   is_additive;      /* bigger is brighter  */
  private gboolean   is_subtractive;   /* bigger is darker    */
  private guint      ID;               /* a unique id */

  private const char**channel_names;   /* name of each channel */
  private const char *color_space_name;/* name of this color space */
  private const char *alpha_string;    /* "Alpha" or "\0"          */
  private const char *channel_data_type_name;  /*name of channel data type*/

  protected 
  gboolean 
  constructor(self, gboolean has_alpha)
  {
    if (GEGL_OBJECT(self)->constructed) 
       return FALSE;
    
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
       return FALSE;
       
    self->_priv->colorspace = COLORSPACE_NONE;
    self->_priv->data_type = DATATYPE_NONE;
    self->_priv->bytes_per_channel = -1;
    self->_priv->bytes_per_pixel = -1; 
    self->_priv->num_channels = -1; 
    self->_priv->num_colors = -1;
    self->_priv->has_alpha = has_alpha;
    self->_priv->alpha_channel = -1;
    self->_priv->is_premultiplied = FALSE; 

    self->_priv->is_additive = FALSE;
    self->_priv->is_subtractive = FALSE;

    self->_priv->channel_names = NULL;
    self->_priv->color_space_name = NULL;
    self->_priv->alpha_string = NULL;
    self->_priv->channel_data_type_name = NULL;
    self->_priv->ID = -1;

    return TRUE;
  }

  public 
  GeglColorSpace 
  color_space(self) 
  { return self->_priv->colorspace; } 

  public
  GeglChannelDataType       
  data_type(self) 
  { return self->_priv->data_type; }

  public
  gint       
  bytes_per_channel(self) 
  { return self->_priv->bytes_per_channel; }

  public
  gint       
  bytes_per_pixel(self) 
  { return self->_priv->bytes_per_pixel; }

  public
  gint       
  num_channels(self) 
  { return self->_priv->num_channels; }

  public
  gint       
  num_colors(self) 
  { return self->_priv->num_colors; }

  public 
  gboolean       
  has_alpha(self) 
  { return self->_priv->has_alpha; }

  public 
  gint       
  alpha_channel(self) 
  { return self->_priv->alpha_channel; }

  public 
  gboolean        
  is_premultiplied(self) 
  { return self->_priv->is_premultiplied; }

  public 
  void
  set_is_premultiplied(self, 
                       gboolean is_premultiplied) 
  { self->_priv->is_premultiplied = is_premultiplied ; }

  virtual 
  void 
  set_color (self, 
             GeglColor *c, 
             GeglColorConstant constant);

  virtual
  void
  convert_to_xyz (self, 
                  gfloat **dest_data, 
		  guchar **src_data, 
		  gint width);

  virtual
  void
  convert_from_xyz (self, 
                    guchar **dest_data, 
		    gfloat **src_data, 
		    gint width);
  virtual 
  gchar * 
  get_converter_interface_name (self); 
}
