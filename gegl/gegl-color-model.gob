%h{
#include "gegl-object.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
typedef void (*ConvertFunc)(GeglColorModel *,
                    GeglColorModel *,
                    guchar **,
                    guchar **,
                    gint);
%}
%{
#include "gegl-color-model.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
#include "gegl-object-private.h"
%}

class Gegl:Color:Model from Gegl:Object {

  protected GeglColorSpace  colorspace;       /* RGB, GRAY, CMYK, etc*/
  protected GeglChannelDataType data_type;    /* FLOAT, U8, U16, etc*/

  protected gint       bytes_per_channel;
  protected gint       bytes_per_pixel;  
  protected gint       num_channels;     /* total number of channels */
  protected gint       num_colors;       /* number of color channels */
  protected gboolean   has_alpha;        /* is there an alpha   */ 
  protected gint       alpha_channel;    /* alpha channel index */
  protected gboolean   is_premultiplied; /* model represents premultiplied*/

  protected gboolean   is_additive;      /* bigger is brighter  */
  protected gboolean   is_subtractive;   /* bigger is darker    */

  protected const char**channel_names;   /* name of each channel */
  protected const char *color_space_name;/* name of this color space */
  protected const char *alpha_string;    /* "Alpha" or "\0"          */
  protected const char *channel_data_type_name;  /*name of channel data type*/


  /**
   * constructor: 
   * @self: a #GeglColorModel
   * @has_alpha: TRUE if the color model has an alpha channel.  
   *
   * Initializes a #GeglColorModel.
   * 
   * Returns: TRUE if constructed successfully.
   **/
  protected 
  gboolean 
  constructor(self, 
              gboolean has_alpha)
  {
    if (GEGL_OBJECT(self)->constructed) 
       return FALSE;
    
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
       return FALSE;
       
    self->colorspace = GEGL_COLOR_SPACE_NONE;
    self->data_type = GEGL_NONE;
    self->bytes_per_channel = 0;
    self->bytes_per_pixel = 0; 
    self->num_channels = 0; 
    self->num_colors = 0;
    self->has_alpha = has_alpha;
    self->alpha_channel = 0;

    self->is_additive = FALSE;
    self->is_subtractive = FALSE;

    self->channel_names = NULL;
    self->color_space_name = NULL;
    self->alpha_string = NULL;
    self->channel_data_type_name = NULL;

    return TRUE;
  }


  /**
   * color_space:
   * @self: a #GeglColorModel
   * 
   * Gets the color space of the color model. (eg RGB, GRAY)
   *
   * Returns: the #GeglColorSpace of this color model.
   **/
  public 
  GeglColorSpace 
  color_space(self) 
  { 
    return self->colorspace; 
  } 


  /**
   * data_type: 
   * @self: a #GeglColorModel
   * 
   * Gets the channel data type of the color model. (eg U8, U16, FLOAT)
   *
   * Returns: #GeglChannelDataType of the color model.  
   **/
  public
  GeglChannelDataType       
  data_type(self) 
  { 
    return self->data_type; 
  }


  /**
   * bytes_per_channel: 
   * @self: a #GeglColorModel
   * 
   * Gets the bytes per channel of the color model. 
   *
   * Returns: number of bytes per channel. 
   **/
  public
  gint       
  bytes_per_channel(self) 
  { 
    return self->bytes_per_channel; 
  }


  /**
   * bytes_per_pixel: 
   * @self: a #GeglColorModel
   * 
   * Gets the bytes per pixel of the color model. 
   *
   * Returns: number of bytes per pixel. 
   **/
  public
  gint       
  bytes_per_pixel(self) 
  { 
    return self->bytes_per_pixel; 
  }


  /**
   * num_channels: 
   * @self: a #GeglColorModel
   * 
   * Gets the number of channels of the color model. 
   *
   * Returns: number of channels. 
   **/
  public
  gint       
  num_channels(self) 
  { 
    return self->num_channels; 
  }


  /**
   * num_colors: 
   * @self: a #GeglColorModel
   * 
   * Gets the number of color channels of the color model. 
   *
   * Returns: number of color channels. 
   **/
  public
  gint       
  num_colors(self) 
  { 
    return self->num_colors; 
  }


  /**
   * has_alpha: 
   * @self: a #GeglColorModel
   * 
   * Gets whether this color model has an alpha channel. 
   *
   * Returns: TRUE if color model has an alpha channel. 
   **/
  public 
  gboolean       
  has_alpha(self) 
  { 
    return self->has_alpha; 
  }


  /**
   * alpha_channel: 
   * @self: a #GeglColorModel
   * 
   * Gets the alpha channel index.
   *
   * Returns: Alpha channel index. 
   **/
  public 
  gint       
  alpha_channel(self) 
  { 
    return self->alpha_channel; 
  }


  /**
   * color_alpha_space: 
   * @self: a #GeglColorModel
   *
   * Gets the #GeglColorAlphaSpace of the color model.(eg RGB, RGBA, GRAY,
   * GRAYA).
   *
   * Returns: The #GeglColorAlphaSpace of this color model.
   **/
  virtual
  GeglColorAlphaSpace
  color_alpha_space (self);


  /**
   * color_model_type: 
   * @self: a #GeglColorModel
   *
   * Gets the #GeglColorModelType. (roughly #GeglColorAlphaSpace plus
   * #GeglChannelDataType)  
   * 
   * Returns: The #GeglColorModelType of this color model.
   **/
  virtual
  GeglColorModelType
  color_model_type (self);


  /**
   * set_color: 
   * @self: a #GeglColorModel
   * @color: a Color to set.
   * @constant: The #GeglColorConstant to use.
   *
   * Set @color to the @constant (eg white, black, green, red, etc) based on
   * the context of this color model.   
   *
   **/
  virtual
  void
  set_color (self,
             GeglColor *color,
             GeglColorConstant constant);


  /**
   * convert_to_xyz: 
   * @self: a #GeglColorModel
   * @dest_data: pointers to dest float xyz data.
   * @src_data: pointers to src data to convert from.
   * @width: number of pixels to process.
   *
   * Converts from this color model to XYZ. Every color model must implement
   * this.
   *
   **/
  virtual
  void
  convert_to_xyz (self,
                  gfloat **dest_data,
                  guchar **src_data,
                  gint width);


  /**
   * convert_from_xyz: 
   * @self: a #GeglColorModel
   * @dest_data: pointers to the dest to convert to.
   * @src_data: pointers to the src float xyz data.
   * @width: number of pixels to process.
   *
   * Converts from XYZ to this color model. Every color model must implement
   * this.
   *
   **/
  virtual
  void
  convert_from_xyz (self,
                    guchar **dest_data,
                    gfloat **src_data,
                    gint width);


  /**
   * get_convert_interface_name: 
   * @self: a #GeglColorModel
   *
   * Gets a the name of the converter interface that converts to data
   * of this color model.  
   *
   * Returns: a string that is the name of the converter interface. 
   **/
  virtual
  gchar *
  get_convert_interface_name (self); 

}
