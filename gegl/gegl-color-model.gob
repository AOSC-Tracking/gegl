%h{
#include "gegl-object.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
typedef void (*ConvertFunc)(GeglColorModel *, 
                    GeglColorModel *, 
                    guchar **,
                    guchar **,
                    gint);
%}
%{
#include "gegl-color-model.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
#include "gegl-object-private.h"
%}

class Gegl:Color:Model from Gegl:Object {

  protected GeglColorSpace  colorspace;       /* RGB, GRAY, CMYK, etc*/
  protected GeglChannelDataType data_type;    /* FLOAT, U8, U16, etc*/

  protected gint       bytes_per_channel;
  protected gint       bytes_per_pixel;  
  protected gint       num_channels;     /* total number of channels */
  protected gint       num_colors;       /* number of color channels */
  protected gboolean   has_alpha;        /* is there an alpha   */ 
  protected gint       alpha_channel;    /* alpha channel index */
  protected gboolean   is_premultiplied; /* model represents premultiplied*/

  protected gboolean   is_additive;      /* bigger is brighter  */
  protected gboolean   is_subtractive;   /* bigger is darker    */

  protected const char**channel_names;   /* name of each channel */
  protected const char *color_space_name;/* name of this color space */
  protected const char *alpha_string;    /* "Alpha" or "\0"          */
  protected const char *channel_data_type_name;  /*name of channel data type*/

  protected 
  gboolean 
  constructor(self, gboolean has_alpha)
  {
    if (GEGL_OBJECT(self)->constructed) 
       return FALSE;
    
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
       return FALSE;
       
    self->colorspace = GEGL_COLOR_SPACE_NONE;
    self->data_type = GEGL_NONE;
    self->bytes_per_channel = -1;
    self->bytes_per_pixel = -1; 
    self->num_channels = -1; 
    self->num_colors = -1;
    self->has_alpha = has_alpha;
    self->alpha_channel = -1;
    self->is_premultiplied = FALSE; 

    self->is_additive = FALSE;
    self->is_subtractive = FALSE;

    self->channel_names = NULL;
    self->color_space_name = NULL;
    self->alpha_string = NULL;
    self->channel_data_type_name = NULL;

    return TRUE;
  }

  public 
  GeglColorSpace 
  color_space(self) 
  { return self->colorspace; } 

  public
  GeglChannelDataType       
  data_type(self) 
  { return self->data_type; }

  public
  gint       
  bytes_per_channel(self) 
  { return self->bytes_per_channel; }

  public
  gint       
  bytes_per_pixel(self) 
  { return self->bytes_per_pixel; }

  public
  gint       
  num_channels(self) 
  { return self->num_channels; }

  public
  gint       
  num_colors(self) 
  { return self->num_colors; }

  public 
  gboolean       
  has_alpha(self) 
  { return self->has_alpha; }

  public 
  gint       
  alpha_channel(self) 
  { return self->alpha_channel; }

  public 
  gboolean        
  is_premultiplied(self)
  { return self->is_premultiplied; }

  public 
  void
  set_is_premultiplied(self, 
                       gboolean is_premultiplied)
  { self->is_premultiplied = is_premultiplied ; }

  virtual
  GeglColorAlphaSpace
  color_alpha_space (self);

  virtual
  GeglColorModelType
  color_model_type (self);

  virtual
  void
  set_color (self,
             GeglColor *c,
             GeglColorConstant constant);

  virtual
  void
  convert_to_xyz (self,
                  gfloat **dest_data,
		  guchar **src_data,
		  gint width);

  virtual
  void
  convert_from_xyz (self,
                    guchar **dest_data,
		    gfloat **src_data,
		    gint width);
  virtual
  gchar *
  get_converter_interface_name (self); 
}
