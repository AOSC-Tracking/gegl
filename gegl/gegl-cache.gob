%h{
#include "gegl-object.h"

#ifndef __TYPEDEF_GEGL_IMAGE__
#define __TYPEDEF_GEGL_IMAGE__
typedef struct _GeglImage  GeglImage;
#endif

#ifndef __TYPEDEF_GEGL_TILE__
#define __TYPEDEF_GEGL_TILE__
typedef struct _GeglTile  GeglTile;
#endif

#ifndef __TYPEDEF_GEGL_TILE_KEY__
#define __TYPEDEF_GEGL_TILE_KEY__
typedef struct _GeglTileKey  GeglTileKey;
#endif

%}
%{
#include "gegl-cache.h"
#include "gegl-cache-private.h"
#include "gegl-object-private.h"
#include "gegl-tile.h"
#include "gegl-tile-image-manager.h"
#include "gegl-color-model.h"
#include "gegl-image.h"
#include <stdio.h>
%}

class Gegl:Cache from Gegl:Object {

  private GHashTable  *hash;

  /**
   * new: 
   *
   * Creates a new #GeglCache.
   * 
   * Returns: a new #GeglCache.
   **/ 
  public
  GeglCache*
  new(void)
  {
    GeglCache * self = GEGL_CACHE(GET_NEW);

    /*Call the constructor */
    if (!constructor(self))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }


  /**
   * constructor:
   * @self: a #GeglCache
   *
   * Initializes a #GeglCache.
   * 
   * Returns: TRUE if constructed successfully.
   **/ 
  protected 
  gboolean 
  constructor(self)
  {
    g_return_val_if_fail (!(GEGL_OBJECT(self)->constructed), FALSE);
       
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    self->_priv->hash = g_hash_table_new(key_hash_func, compare_key);

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   * 
   * Free memory allocated by this object. The hash table is freed.
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglCache *self = GEGL_CACHE(object);
    g_return_if_fail (object != NULL);

    /* Free the hash table */
    g_hash_table_destroy(self->_priv->hash);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * print:
   * @self: a #GeglCache
   * 
   * Print out the entire hash table.
   *
   **/ 
  public
  void
  print(self)
  {
    g_print("cache hash table entries: \n");
    g_hash_table_foreach(self->_priv->hash, print_entry,NULL);
  }


  /**
   * print_entry:
   * @key:  a #GeglTileKey.
   * @value: a #GeglTile.
   * @user_data: not used.
   * 
   * Print out an entry in the hash table.
   *
   **/ 
  private
  void
  print_entry(gpointer key,
              gpointer value,
              gpointer user_data)
  {
    GeglTileKey *k = (GeglTileKey*)key;
    g_print("key: %x  tile: %x\n", (guint)(k->image), (guint)value);
  }


  /**
   * lookup_tile:
   * @self: a #GeglCache
   * @key: a #GeglTileKey.
   *
   * Look for a tile that matches @key in the cache.
   * 
   * Returns: a found #GeglTile or NULL.
   **/ 
  public
  GeglTile * 
  lookup_tile(self,
              GeglTileKey * key)
  {
    return (GeglTile*)g_hash_table_lookup(self->_priv->hash, key);
  }


  /**
   * insert_tile:
   * @self: a #GeglCache
   * @key: a #GeglTileKey.
   * @tile: a #GeglTile.
   * 
   * Insert @tile using the passed @key. Makes a duplicate of @key before
   * inserting.
   *
   **/
  public
  void
  insert_tile(self,
              GeglTileKey * key,
              GeglTile *tile)
  {
    GeglTileKey *new_key = key_dup(self,key);

    /* Ref the tile */
    /*gegl_object_ref(GEGL_OBJECT(tile));*/

    /* Put it in the table */
    g_hash_table_insert(self->_priv->hash, new_key,tile);
  }


  /**
   * remove_tile:
   * @self: a #GeglCache
   * @key: a #GeglTileKey.
   * 
   * Remove @tile from the hash using the passed @key. Frees both @tile and the
   * original #GeglTilekey if it finds them.
   *
   * Returns: The removed tile or NULL if not found.
   **/
  public
  GeglTile *
  remove_tile(self,
              GeglTileKey *key)
  {
    GeglTile * tile = NULL;
    GeglTileKey *orig_key = NULL;
    g_hash_table_lookup_extended(self->_priv->hash,
                                 key,
                                 (gpointer*)&orig_key,
                                 (gpointer*)&tile);
    if(tile)
      {
        g_hash_table_remove(self->_priv->hash,orig_key);
        g_free(orig_key);
        
        /* Unref the tile */
        /*gegl_object_unref(GEGL_OBJECT(tile));*/
      }

    return tile;
  }


  /**
   * key_dup:
   * @self: a #GeglCache
   * @key: a #GeglTileKey.
   * 
   * Duplicates the #GeglTileKey @key.
   *
   * Returns: a #GeglTileKey.
   **/
  private
  GeglTileKey*
  key_dup(self,
          GeglTileKey* key)
  {
    GeglTileKey *new_key = g_new(GeglTileKey,1);

    new_key->image = key->image;

    return new_key;
  }


  /**
   * compare_key:
   * @self: a #GeglCache
   * @a: first #GeglTileKey.
   * @b: second #GeglTileKey.
   *
   * Compares the two keys @a and @b.
   * 
   * Returns: TRUE if keys are equal.
   **/
  private
  gint
  compare_key(gconstpointer a,
              gconstpointer b)
  {
    const GeglTileKey *a_key = (GeglTileKey*)a;
    const GeglTileKey *b_key = (GeglTileKey*)b;

    if(a_key->image == b_key->image) 
      return TRUE;
    else
      return FALSE; 
  }


  /**
   * key_hash_func:
   * @key: a #GeglTileKey.
   *
   * Calculates unsigned int for @key. 
   * 
   * Returns: A GUINT for the key. 
   **/
  private
  guint
  key_hash_func(gconstpointer key)
  {
    GeglTileKey *k = (GeglTileKey*)key;
    return GPOINTER_TO_UINT(k->image);
  }

}
