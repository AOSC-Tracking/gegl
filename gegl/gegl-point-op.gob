%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_IMAGE_ITERATOR__
#define __TYPEDEF_GEGL_IMAGE_ITERATOR__
typedef struct _GeglImageIterator  GeglImageIterator;
#endif

%}
%{
#include "gegl-point-op.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-utils.h"
#include "trace.h"
%}

class Gegl:Point:Op from Gegl:Op {

  private gint unused;

  protected 
  gboolean 
  constructor(self, 
              GeglImage **sources, 
              gint num_sources)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), 
          sources, num_sources))
      return FALSE;
    
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  /* 
     This is called once all inputs are ready 
     Here is where an op would do its own custom
     iterator scheme if it wanted to. 

     This one just calls a scanline iterator for 
     the dest rect. 

  */ 

  override (Gegl:Op)
  void  
  apply(GeglOp *op,
        GeglImage *dest,
        GeglRect *dest_rect) 
  {
    GeglPointOp *point_op =  GEGL_POINT_OP(op);
    GeglPointOpClass *point_op_class = 
      GEGL_POINT_OP_CLASS (GTK_OBJECT(op)->klass);

    gint i,j;
    GeglRect * src_rects = g_new (GeglRect, op->_priv->num_sources);
    GeglImageIterator **src_iters = g_new (GeglImageIterator*, 
	                              op->_priv->num_sources);
    GeglImageIterator *dest_iter;
    gint height;

    /* Set up the source and dest iterators */
    for (i = 0; i < op->_priv->num_sources; i++)
      {
        src_iters[i] = gegl_image_iterator_new (
	                 op->_priv->input_buffers[i],
                         &(op->_priv->source_rois[i]));
      }

    dest_iter = gegl_image_iterator_new (
	          GEGL_IMAGE_BUFFER(dest), dest_rect);

    height = gegl_image_iterator_current_rect_height (dest_iter);

    /* Now iterate over the scanlines in the dest */
    for(j = 0; j < height; j++)  
      {
        /* Call the installed subclass scanline func */
        (point_op_class->scanline_func)(point_op, 
					dest_iter, 
					src_iters);
          
        /* Advance all the source iterators */
        for (i = 0; i < op->_priv->num_sources; i++)
          gegl_image_iterator_next_scanline (src_iters[i]);

        /* Advance the dest iterator */
        gegl_image_iterator_next_scanline (dest_iter);
      }

    /* Free the source and dest iterators */
    for (i = 0; i < op->_priv->num_sources; i++)
      gegl_object_destroy (GEGL_OBJECT (src_iters[i])); 

    gegl_object_destroy(GEGL_OBJECT (dest_iter));

    /* Free the arrays of iters and rects */
    g_free (src_iters);
    g_free (src_rects);
  }

  /* Subclasses install their own scanline funcs */
  virtual private void 
  scanline_func (self, 
                 GeglImageIterator *dest_iter, 
		 GeglImageIterator **src_iters);
}

