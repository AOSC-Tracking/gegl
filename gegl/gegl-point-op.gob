%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_IMAGE_ITERATOR__
#define __TYPEDEF_GEGL_IMAGE_ITERATOR__
typedef struct _GeglImageIterator  GeglImageIterator;
#endif

%}
%{
#include "gegl-point-op.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-utils.h"
%}

class Gegl:Point:Op from Gegl:Op {

  private gint scanline_width;             /*width of scanline*/
  private GeglImageIterator **iterators;   /*image iterators point ops need*/
  
  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer **image_buffers, 
              GeglRect *rects, 
              gint num_images)
  {
    GeglOp *op = GEGL_OP (self);
    GeglOpClass *op_class = GEGL_OP_CLASS(GTK_OBJECT(op)->klass);

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), 
          image_buffers, rects, num_images))
      return FALSE;
   
    {
      gint i;
      self->_priv->iterators = NULL;
      self->_priv->scanline_width = 0;
 
      /* Get the iterator array */
      self->_priv->iterators = g_new(GeglImageIterator*,num_images);

      /* Make them NULL to start with */
      for (i = 0; i < num_images; i++)
       self->_priv->iterators[i] = NULL; 

      /* Now get a new iterator for each image */
      for (i = 0; i < num_images; i++)
       self->_priv->iterators[i] = 
          gegl_image_iterator_new (image_buffers[i]);

    /*  
      Now based on the color_models and data storage strategies,
      we should install an appropriate point op apply function.
      So far there is just one, since only one kind of data storage. 
     */

      /* Heres the apply for this kind of data storage */
      op_class->apply = gegl_point_op_apply;  
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglPointOp *self = GEGL_POINT_OP(object); 
    GeglOp *op =  GEGL_OP(object);
    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);
    gint i;

    /* Free iterator array and iterators */
    if (self->_priv->iterators)
      {
        /* Free the iterator objects */
       for (i = 0; i < opP->num_images; i++)
         if (self->_priv->iterators[i])
          gegl_object_destroy(GEGL_OBJECT(self->_priv->iterators[i]));  
        
        /* Free the array */
        g_free(self->_priv->iterators);
      }

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  private 
  void
  apply (GeglOp *op)
  {
    gint i;
    gint j;

    GeglRect *rects = NULL;

    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);
    GeglPointOp *self =  GEGL_POINT_OP(op);
    GeglPointOpClass *self_class = 
       GEGL_POINT_OP_CLASS (GTK_OBJECT(op)->klass);

    rects = g_new(GeglRect, opP->num_images);

    /* Tell each iterators what rect we plan to use*/
    for (i = 0; i < opP->num_images; i++)
      gegl_image_iterator_request_rect (
              self->_priv->iterators[i], 
              &(opP->rects[i]));

    /* Now find out what the actual rects we receive are  */
    for (i = 0; i < opP->num_images; i++)
      gegl_image_iterator_get_current_rect ( 
        self->_priv->iterators[i], &rects[i]);

    /* 
       We will have additional code here to decide
       how to iterate for a this type of storage strategy. 
       and so wind up with a loop over a bunch of
       rects whose union is the entire region we
       wish to process. Now we just do our one
       rect which is the same as the one we requested. 
    */

    /* 
      Set the scanline width (of the dest rect)
      so our subclass(es) can retrieve it  
    */
    self->_priv->scanline_width = rects[0].w; 

    /* Now iterate over the scanlines in the dest */
    for(j = 0; j < rects[0].h; j++)  
      {
        /* Call the installed scanline func of subclass */
        (self_class->scanline_func)(self);
          
        /* Advance all the iterators */
        for (i = 0; i < opP->num_images; i++)
          gegl_image_iterator_next_scanline (
                self->_priv->iterators[i]);

      }

    g_free (rects);   
  }

  virtual private void scanline_func (self);
}

