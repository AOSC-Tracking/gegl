%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_TILE_ITERATOR__
#define __TYPEDEF_GEGL_TILE_ITERATOR__
typedef struct _GeglTileIterator  GeglTileIterator;
#endif

%}
%{
#include "gegl-point-op.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image.h"
#include "gegl-image-private.h"
#include "gegl-color-model.h"
#include "gegl-node.h"
#include "gegl-tile.h"
#include "gegl-tile-iterator.h"
#include "gegl-utils.h"
%}

class Gegl:Point:Op from Gegl:Op {

  protected 
  gboolean 
  constructor(self, 
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), inputs))
      return FALSE;

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  override (Gegl:Image) 
  void 
  compute_have_rect (GeglImage *self_image) 
  {
    GeglNode *self_node = GEGL_NODE(self_image);
    GeglOp *self_op = GEGL_OP(self_image);
    gint num_inputs = gegl_node_num_inputs(self_node);
    GeglRect have_rect;
    GeglRect intersection;
    GeglImage *input;
    gint i;

    gegl_rect_set(&self_image->have_rect, 0, 0, G_MAXINT, G_MAXINT);

    /* Lets take the intersection of all the have_rects,
       though this isnt ideal, it covers some important cases. */ 
    for (i = 0; i < num_inputs; i++)
      {
        /* Get the have_rect of ith input, in its coords */
        input = GEGL_IMAGE(gegl_node_get_nth_input(self_node,i));
        gegl_image_get_have_rect (input, &have_rect);

        /* Put in the offsets for this op */
        have_rect.x += self_op->input_offsets[i].x;
        have_rect.y += self_op->input_offsets[i].y;

        gegl_rect_intersect (&intersection, 
            &self_image->have_rect, &have_rect); 

        gegl_rect_copy(&self_image->have_rect, &intersection);

      }
  }

  override (Gegl:Image) 
  void 
  compute_preimage(GeglImage *self_image, 
                   GeglRect *rect, 
                   GeglRect *preimage, 
                   gint i)
  {
    GeglOp *self_op = GEGL_OP(self_image); 
    gegl_rect_copy (preimage, rect);
 
    /* 
       Just take out the offset of this input,
       so put preimage in the inputs coord system.
    */ 
    preimage->x -= self_op->input_offsets[i].x;
    preimage->y -= self_op->input_offsets[i].y;

  }

  override (Gegl:Image)
  void  
  apply(GeglImage *self_image,
        GList *requests)
  {
    GeglImageRequest * request;
    gint i,j;
    gint width, height;
    GeglPointOp *self =  GEGL_POINT_OP(self_image);
    GeglPointOpClass *self_class = 
        GEGL_POINT_OP_CLASS (GTK_OBJECT(self_image)->klass);
    GeglNode *self_node = GEGL_NODE(self_image);
    gint num_inputs = gegl_node_num_inputs(self_node);
    GeglTileIterator **iters = g_new (GeglTileIterator*, num_inputs+1);

    /* Get tile iterators for dest and sources. */
    for (i = 0; i < num_inputs+1; i++)
      {
         request = (GeglImageRequest*)g_list_nth_data(requests,i); 

         /* Get the tile, if it is not NULL */ 
         if(request->tile)
           {
             iters[i] = gegl_tile_iterator_new (request->tile, &request->rect);
             gegl_tile_iterator_first (iters[i]);
           }
         else
           iters[i] = NULL;
      }

    /* Get the height and width of dest rect we want to process */
    request = (GeglImageRequest*)g_list_nth_data(requests,0); 
    width = request->rect.w;
    height = request->rect.h;

    /* Now iterate over the scanlines in the dest. */
    for(j=0; j < height; j++)
      {
        /* Call the subclass scanline func. */
        (self_class->scanline_func)(self, iters, width);

        /* Advance all the scanlines. */
        for (i = 0; i < num_inputs+1; i++)
          {
            if(iters[i])
              gegl_tile_iterator_next(iters[i]);
          }

      } 

    /* Free the iterators */
    for (i = 0; i < num_inputs+1; i++)
      {
        if (iters[i])
          gegl_object_unref (GEGL_OBJECT (iters[i])); 
      }

    /* Free the array of iterator pointers */
    g_free (iters);
  }

  /* Subclasses install their own scanline funcs */
  virtual private void 
  scanline_func (self,
                 GeglTileIterator **iters,
                 gint width);
}

