%h{
#include "gegl-op.h"
#include "gegl-image-buffer.h"
%}
%{
#include "gegl-point-op.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-utils.h"
%}

class Gegl:Point:Op from Gegl:Op {

  private gint scanline_width;   /*width of scanline*/
  
  protected 
  gboolean 
  constructor(self, 
	      GeglImageBuffer **image_buffers, 
	      GeglRect *rects, 
	      gint num_images)
  {
    GeglOp *op = GEGL_OP (self);
    GeglOpClass *op_class = GEGL_OP_CLASS(GTK_OBJECT(op)->klass);

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
	
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), 
	image_buffers, rects, num_images))
      return FALSE;
   
    /* Dont know this yet till after we request a rect 
	to work with, which we do in apply */
    self->_priv->scanline_width = 0;

    /*  
	Now based on the color_models and data storage strategies,
	we should install an appropriate point op apply function.
	So far there is just one, since only one kind of data storage. 
     */

#if 0
    switch (storage strategy)
    {
      case DATA_BANKS_PLANAR:
        op_class->apply = gegl_point_op_apply;  
	break;
      case DATA_BANKS_INTERLEAVED:
      case DATA_BANKS_PACKED:
        op_class->apply = NULL;  
	g_warning("PointOp: Data Storage type none or unknown\n");
	return FALSE;
    }
#endif
    op_class->apply = gegl_point_op_apply;  

    return TRUE;
  }

  private 
  void
  apply (GeglOp *op)
  {
    gint i;
    gint j;

    GeglRect *rects = NULL;

    GeglOpPrivate *opP = (GeglOpPrivate *)(op->_priv);
    GeglPointOp *self =  GEGL_POINT_OP(op);
    GeglPointOpClass *self_class = GEGL_POINT_OP_CLASS (GTK_OBJECT(op)->klass);

    rects = g_new(GeglRect, opP->num_images);

    /* Request the rects to work with */
    for (i = 0; i < opP->num_images; i++)
      gegl_image_buffer_request_rect (
	  opP->image_buffers[i], &(opP->rects[i]));

    /* And get the current rects (the same as requested for now) */
    for (i = 0; i < opP->num_images; i++)
      gegl_image_buffer_get_current_rect ( 
	opP->image_buffers[i], &rects[i]);

    /* 
	Set the scanline width (of the dest rect)
	so our subclass(es) can retrieve it  
    */
    self->_priv->scanline_width = rects[0].w; 


    /* Now iterate over the scanlines in the dest */
    for(j = 0; j < rects[0].h; j++)  
      {
	 /* Call the installed scanline func of subclass */
	 (self_class->scanline_func)(self);
	  
	 /* Advance the dest and sources scanline ptrs */
	 for (i = 0; i < opP->num_images; i++)
	  	gegl_image_buffer_next_scanline (opP->image_buffers[i]);

      }

    g_free (rects);   
  }

  virtual private void scanline_func (self);
}

