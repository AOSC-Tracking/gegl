%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_IMAGE_ITERATOR__
#define __TYPEDEF_GEGL_IMAGE_ITERATOR__
typedef struct _GeglImageIterator  GeglImageIterator;
#endif

%}
%{
#include "gegl-point-op.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-node.h"
#include "gegl-image-iterator.h"
#include "gegl-utils.h"
#include "trace.h"
%}

class Gegl:Point:Op from Gegl:Op {

  private gint unused;

  protected 
  gboolean 
  constructor(self, 
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), "point_op", inputs))
      return FALSE;
    
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Op) 
  void 
  compute_need_rect (GeglOp *self_op, 
                     GeglRect *need_rect, 
                     gint i) 
  {
    /* 
       Need rect of children is same size as for point op,
       just translated back to childrens coordinate system
    */ 
    gegl_rect_copy (need_rect, &self_op->_priv->need_rect);
 
    need_rect->x -= self_op->_priv->input_offsets[i].x;
    need_rect->y -= self_op->_priv->input_offsets[i].y;

  }

  override (Gegl:Op) 
  void 
  compute_result_rect (GeglOp *self_op) 
  {
    GeglImage *self_image = GEGL_IMAGE(self_op);
    gegl_rect_intersect (&self_op->_priv->result_rect, 
                         &self_op->_priv->need_rect,
                         &self_image->_priv->have_rect);
  }

  override (Gegl:Op) 
  void 
  compute_have_rect (GeglOp *self_op) 
  {
    GeglImage *self_image = GEGL_IMAGE(self_op);
    GeglNode *self_node = GEGL_NODE(self_op);
    gint num_inputs = gegl_node_num_inputs(self_node);
    GeglRect have_rect;
    GeglRect intersection;
    GeglImage *input;
    gint i;

    gegl_rect_set(&self_image->_priv->have_rect, 0, 0, G_MAXINT, G_MAXINT);

    /* Lets take the intersection of all the have_rects,
       though this isnt ideal, it covers some important cases. */ 
    for (i = 0; i < num_inputs; i++)
      {
        /* Get the have_rect of source i, in its coords */
        input = GEGL_IMAGE(gegl_node_get_nth_input(self_node,i));
        gegl_image_get_have_rect (input, &have_rect);

        /* Put in the offsets for this op */
        have_rect.x += self_op->_priv->input_offsets[i].x;
        have_rect.y += self_op->_priv->input_offsets[i].y;

        gegl_rect_intersect (&intersection, 
            &self_image->_priv->have_rect, &have_rect); 

        gegl_rect_copy(&self_image->_priv->have_rect, &intersection);

      }
  }

  override (Gegl:Op)
  void  
  apply(GeglOp *self_op,
        GeglImage *dest,
        GeglRect *result_rect) 
  {
    GeglPointOp *self =  GEGL_POINT_OP(self_op);
    GeglPointOpClass *self_class = 
      GEGL_POINT_OP_CLASS (GTK_OBJECT(self_op)->klass);
    GeglNode *self_node = GEGL_NODE(self_op);
    gint num_inputs = gegl_node_num_inputs(self_node);
    GeglImage *input;
    GeglRect rect;
    gint i,j;
    gint height;
    GeglImageIterator **src_iters = g_new (GeglImageIterator*, num_inputs);
    GeglImageIterator *dest_iter;

    /* Set up the source and dest iterators */
    for (i = 0; i < num_inputs; i++)
      {
        gegl_rect_copy (&rect, &self_op->_priv->result_rect);  

        rect.x -= self_op->_priv->input_offsets[i].x;
        rect.y -= self_op->_priv->input_offsets[i].y;

        input = GEGL_IMAGE(gegl_node_get_nth_input(self_node,i));
        src_iters[i] = gegl_image_iterator_new (input, &rect);
      }

    dest_iter = gegl_image_iterator_new (dest, result_rect);
    height = gegl_image_iterator_current_rect_height (dest_iter);

    /* Now iterate over the scanlines in the dest */
    for(j = 0; j < height; j++)  
      {
        /* Call the installed subclass scanline func */
        (self_class->scanline_func)(self, dest_iter, src_iters);
          
        /* Advance all the source iterators */
        for (i = 0; i < num_inputs; i++)
          gegl_image_iterator_next_scanline (src_iters[i]);

        /* Advance the dest iterator */
        gegl_image_iterator_next_scanline (dest_iter);
      }

    /* Free the source and dest iterators */
    for (i = 0; i < num_inputs; i++)
      gtk_object_unref (GTK_OBJECT (src_iters[i])); 

    gtk_object_unref(GTK_OBJECT (dest_iter));

    /* Free the arrays of iters and rects */
    g_free (src_iters);
  }

  /* Subclasses install their own scanline funcs */
  virtual private void 
  scanline_func (self,
                 GeglImageIterator *dest_iter, 
                 GeglImageIterator **src_iters);
}

