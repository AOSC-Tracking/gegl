%h{
#include "gegl-point-op.h"
typedef  void (*ScanlineFuncP)(GeglPointOp *self_point_op,
				               GeglTileIterator **iters,
                               gint width);

%}
%{
#include "gegl-image.h"
#include "gegl-op.h"
#include "gegl-op-private.h"
#include "gegl-color-model.h"
#include "gegl-n-src-op.h"
#include "gegl-n-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-node-private.h"
%}


class Gegl:N:Src:Op from Gegl:Point:Op
{
  private guint32 mask_mask;
  classwide ScanlineFuncP scanline_funcs[5][6];

  protected 
  gboolean 
  constructor(self, 
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;

    {
      /* Chain up */
      if (!gegl_point_op_constructor (GEGL_POINT_OP(self), inputs))
        return FALSE;
    }
    /* 0 would be a legal value so set mask_mask to maxlong */
    self->_priv->mask_mask = G_MAXLONG;

    return TRUE;
  }

  override(Gegl:Image)
  void
  prepare(GeglImage *self_image,
          GList *requests)
  {
    GeglNSrcOp       *self_n_src_op = GEGL_N_SRC_OP (self_image);
    GeglNode         *self_node     = GEGL_NODE (self_image);
    GeglPointOp      *self_point_op = GEGL_POINT_OP (self_image);

    GeglPointOpClass *self_point_op_class =
      GEGL_POINT_OP_CLASS(GTK_OBJECT(self_point_op)->klass);

    GeglNSrcOpClass  *self_n_src_op_class =
      GEGL_N_SRC_OP_CLASS(GTK_OBJECT(self_n_src_op)->klass);

    GeglChannelDataType datatype   = GEGL_U8;  /* FIXME */
    GeglColorSpace      colorspace = GEGL_COLOR_SPACE_RGB; /* FIXME */

    GList *list;
    guint32 mask_mask = 0;

    GeglColorModel *cm;
    
    /* compute the mask_mask so we can switch on it in the scanline funcs */

    for (list = g_list_last(gegl_node_get_inputs(self_node)); 
         list; 
         list = g_list_previous(list))
      {
        cm = gegl_image_color_model(GEGL_IMAGE(list->data));
            if (gegl_color_model_has_alpha (cm))
          mask_mask = (mask_mask << 1) | 1;
        else
          mask_mask = (mask_mask << 1) | 0;
      }
    
    self_n_src_op->_priv->mask_mask = mask_mask;

    /* Now make sure the correct scanline func is installed */
    if (!(self_point_op_class->scanline_func =
	  self_n_src_op_class->scanline_funcs[datatype][colorspace]))
      {
        g_error("Unimplemented scanline_func");
      }
  }
}
