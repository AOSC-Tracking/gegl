%h{
#include "gegl-color-model-gray.h"
%}
%{
#include "gegl-color-model-gray-u16_4.h"
#include "gegl-color-model-gray-u16_4-private.h"
#include "gegl-color-model-gray-private.h"
#include "gegl-color-model-private.h"
#include "gegl-color.h"
%}

class Gegl:Color:Model:Gray:U16_4 from Gegl:Color:Model:Gray {

  public
  GeglColorModelGrayU16_4 *       
  new(gboolean has_alpha)
  {
    GeglColorModelGrayU16_4 * self = GEGL_COLOR_MODEL_GRAY_U16_4(GET_NEW);
  
    /*Call the constructor */
    if (!constructor(self, has_alpha))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }
  
  protected
  gboolean 
  constructor(self, 
              gboolean has_alpha)
  {
    GeglColorModel *self_color_model = GEGL_COLOR_MODEL (self);

    if (GEGL_OBJECT(self)->constructed) 
        return FALSE;
    
    /* Chain up to superclass*/
    if (!gegl_color_model_gray_constructor (
         GEGL_COLOR_MODEL_GRAY(self), has_alpha))
        return FALSE;

    self_color_model->data_type = GEGL_U16_4;
    self_color_model->channel_data_type_name = NULL;
    self_color_model->bytes_per_channel = sizeof(guint16);
    self_color_model->bytes_per_pixel = 
                  self_color_model->bytes_per_channel * 
                  self_color_model->num_channels;
    return TRUE;
  }
  
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Color:Model) 
  void 
  set_color (GeglColorModel *self_color_model, 
             GeglColor *color, 
             GeglColorConstant constant)
  {
    GeglChannelValue * channel_values = 
                       gegl_color_get_channel_values(color); 
    gboolean has_alpha = gegl_color_model_has_alpha (self_color_model); 
    GeglColorModelGray * cm_gray = GEGL_COLOR_MODEL_GRAY(self_color_model);
    
    gint g = gegl_color_model_gray_get_gray_index (cm_gray);
    gint a = gegl_color_model_alpha_channel (GEGL_COLOR_MODEL(cm_gray));

    switch (constant) 
      { 
        case COLOR_WHITE:
          channel_values[g].u16_4 = 4095;
          if (has_alpha)
            channel_values[a].u16_4 = 4095;
          break;
        case COLOR_BLACK:
          channel_values[g].u16_4 = 0;
          if (has_alpha)
            channel_values[a].u16_4 = 4095;
          break;
        case COLOR_RED:
          channel_values[g].u16_4 = CLAMP(ROUND(0.3 * 4095),0,4095);
          if (has_alpha)
            channel_values[a].f = 4095;
          break;
        case COLOR_GREEN:
          channel_values[g].u16_4 = CLAMP(ROUND(0.59 * 4095),0,4095);
          if (has_alpha)
            channel_values[a].u16_4 = 4095;
          break;
        case COLOR_BLUE:
          channel_values[g].u16_4 = CLAMP(ROUND(0.11 * 4095),0,4095);
          if (has_alpha)
            channel_values[a].u16_4 = 4095;
          break;
        case COLOR_GRAY:
        case COLOR_HALF_WHITE:
          channel_values[g].u16_4 = 2048;
          if (has_alpha)
            channel_values[a].u16_4 = 4095;
          break;
        case COLOR_WHITE_TRANSPARENT:
          channel_values[g].u16_4 = 4095;
          if (!has_alpha)
            channel_values[a].u16_4 = 0;
          break;
        case COLOR_TRANSPARENT:
        case COLOR_BLACK_TRANSPARENT:
          channel_values[g].u16_4 = 0;
          if (has_alpha)
            channel_values[a].u16_4 = 0;
          break;
      }
   }

  override (Gegl:Color:Model)
  void
  convert_to_xyz (GeglColorModel *self_color_model, 
                  gfloat **xyz_data, 
                  guchar **data, /*gray u16_4 data */ 
                  gint width)
  {
    /* convert from u16_4 gray to float xyz */

    gfloat m00 = 0.412453;
    gfloat m10 = 0.357580;
    gfloat m20 = 0.180423;
    gfloat m01 = 0.212671;
    gfloat m11 = 0.715160;
    gfloat m21 = 0.072169;
    gfloat m02 = 0.019334;
    gfloat m12 = 0.119193;
    gfloat m22 = 0.950227;
                              
    guint16 *g; 
    guint16 *a = NULL;
    gfloat G;
    gfloat *x, *y, *z; 
    gfloat *xyz_a = NULL;
    gfloat tmp= 1.0/4095.0;

    gboolean has_alpha = gegl_color_model_has_alpha(self_color_model);

    g = (guint16*)data[0];
    x = xyz_data[0];
    y = xyz_data[1];
    z = xyz_data[2];

    if (has_alpha)
      {
       a = (guint16*)data[1];
       xyz_a = xyz_data[3];
      }

    while (width--)
      {
       G = *g++ * tmp;
       *x++ = (m00 + m10 + m20) * G;
       *y++ = (m01 + m11 + m21) * G;
       *z++ = (m02 + m12 + m22) * G;
       if (has_alpha)
         *a++ = *a++ * tmp;
      }
  }

  override (Gegl:Color:Model)
  void
  convert_from_xyz (GeglColorModel *self_color_model, 
                    guchar **data, /*gray u16_4 data */
                    gfloat **src_data, 
                    gint width)
  {
    /* convert from float xyz to u16_4 gray */

    /*
      __  __      __                               __  __  __
      | R  |      | 3.240479   -1.537150   -0.498535 | | X  |
      | G  |   =  |-0.969256    1.875992    0.041556 | | Y  |
      | B  |      | 0.055648   -0.204043    1.057311 | | Z  |
      --  --      ---                             ---- --  --
    */
    gfloat m00 = 3.240479;
    gfloat m10 = -1.537150;
    gfloat m20 = -0.498535;
    gfloat m01 = -0.969256;
    gfloat m11 = 1.875991;
    gfloat m21 = 0.041556;
    gfloat m02 = 0.055648;
    gfloat m12 = -0.204043;
    gfloat m22 = 1.057311;
                                
    guint16 *g; 
    guint16 *a = NULL;
    gfloat *src_x, *src_y, *src_z; 
    gfloat *src_a = NULL; 

    gboolean has_alpha = gegl_color_model_has_alpha(self_color_model);

    g = (guint16*)data[0];
    src_x = src_data[0];
    src_y = src_data[1];
    src_z = src_data[2];

    if (has_alpha)
      {
         a = (guint16*)data[1];
         src_a = src_data[3];
      }

    while (width--)
      {
         *g    = CLAMP(ROUND((m00 * *src_x + m10 * *src_y + m20 * *src_z) * 4095 * 0.3),0,4095);
         *g   += CLAMP(ROUND((m01 * *src_x + m11 * *src_y + m21 * *src_z) * 4095 * 0.59),0,4095);
         *g++ += CLAMP(ROUND((m02 * *src_x + m12 * *src_y + m22 * *src_z) * 4095 * 0.11),0,4095);

         src_x++;
         src_y++;
         src_z++;
         if (has_alpha)
          {
            *a++  = CLAMP(ROUND(*src_a * 4095),0,4095);
            src_a++;
          }
      }
  }
}

