%h{
#include "gegl-object.h"
#ifndef __TYPEDEF_GEGL_IMAGE__
#define __TYPEDEF_GEGL_IMAGE__
typedef struct _GeglImage GeglImage;
#endif
%}
%{
#include "gegl-image-iterator.h"
#include "gegl-image-iterator-private.h"
#include "gegl-object-private.h"
#include "gegl-image.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Iterator from Gegl:Object {

  private GeglImage *image;         /* The image we iterate over */
  private GeglRect current_rect;    /* The current data rect */ 
  private gint scanline;            /* in [0, current_rect.h-1] */ 
  private guchar **scanline_data;   /* data pointers to current scanline */

  public
  GeglImageIterator *       
  new(GeglImage *image, GeglRect *rect)
  {
    GeglImageIterator * self = GEGL_IMAGE_ITERATOR(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, image, rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    /* Ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

    return self;
  }

  protected 
  gboolean 
  constructor (self, 
               GeglImage *image,
	       GeglRect *rect)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    {
      GeglColorModel *cm = gegl_image_color_model(image);
      gint num_channels = gegl_color_model_num_channels(cm);

      self->_priv->scanline = 0;
      self->_priv->scanline_data = NULL; 
      self->_priv->image = image; 

      gegl_rect_copy(&self->_priv->current_rect, rect);

      /*Allocate data pointers array*/
      self->_priv->scanline_data = g_new(guchar*, num_channels);

      /*Make the scanline data point to the passed rect */
      begin_scanline (self);

    }
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImageIterator *self = GEGL_IMAGE_ITERATOR (object);

    /* Dispose of scanline data pointer array*/
    if (self->_priv->scanline_data)
      g_free(self->_priv->scanline_data);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public
  void
  begin_scanline (self)
  {
    gint  i;
    gint  x;
    gint  y;
    guchar **image_data;

    GeglColorModel *cm = gegl_image_color_model (self->_priv->image);
    gint num_channels  =  gegl_color_model_num_channels (cm);
    gint bytes_per_channel = gegl_color_model_bytes_per_channel (cm); 
    gint width = gegl_image_get_width (self->_priv->image); 
    gint channel_row_bytes = bytes_per_channel * width; 

    self->_priv->scanline = 0;

    /* Get the image data */
    image_data = gegl_image_get_data(self->_priv->image);

    x = self->_priv->current_rect.x;
    y = self->_priv->current_rect.y;

    /* Set up the iterators scanline channel pointers */
    for (i = 0; i < num_channels; i++)
      self->_priv->scanline_data[i] = image_data[i] + 
                                    y * channel_row_bytes + 
                                    x * bytes_per_channel;   
  }

  public
  gint
  scanline_width (self)
  {
    return self->_priv->current_rect.w;
  }

  public
  gint
  current_rect_height (self)
  {
    return self->_priv->current_rect.h;
  }

  public
  GeglImage * 
  get_image(self)
  {
    return self->_priv->image;
  }
  
  public
  void
  next_scanline (self)
  {
    /* Means we are advancing to the next scanline */
    gint i;
    GeglColorModel *cm = gegl_image_color_model(self->_priv->image);
    gint num_channels = gegl_color_model_num_channels(cm); 
    gint width = gegl_image_get_width (self->_priv->image);
    gint bytes_per_channel = gegl_color_model_bytes_per_channel(cm ); 
    gint channel_row_bytes = bytes_per_channel * width; 

    self->_priv->scanline++;

   for (i=0; i < num_channels; i++)
      self->_priv->scanline_data[i] += channel_row_bytes; 
  }

  public
  void
  get_scanline_data (self, guchar **data_ptrs)
  {
    gint i;
    GeglColorModel *cm = gegl_image_color_model(self->_priv->image);
    gint num_channels = gegl_color_model_num_channels (cm); 

    for (i=0; i < num_channels; i++)
      data_ptrs[i] = self->_priv->scanline_data[i];   

  }
}
