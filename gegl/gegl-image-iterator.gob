%h{
#include "gegl-object.h"
#ifndef __TYPEDEF_GEGL_IMAGE_BUFFER__
#define __TYPEDEF_GEGL_IMAGE_BUFFER__
typedef struct _GeglImageBuffer  GeglImageBuffer;
#endif
%}
%{
#include "gegl-image-iterator.h"
#include "gegl-image-iterator-private.h"
#include "gegl-object-private.h"
#include "gegl-image-buffer.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Image:Iterator from Gegl:Object {

  private GeglImageBuffer *image_buffer;   /* The image we iterate over */
  private GeglRect request_rect;           /* The requested data rect*/
  private GeglRect current_rect;           /* The actual current data rect */ 
  private gint scanline;                        /* in [0, current_rect.h-1] */ 
  private guchar **scanline_data;          /* data pointers to current scanline */

  public
  GeglImageIterator *       
  new(GeglImageBuffer *image_buffer)
  {
    GeglImageIterator * self = GEGL_IMAGE_ITERATOR(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, image_buffer))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *image_buffer)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_object_constructor (GEGL_OBJECT(self)))
      return FALSE;

    {
      GeglColorModel *cm;
      gint num_channels;

      gegl_rect_set (&(self->_priv->request_rect),0,0,0,0);
      gegl_rect_set (&(self->_priv->current_rect),0,0,0,0);

      self->_priv->scanline = 0;
      self->_priv->scanline_data = NULL; 
      self->_priv->image_buffer = image_buffer; 

      cm = gegl_image_buffer_color_model(image_buffer);
      num_channels = gegl_color_model_num_channels(cm);
     
      /*Allocate data pointers array*/
      self->_priv->scanline_data = g_new(guchar*, num_channels);
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImageIterator *self = GEGL_IMAGE_ITERATOR (object);

    /* Dispose of scanline data pointer array*/
    if (self->_priv->scanline_data)
      g_free(self->_priv->scanline_data);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  public
  void
  request_rect (self, GeglRect *request_rect)
  {
    gegl_rect_copy (&(self->_priv->request_rect), 
                    request_rect);
              
  /* 
     Heres where we set the current rect based on the 
     request rect. The data storage right now is simple 
     and the request rect = current rect.
  */

    gegl_rect_copy (&(self->_priv->current_rect), 
                    &(self->_priv->request_rect));
  }

  public
  void
  get_current_rect (self, GeglRect *current_rect)
  {
    /* Means we are about to start processing the current rect of image */
    gint  i;
    gint  x;
    gint  y;
    guchar *image_data;

    GeglColorModel *cm = gegl_image_buffer_color_model(
                               self->_priv->image_buffer);
    gint num_channels = gegl_color_model_num_channels(cm);
    gint bytes_per_channel = gegl_color_model_bytes_per_channel(cm); 
    gint width = gegl_image_buffer_get_width (self->_priv->image_buffer);
    gint height = gegl_image_buffer_get_height (self->_priv->image_buffer);
    gint channel_row_bytes = bytes_per_channel * width; 
    gint plane_bytes = bytes_per_channel * width * height; 

    /* Copy our private current rect to the one passed in */ 
    gegl_rect_copy (current_rect, &(self->_priv->current_rect));

    /* This also sets the scanline index to first scanline of rect */ 
    self->_priv->scanline = 0;
 
    x = self->_priv->current_rect.x;
    y = self->_priv->current_rect.y;

    /* 
       and then sets the data channel pointers 
       to first pixel of first scanline of that rect
    */

    image_data =  gegl_image_buffer_get_data(self->_priv->image_buffer);

    /* first channel */
    self->_priv->scanline_data[0] = image_data + 
                                    y * channel_row_bytes + 
                                    x * bytes_per_channel;   

    /* and any other channels */
    for (i=1; i < num_channels; i++)
     self->_priv->scanline_data[i] = self->_priv->scanline_data[i-1] + 
                                     plane_bytes;
  }

  public
  void
  next_scanline (self)
  {
    /* Means we are advancing to the next scanline */
    gint i;
    GeglColorModel *cm = gegl_image_buffer_color_model(
                               self->_priv->image_buffer);
    gint num_channels = gegl_color_model_num_channels(cm); 
    gint width = gegl_image_buffer_get_width (self->_priv->image_buffer);
    gint bytes_per_channel = gegl_color_model_bytes_per_channel(cm ); 
    gint channel_row_bytes = bytes_per_channel * width; 

    /* advance the current scanline index */
    self->_priv->scanline++;

    /* 
       Update our private scanline data pointers to point 
       to next scanline. 
    */
    for (i=0; i < num_channels; i++)
      self->_priv->scanline_data[i] += channel_row_bytes; 
  }

  public
  void
  get_scanline_data (self, guchar **data_ptrs)
  {
    gint i;
    GeglColorModel *cm = gegl_image_buffer_color_model(
                               self->_priv->image_buffer);
    gint num_channels = gegl_color_model_num_channels (cm); 

    /* 
       Set the passed in data pointers 
       equal to our private data pointers which 
       should already point to the beginning of the
       current scanline. 
       
     */

    for (i=0; i < num_channels; i++)
      data_ptrs[i] = self->_priv->scanline_data[i];   

  }
}
