%h{
#include "gegl-node.h"
#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif
#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif
%}
%{
#include "gegl-image.h"
#include "gegl-image-private.h"
#include "gegl-node-private.h"
#include "gegl-object-private.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Image from Gegl:Node {

  private GeglColorModel *color_model;

  protected gint width;
  protected gint height;

  private guchar **data;           /* actual channel data pointers  */
  protected GeglRect data_rect;    /* data represents this sub rect */

  protected GeglRect have_rect;    /* ie the domain of definition   */
  protected GeglRect need_rect;    /*roi info passed down from root */
  protected GeglRect result_rect;  /*result - based on needRect,haveRect */

  protected 
  gboolean 
  constructor(self,
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_node_constructor (GEGL_NODE(self), inputs))
      return FALSE;

    self->width = 0;
    self->height = 0;
    self->_priv->color_model = NULL;
    self->_priv->data = NULL;

    gegl_rect_set (&self->have_rect,0,0,0,0);
    gegl_rect_set (&self->need_rect,0,0,0,0);
    gegl_rect_set (&self->result_rect,0,0,0,0);

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImage *self = GEGL_IMAGE(object);
    free_data (self);

    if(self->_priv->color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->color_model));

    self->_priv->color_model = NULL;

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  protected
  gboolean 
  alloc(self, 
        gint w,
        gint h)
  {
    GeglColorModel *cm = self->_priv->color_model;
    gint i;

    if (self->_priv->data)
      {
        free_data(self);
      }

    if (!cm)
      {
        g_warning("gegl_image_alloc: color_model unknown\n");
        return FALSE;
      }

    {
      gint bpc = gegl_color_model_bytes_per_channel(cm);  
      gint num_channels = gegl_color_model_num_channels(cm);
      gint channel_bytes = bpc * w * h;

      self->_priv->data = g_new(guchar *, num_channels);

      for(i = 0; i < num_channels; i++)
        {
          self->_priv->data[i] = g_new (guchar, channel_bytes); 
          if (!self->_priv->data[i]) 
            {
              free_data(self);
              g_warning ("gegl_image_alloc: Cant alloc image data.\n"); 
              return FALSE;
            }
        }

      self->width = w;
      self->height = h;

      /* The domain of definition by default is the whole thing */
      gegl_rect_set (&self->have_rect,0,0,w,h);
    }

    return TRUE;
  }

  protected
  void
  free_data(self) 
  {
    GeglColorModel *cm = self->_priv->color_model;
    gint num_channels = gegl_color_model_num_channels(cm);
    gint i;

    if (self->_priv->data)
      {
        for(i = 0; i < num_channels; i++)
          {
            if (self->_priv->data[i]) 
            g_free (self->_priv->data[i]);
          }
        g_free (self->_priv->data); 
      }

    self->_priv->data = NULL;
    self->width = 0;
    self->height = 0;
    gegl_rect_set (&self->have_rect,0,0,0,0);
  }

  public
  void 
  get_have_rect(self, GeglRect *have_rect)
  {
    gegl_rect_copy (have_rect, &self->have_rect);
  }

  public
  void 
  set_have_rect(self, GeglRect *have_rect)
  {
    gegl_rect_copy (&self->have_rect, have_rect);
  }

  public
  guchar ** 
  get_data(self)
  {
    return self->_priv->data;
  }

  public 
  gint 
  get_width (self)
  {
    return self->width;
  }

  public 
  gint 
  get_height (self)
  {
    return self->height;
  }

  public
  GeglColorModel * 
  color_model(self) 
  { 
    return self->_priv->color_model; 
  }

  public
  gboolean 
  has_alpha(self) 
  {
    return gegl_color_model_has_alpha (self->_priv->color_model); 
  }

  public
  void
  set_color_model(self,
                  GeglColorModel *cm) 
  { 
    /* Unref any old one */
    if(self->_priv->color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->color_model)); 

    /* Set and ref the new one */
    self->_priv->color_model = cm; 
    gegl_object_ref(GEGL_OBJECT(cm));
  }

  virtual public GeglImage * get_pixels (self, GeglImage *dest, GeglRect *dest_roi);
  virtual protected void compute_have_rect (self); 
  virtual protected void compute_need_rect (self, GeglRect *need_rect, gint index); 
  virtual protected void compute_result_rect (self); 
}
