%h{
#include "gegl-op.h"

#ifndef __TYPEDEF_GEGL_COLOR__
#define __TYPEDEF_GEGL_COLOR__
typedef struct _GeglColor  GeglColor;
#endif

#ifndef __TYPEDEF_GEGL_COLOR_MODEL__
#define __TYPEDEF_GEGL_COLOR_MODEL__
typedef struct _GeglColorModel  GeglColorModel;
#endif

%}


%{
#include "gegl-image.h"
#include "gegl-image-private.h"
#include "gegl-op-private.h"
#include "gegl-image-manager.h"
#include "gegl-image-manager-private.h"  /*friend*/
#include "gegl-node-private.h"
#include "gegl-object-private.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Image from Gegl:Op {

  private GeglColorModel *color_model;

  protected GeglRect have_rect;    /* domain of definition */
  protected GeglRect need_rect;    /* region of interest */
  protected GeglRect result_rect;  /* intersection of need and have rects */
  protected GeglRect cache_rect;   /* a valid computed result */

  private GeglColorModel *derived_color_model; /* derived color model */
  private GeglImage *dest;         /* a dest to use */

  /**
   * constructor:
   * @self: a #GeglImage.
   * @inputs: #GeglImage list.
   *
   * Initializes the #GeglImage. Sets the color model to NULL.
   *
   * Returns: TRUE if constructed successfully.
   **/
  protected 
  gboolean 
  constructor(self,
              GList *inputs)
  {
    if(GEGL_OBJECT(self)->constructed)
      return FALSE;
       
    /* Chain up */
    if (!gegl_op_constructor (GEGL_OP(self), inputs))
      return FALSE;

    self->_priv->color_model = NULL;
    self->_priv->derived_color_model = NULL;
    self->_priv->dest = NULL;

    gegl_rect_set (&self->have_rect,0,0,0,0);
    gegl_rect_set (&self->need_rect,0,0,0,0);
    gegl_rect_set (&self->result_rect,0,0,0,0);
    gegl_rect_set (&self->cache_rect,0,0,0,0);

    return TRUE;
  }


  /**
   * destroy:
   * @object:
   *
   * Frees memory allocated by this object. Calls the #GeglImageManager to free
   * any image data it has for this image. 
   *
   **/ 
  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglImage *self = GEGL_IMAGE(object);

    /* Give the image manager a chance to handle tiles. */
    GeglImageManager *image_manager = gegl_image_manager_instance();
    gegl_image_manager_delete_image(image_manager,self); 

    if(self->_priv->color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->color_model));
    if(self->_priv->derived_color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->derived_color_model));

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }


  /**
   * get_have_rect:
   * @self: a #GeglImage
   * @have_rect: returned rect.
   *
   * Gets the domain of definition computed during graph evalution.
   *
   **/ 
  public
  void 
  get_have_rect(self, 
                GeglRect *have_rect) 
  {
    gegl_rect_copy (have_rect, &self->have_rect); 
  }
  

  /**
   * get_need_rect:
   * @self: a #GeglImage.
   * @need_rect: returned rect.   
   *
   * Gets the region of interest computed during graph evaluation.
   *
   **/ 
  public
  void
  get_need_rect(self, 
                GeglRect *need_rect)
  {
    gegl_rect_copy (need_rect, &self->need_rect);
  }


  /**
   * get_result_rect:
   * @self: a #GeglImage.
   * @result_rect: returned rect.   
   *
   * Gets the result region computed during graph evaluation.
   *
   **/ 
  public
  void
  get_result_rect(self, 
                  GeglRect *result_rect)
  {
    gegl_rect_copy (result_rect, &self->result_rect);
  }


  /**
   * get_cache_rect:
   * @self: a #GeglImage.
   * @cache_rect: returned rect.   
   *
   * Gets the region cached as a result of the #GeglImage operation.
   *
   **/ 
  public
  void
  get_cache_rect(self, 
                 GeglRect *cache_rect)
  {
    gegl_rect_copy (cache_rect, &self->cache_rect);
  }


  /**
   * get_dest:
   * @self: a #GeglImage.
   *
   * Gets the #GeglImage to use as destination output buffer.
   *
   * Returns: A #GeglImage to use for the output 
   **/ 
  public
  GeglImage * 
  get_dest(self)
  {
    return self->_priv->dest;
  }


  /**
   * color_model:
   * @self: a #GeglImage.
   *
   * Gets the color model of this image. This may not be determined, if it has
   * not been set explicitly or derived yet.  
   *
   * Returns: the #GeglColorModel, or NULL. 
   **/ 
  public
  GeglColorModel *
  color_model(self)
  {
    return self->_priv->color_model ? 
           self->_priv->color_model : 
           self->_priv->derived_color_model;
  }


  /**
   * set_color_model:
   * @self: a #GeglImage.
   * @cm: a #GeglColorModel.
   * 
   * Sets the color model explicitly for this image. This takes precedence over
   * derived color models during graph evaluation. Set this when you want to
   * force an image to have a particular color model.
   *
   **/ 
  public
  void
  set_color_model(self,
                  GeglColorModel *cm)
  {
    /* Unref any old one */
    if(self->_priv->color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->color_model));

    /* Set the new color model */
    self->_priv->color_model = cm;
    if(cm)
      gegl_object_ref(GEGL_OBJECT(cm));

    /* Set the derived one to NULL */
    if(self->_priv->derived_color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->derived_color_model));

    self->_priv->derived_color_model = NULL;
  }


  /**
   * set_derived_color_model:
   * @self: a #GeglImage.
   * @cm: the derived #GeglColorModel.
   *
   * Sets a derived #GeglColorModel during graph evaluation. Typically called
   * by subclasses once they determine what their derived color model is.
   *
   **/ 
  protected
  void
  set_derived_color_model(self,
                          GeglColorModel *cm)
  {
    /* Unref any old one */
    if(self->_priv->derived_color_model)
      gegl_object_unref(GEGL_OBJECT(self->_priv->derived_color_model));

    /* Set the new color model */
    self->_priv->derived_color_model = cm;

    if(cm)
      gegl_object_ref(GEGL_OBJECT(cm));
  }


  /**
   * set_need_rect:
   * @self: a #GeglImage.
   * @need_rect: set to this.
   * 
   * Sets the need rect of this image during graph evaluation.
   *
   **/ 
  protected
  void
  set_need_rect(self, 
                GeglRect *need_rect)
  {
    if(need_rect)
      gegl_rect_copy (&self->need_rect, need_rect);
    else
      gegl_rect_set (&self->need_rect, 0,0,G_MAXINT, G_MAXINT);
  }


  /**
   * set_dest:
   * @self: a #GeglImage.
   * @dest: a #GeglImage dest.
   * 
   * Sets the dest image for this image's output.
   *
   **/ 
  protected
  void
  set_dest(self, 
           GeglImage *dest)
  {
    self->_priv->dest = dest;
  }


  /**
   * apply:
   * @self: a #GeglImage.
   * @dest: a destination #GeglImageBuffer for result.
   * @roi: a region of interest.
   *
   * This is the main image processing routine. It evaluates the graph rooted
   * on this image for pixels inside the @roi, and places the result in @dest.
   * @dest may be NULL.
   *
   **/ 
  override(Gegl:Op)
  void
  apply (GeglOp *self_op,
         GeglImageBuffer *dest,
         GeglRect *roi)
  {
    /* Get the singleton image manager. */
    GeglImageManager *image_manager = gegl_image_manager_instance();

    /* Call image manager, which calls the image's processing routines.  */
    gegl_image_manager_apply(image_manager, self_op, dest, roi);
  }


  /**
   * compute_derived_color_model:
   * @self: a #GeglImage
   * @inputs: a #GeglImage list.
   *
   * Computes a derived #GeglColorModel for this image. If the color model is
   * already set explicitly, this routine has no effect.  Otherwise the color
   * model is derived from the inputs' color models. Called by
   * #GeglImageManager during graph evaluation.
   *
   **/
  virtual protected 
  void 
  compute_derived_color_model (self, 
                               GList *inputs)
  {
    /* Only compute this if the color model is still not set */
    if (!color_model(self))
    {

        /* Compute the color alpha space and data type from inputs */
        GeglColorAlphaSpace space = gegl_utils_derived_color_alpha_space(inputs);
        GeglChannelDataType type = gegl_utils_derived_channel_data_type(inputs);

        /* Get a derived color model from the space and type */
        GeglColorModel * derived = gegl_color_model_instance1(space,type);

        /* Set the derived color model. */
        set_derived_color_model (self,derived);

    }

  }


  /**
   * compute_result_rect:
   * @self: a #GeglImage.
   * @inputs: a #GeglImage list.
   *
   * Computes the result_rect of this image based on its need and have rects.
   * Called by #GeglImageManager during graph evaluation. 
   *
   **/ 
  virtual protected void compute_result_rect (self, GList *inputs);


  /**
   * compute_have_rect:
   * @self: a #GeglImage.
   * @inputs: a #GeglImage list.
   *
   * Computes a have_rect of this Image based on the inputs' have_rects.
   *
   **/ 
  virtual protected void compute_have_rect (self, GList *inputs);


  /**
   * compute_cache_rect:
   * @self: a #GeglImage
   * @inputs: a #GeglImage list.
   *
   * Computes a rect that indicates the cached area of the image's result. 
   *
   **/
  virtual protected void compute_cache_rect (self, GList *inputs);


  /**
   * compute_preimage:
   * @self: a #GeglImage.
   * @rect: a rect on the #GeglImage.
   * @preimage: returned preimage rect on ith input. 
   * @i: which input.
   * 
   * Computes the @preimage of @rect on the ith input. This is the inverse map
   * of @rect on the ith input. This routine is used to compute need rects.
   *  
   **/
  virtual protected void compute_preimage (self,
                                           GList *inputs,
                                           GeglRect *rect,
                                           GeglRect *preimage,
                                           gint i);

}
