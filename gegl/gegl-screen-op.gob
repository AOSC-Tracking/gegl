%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-screen-op.h"
#include "gegl-screen-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-object-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Screen:Op from Gegl:Dual:Src:Op {

  public 
  GeglScreenOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src1,
       GeglImageBuffer *src2,       
       GeglRect *dest_rect,
       GeglRect *src1_rect,
       GeglRect *src2_rect)
  {
    GeglScreenOp * self = GEGL_SCREEN_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src1, src2, 
                     dest_rect, src1_rect, src2_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
               GeglImageBuffer *dest,
                    GeglImageBuffer *src1,
              GeglImageBuffer *src2,
              GeglRect *dest_rect,
              GeglRect *src1_rect,
              GeglRect *src2_rect)        
  {
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
        GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_dual_src_op_constructor ( 
           GEGL_DUAL_SRC_OP(self),dest, src1, src2, 
           dest_rect, src1_rect, src2_rect))
      return FALSE;

    {
      point_op_class->scanline_func = gegl_screen_op_RGB_FLOAT;        
    }

    return TRUE;
  }

  private 
  void
  RGB_FLOAT (GeglPointOp *point_op)
  {
    /*
     Whats the algorithm for this code?       
     
     {
       int dest_has_alpha; 
       int src1_has_alpha; 
       int src2_has_alpha; 

       Chan dest;
       Chan src1;
       Chan src2;

       dest = WP - ((WP - src1) * (WP - src2));

       if (dest_has_alpha)
         {
           if (src1_has_alpha && src2_has_alpha)
             dest_a = MIN(src1_a, src2_a);
           else if (src1_has_alpha)
             dest_a = src1_a;
           else if (src2_has_alpha)
             dest_a = src2_a; 
         } 
      }

    */ 
    GeglPointOpPrivate *point_opP = 
        (GeglPointOpPrivate *)(point_op->_priv); 
    GeglDualSrcOp *dual_src_op = GEGL_DUAL_SRC_OP(point_op); 
    GeglDualSrcOpPrivate *dual_src_opP = 
        (GeglDualSrcOpPrivate *)(dual_src_op->_priv); 

    gboolean dest_has_alpha = 
       gegl_color_model_has_alpha(dual_src_opP->dest_cm); 
    gboolean src1_has_alpha = 
       gegl_color_model_has_alpha(dual_src_opP->src1_cm); 
    gboolean src2_has_alpha = 
       gegl_color_model_has_alpha(dual_src_opP->src2_cm); 

    guint width = point_opP->scanline_width;

    gfloat *dest_data[4], *src1_data[4], *src2_data[4]; 
    gfloat *dest_r, *dest_g, *dest_b, *dest_a=NULL;
    gfloat *src1_r, *src1_g, *src1_b, *src1_a=NULL;
    gfloat *src2_r, *src2_g, *src2_b, *src2_a=NULL;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 
    
    dest_r = dest_data[0];
    dest_g = dest_data[1];
    dest_b = dest_data[2];

    src1_r = src1_data[0];
    src1_g = src1_data[1];
    src1_b = src1_data[2];

    src2_r = src2_data[0];
    src2_g = src2_data[1];
    src2_b = src2_data[2];

    if(dest_has_alpha) dest_a = dest_data[3];
    if(src1_has_alpha) src1_a = src1_data[3];
    if(src2_has_alpha) src2_a = src2_data[3];

    while (width--)
    {
      *dest_r++ = 1.0 - ((1.0 - *src1_r) * (1.0 - *src2_r));
      *dest_g++ = 1.0 - ((1.0 - *src1_g) * (1.0 - *src2_g));
      *dest_b++ = 1.0 - ((1.0 - *src1_b) * (1.0 - *src2_b));

      src1_r++;
      src1_g++;
      src1_b++;

      src2_r++;
      src2_g++;
      src2_b++;

      if (dest_has_alpha)
       {
         if (src1_has_alpha && src2_has_alpha)
           {
             *dest_a++ = MIN(*src1_a, *src2_a);
             src1_a++;
             src2_a++;
           }       
         else if (src1_has_alpha)
           *dest_a++ = *src1_a++;
         else if (src2_has_alpha)
           *dest_a++ = *src2_a++; 
       } 
    }               
  }
}
