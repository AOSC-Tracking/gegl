%h{
#include "gegl-image.h"
%}
%{
#include "gegl-op.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-node.h"
#include "gegl-node-private.h"
#include "gegl-utils.h"
#include "trace.h"
%}

class Gegl:Op from Gegl:Image {

  protected GeglPoint *input_offsets;   /* offsets of inputs-relative to this op */ 

  protected 
  gboolean 
  constructor(self, 
              GList *inputs) 
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self),inputs))
      return FALSE;

    {
      gint i;
      gint num_inputs = g_list_length(inputs);

      self->input_offsets = g_new (GeglPoint, num_inputs);

      for (i = 0; i < num_inputs; i++)
      {
        self->input_offsets[i].x = 0;
        self->input_offsets[i].y = 0;
      }	  
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglOp *self = GEGL_OP(object);

    g_free (self->input_offsets);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override(Gegl:Image)
  void
  compute_derived_color_model(GeglImage *self_image)
  {
    /* Only compute this if the color model is not set */
    if (!gegl_image_color_model(self_image))
      {
        GList *inputs = gegl_node_get_inputs(GEGL_NODE(self_image));

        /* Compute the color alpha space and data type from inputs */
        GeglColorAlphaSpace space = gegl_utils_derived_color_alpha_space(inputs);
        GeglChannelDataType type = gegl_utils_derived_channel_data_type(inputs);
        GeglColorModel * derived = gegl_color_model_instance1(space,type);

        /* Set the derived color model. */ 
        gegl_image_set_derived_color_model (self_image,derived);
      }
  }

  public
  void
  set_offset(self, 
             gint x,
             gint y, 
	         gint index)
  {
    self->input_offsets[index].x = x;
    self->input_offsets[index].y = y;
  }
}
