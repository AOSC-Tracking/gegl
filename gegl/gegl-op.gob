%h{
#include "gegl-image.h"
#ifndef __TYPEDEF_GEGL_IMAGE_BUFFER__
#define __TYPEDEF_GEGL_IMAGE_BUFFER__
typedef struct _GeglImageBuffer  GeglImageBuffer;
#endif
%}
%{
#include "gegl-op.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include "trace.h"
%}


class Gegl:Op from Gegl:Image {

  private GeglImage **sources;                /* input sources  (ops or images)*/
  private GeglRect *source_rois;              /* rois of sources  */
  private GeglPoint *source_offsets;          /* offsets of sources-relative to this op */ 
  private gint num_sources; 
  private GeglImageBuffer **input_buffers;    /* actual data buffers for inputs */
  private gboolean *src_has_alpha;            /*Do the sources have alphas*/ 
  private gboolean has_alpha;                 /*Does this op have alpha*/ 

  protected 
  gboolean 
  constructor(self, 
              GeglImage **sources, 
	      gint num_sources)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self)))
      return FALSE;

    {
      gint i;

      self->_priv->sources = g_new(GeglImage*,num_sources);
      self->_priv->input_buffers = g_new(GeglImageBuffer*,num_sources);
      self->_priv->src_has_alpha = g_new(gboolean, num_sources);
      self->_priv->source_rois = g_new (GeglRect, num_sources);
      self->_priv->source_offsets = g_new (GeglPoint, num_sources);
      self->_priv->num_sources = num_sources;

      for (i = 0; i < num_sources; i++)
	{
          self->_priv->sources[i] = sources[i];
          self->_priv->input_buffers[i] = NULL;
          gegl_rect_set (&self->_priv->source_rois[i],0,0,0,0);
	  self->_priv->source_offsets[i].x = 0;
	  self->_priv->source_offsets[i].y = 0;
        }	  
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglOp *self = GEGL_OP(object);

    g_free (self->_priv->sources);
    g_free (self->_priv->source_rois);
    g_free (self->_priv->source_offsets);
    g_free (self->_priv->input_buffers);
    g_free (self->_priv->src_has_alpha);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  /* Get pixels from input(s) and put in dest */
  override (Gegl:Image)
  GeglImage* 
  get_pixels (GeglImage *self, 
              GeglImage *dest, 
	      GeglRect *roi)
  {
    GeglOp *self_op = GEGL_OP (self); 
    GeglRect dest_rect;
    gint i;

#ifdef DEBUG_GET_PIXELS 
    trace_begin("get_pixels %s", gtk_type_name(GTK_OBJECT_TYPE(self)));
#endif

    /* If dest exists but isnt an image buffer return NULL */ 
    if (dest && !GEGL_IS_IMAGE_BUFFER(dest))
       {
	 g_warning("gegl_op_get_pixels: dest not image buffer.\n");
         return NULL; 
       }

    /* Determine all the source rois, from the passed roi */ 
    gegl_op_compute_source_rois (self_op, roi); 

    /* Ready each source input */ 
    for (i = 0; i < self_op->_priv->num_sources; i++)    
      {
#ifdef DEBUG_GET_PIXELS 
        g_print("Calling source %d\n", i);
#endif

        self_op->_priv->input_buffers[i] = GEGL_IMAGE_BUFFER(
	                        gegl_image_get_pixels (
				self_op->_priv->sources[i], 
				NULL, 
				&self_op->_priv->source_rois[i])); 
      }

#ifdef DEBUG_GET_PIXELS 
    g_print("Done with sources\n");
#endif

    /* Set the color model of this op */
    compute_color_model (self_op, dest);

    /* Allocate a temp dest buffer for result if needed */
    if (!dest)
      {
	 /* Allocate the dest (actually it is an ImageBuffer)*/  
         dest = GEGL_IMAGE (gegl_image_buffer_new (
		   self->_priv->color_model, 
		   roi->w,
		   roi->h));

	 if(!dest)
	   {
	     g_warning("gegl_op_get_pixels: Cant allocate temp data\n");
	     return NULL;
	   }

#ifdef DEBUG_GET_PIXELS 
         g_print("Allocated temp buffer %x\n", dest);
#endif
         gegl_rect_set (&dest_rect,0,0,roi->w,roi->h);
      }
    else
      gegl_rect_copy(&dest_rect, roi);

#ifdef DEBUG_GET_PIXELS 
    g_print("Call prepare\n");
#endif
    gegl_op_prepare (self_op,dest,&dest_rect);

    /* Everything is ready, actually do the op */
#ifdef DEBUG_GET_PIXELS 
    g_print("Call apply\n");
#endif
    gegl_op_apply (self_op, dest, &dest_rect); 

    /* Everything is done, free the inputs */
    for (i = 0; i < self_op->_priv->num_sources; i++)    
      {
	/* Free any input data */ 
        if (!GEGL_IS_IMAGE_BUFFER(self_op->_priv->sources[i]))
	  {
#ifdef DEBUG_GET_PIXELS 
            g_print("freeing input %d at %x\n", 
	      i, self_op->_priv->input_buffers[i]);
#endif
            gegl_object_destroy(GEGL_OBJECT(
		self_op->_priv->input_buffers[i]));
	  }
      }

#ifdef DEBUG_GET_PIXELS 
    trace_end();
#endif
    return dest;
  }

  private 
  void
  compute_color_model(self, 
                      GeglImage *dest)
  {
    GeglImage * image = GEGL_IMAGE(self);

    /* If there is a dest, take the colormodel from that */
    if (dest != NULL)
      image->_priv->color_model = gegl_image_color_model (dest); 

    /* Otherwise, try to take it from an input */
    if (!image->_priv->color_model) 
      if (self->_priv->num_sources)
        image->_priv->color_model = gegl_image_color_model(
	                        self->_priv->sources[0]); 

    if (!image->_priv->color_model)
      g_warning("gegl_op_find_color_model: color_model is NULL\n");
  }

  protected 
  void  
  save_alphas(self)
  {
    GeglImage *self_image = GEGL_IMAGE(self);
    GeglColorModel *src_cm;
    GeglColorModel *dest_cm;
    gint i;

    for (i = 0; i < self->_priv->num_sources; i++)
      {
        src_cm = gegl_image_color_model (self->_priv->sources[i]);
        self->_priv->src_has_alpha[i] = gegl_color_model_has_alpha (src_cm); 
      }

    dest_cm = self_image->_priv->color_model; 
    self->_priv->has_alpha = gegl_color_model_has_alpha (dest_cm); 
  }

  public
  void
  set_offset(self, 
             int x,
             int y, 
	     int index)
  {
    self->_priv->source_offsets[index].x = x;
    self->_priv->source_offsets[index].y = y;
  }

  /* routines subclasses may need to implement */
  virtual protected void compute_source_rois (self, GeglRect *roi); 
  virtual protected void prepare (self, GeglImage *dest, GeglRect *dest_rect);
  virtual protected void apply (self, GeglImage *dest, GeglRect *dest_rect);
}
