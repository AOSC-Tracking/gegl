%h{
#include "gegl-image.h"
#ifndef __TYPEDEF_GEGL_IMAGE_BUFFER__
#define __TYPEDEF_GEGL_IMAGE_BUFFER__
typedef struct _GeglImageBuffer  GeglImageBuffer;
#endif
%}
%{
#include "gegl-op.h"
#include "gegl-op-private.h"
#include "gegl-image-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include "trace.h"
%}


class Gegl:Op from Gegl:Image {

  private GeglImage **sources;       /* input sources  (ops or images)*/
  private GeglPoint *source_offsets; /* offsets of sources-relative to this op */ 
  private gint num_sources; 
  private gboolean *src_has_alpha;
  private gboolean has_alpha;

  private GeglRect need_rect;         /*roi info passed down from root */
  private GeglRect result_rect;       /*result - based on needRect,haveRect */

  protected 
  gboolean 
  constructor(self, 
              GeglImage **sources, 
	      gint num_sources)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
       
    /* Chain up */
    if (!gegl_image_constructor (GEGL_IMAGE(self)))
      return FALSE;

    {
      gint i;

      self->_priv->sources = g_new(GeglImage*,num_sources);
      self->_priv->src_has_alpha = g_new(gboolean, num_sources);
      self->_priv->source_offsets = g_new (GeglPoint, num_sources);
      self->_priv->num_sources = num_sources;
      gegl_rect_set (&self->_priv->need_rect,0,0,0,0);
      gegl_rect_set (&self->_priv->result_rect,0,0,0,0);

      for (i = 0; i < num_sources; i++)
	{
          self->_priv->sources[i] = sources[i];
	  self->_priv->source_offsets[i].x = 0;
	  self->_priv->source_offsets[i].y = 0;
        }	  
    }

    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    GeglOp *self = GEGL_OP(object);

    g_free (self->_priv->sources);
    g_free (self->_priv->source_offsets);
    g_free (self->_priv->src_has_alpha);

    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  override (Gegl:Image)
  GeglImage* 
  get_pixels (GeglImage *self, 
              GeglImage *dest, 
	      GeglRect *roi)
  {
    GeglOp *self_op = GEGL_OP (self); 
    gint i;

#ifdef DEBUG_GET_PIXELS 
    trace_begin("get_pixels %s", gtk_type_name(GTK_OBJECT_TYPE(self)));
#endif

    /* If dest exists but isnt an image buffer return NULL */ 
    if (dest && !GEGL_IS_IMAGE_BUFFER(dest))
      {
	 g_warning("gegl_op_get_pixels: dest not image buffer.\n");
         return NULL; 
      }

    /* The roi becomes our need_rect */
    gegl_rect_copy (&self_op->_priv->need_rect, roi); 

    /* Ready each source input */ 
    for (i = 0; i < self_op->_priv->num_sources; i++)    
      {
	GeglRect need_rect;

	/* Compute the need_rect of the ith input */
	compute_need_rect (self_op, &need_rect, i);

#ifdef DEBUG_GET_PIXELS 
        g_print("Calling source %d\n", i);
#endif
	
	/* Call the input's get_pixels, pass it its need_rect */
        gegl_image_get_pixels (self_op->_priv->sources[i], 
	    NULL, &need_rect); 
      }

#ifdef DEBUG_GET_PIXELS 
    g_print("Done with sources\n");
#endif

    /* Set the color model of this op */
    compute_color_model (self_op, dest);

    /* Compute the have rect and result rect */
    compute_have_rect (self_op);
    compute_result_rect (self_op);

    /* Allocate a buffer for result if necessary */
    if (!dest)
      {
	 gint w = self_op->_priv->result_rect.w;
	 gint h = self_op->_priv->result_rect.h;

	 if(!gegl_image_alloc (self, w, h))
	   {
	     g_warning("gegl_op_get_pixels: Cant allocate dest data\n");
	     return NULL;
	   }

	 dest = self;

#ifdef DEBUG_GET_PIXELS 
         g_print("Allocated dest buffer size: %d, %d \n", w, h);
#endif
      }

#ifdef DEBUG_GET_PIXELS 
    g_print("Call prepare\n");
#endif
    prepare (self_op,dest,&self_op->_priv->result_rect);

    /* Everything is ready, actually do the op */
#ifdef DEBUG_GET_PIXELS 
    g_print("Call apply\n");
#endif
    apply (self_op, dest, &self_op->_priv->result_rect); 

    /* Everything is done, free the inputs */
    for (i = 0; i < self_op->_priv->num_sources; i++)    
      {
	/* Free any input data */ 
        if (!GEGL_IS_IMAGE_BUFFER(self_op->_priv->sources[i]))
	  {
#ifdef DEBUG_GET_PIXELS 
            g_print("freeing input %d \n", i); 
#endif
            gegl_image_free_data(self_op->_priv->sources[i]);
	  }
      }

#ifdef DEBUG_GET_PIXELS 
    trace_end();
#endif
    return dest;
  }

  private 
  void
  compute_color_model(self, 
                      GeglImage *dest)
  {
    GeglImage * image = GEGL_IMAGE(self);

    /* If there is a dest, take the colormodel from that */
    if (dest != NULL)
      image->_priv->color_model = gegl_image_color_model (dest); 

    /* Otherwise, try to take it from an input */
    if (!image->_priv->color_model) 
      if (self->_priv->num_sources)
        image->_priv->color_model = gegl_image_color_model(
	                        self->_priv->sources[0]); 

    if (!image->_priv->color_model)
      g_warning("gegl_op_find_color_model: color_model is NULL\n");
  }

  protected 
  void  
  save_alphas(self)
  {
    GeglImage *self_image = GEGL_IMAGE(self);
    GeglColorModel *src_cm;
    GeglColorModel *dest_cm;
    gint i;

    for (i = 0; i < self->_priv->num_sources; i++)
      {
        src_cm = gegl_image_color_model (self->_priv->sources[i]);
        self->_priv->src_has_alpha[i] = gegl_color_model_has_alpha (src_cm); 
      }

    dest_cm = self_image->_priv->color_model; 
    self->_priv->has_alpha = gegl_color_model_has_alpha (dest_cm); 
  }

  public
  void
  set_offset(self, 
             int x,
             int y, 
	     int index)
  {
    self->_priv->source_offsets[index].x = x;
    self->_priv->source_offsets[index].y = y;
  }

  virtual protected void prepare (self, GeglImage *dest, GeglRect *result_rect);
  virtual protected void apply (self, GeglImage *dest, GeglRect *result_rect);
  virtual protected void compute_have_rect (self); 
  virtual protected void compute_need_rect (self, GeglRect *need_rect, gint index); 
  virtual protected void compute_result_rect (self); 
}
