#!/usr/bin/perl

# Copyright 2000-2001 Jay Cox <jaycox@gimp.org>

# this code may be used under the terms of the GPL

package Gegl::Op;


sub new
  {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    $class = Gegl::Op unless $class;
    my $op = {};
#    my $op = shift;
 #   my $type = ref($op) || $op;
    my $i;
    # Initialize the data members to help with debugging
    foreach $i (qw/name arguments language description author copyright license filename parent_class/)
      {
	$op->{$i} = "  Gegl::Op->\{$i\} not set.  ";
      }
    return bless $op, $class;
  }

# Only call this function after parsing the xml
# setup the following fields in an op:
#    class_name
#    class_cast
#    argnames[]
#    numargs
#    constructor_args
#    argnames[]

sub setup
  {
    my $op = shift;

    my (@args)      = split /,/, $op->{arguments};

    if (${op}->{libraries})
      {
	print "Warning:  libraries setting not implemented\n";
      }

    $op->{class_name} = "Gegl$op->{name}Op";

    $op->{class_cast} = "GEGL_" . uc($op->{name}) . "_OP";
    @{$op->{argnames}} = [];
    @{$op->{buffer_args}} = ();
    $op->{numargs} = @args + 0;

    my ($i, $j) = (0,0);
    foreach (@args) # get the argument names without type qualifiers
      {
	${op}->{argnames}[$i] = (reverse (split /\s+/, $_))[0];
	if ((grep "Buffer ", $_)) # store the names of all buffers
	  {
	    push @{$op->{buffer_args}}, ${op}->{argnames}[$i];
	  }
	if ($i == 0)
	  {
	    $op->{constructor_args} = ${op}->{argnames}[$i];
	  }
	else
	  {
	    $op->{constructor_args} = $op->{constructor_args} . ", " . ${op}->{argnames}[$i];
	  }
	  $i++;
      };

  }


# Print out the entire class;
sub print_class
  {
    my $op = shift;

    die "Sorry, I don't know how to code in $op->{language} yet." unless ($op->{language} eq "c");

    $op->setup();
    $op->print_headers();
    print "class Gegl:$op->{name}:op from $op->{parent_class}\n";
    print "{\n\n";
    $op->print_variables();
    $op->print_new();
    $op->print_constructor();
    $op->print_class_init();
    $op->print_prepare();
    $op->print_class_specific();
# print tail end junk
  }



sub print_headers
  {
# move some of these headers into derived classes
    my $op = shift;
    print <<HERE;
/*
 *  This is file was generated by xqlgen from $op->{filename}
 *  DO NOT EDIT!!
 */
%h{
#include "gegl-n-src-op.h"
%}
%{
#include "gegl-n-src-op.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>

%}
HERE
}


sub print_variables
  {
    my $op = shift;
    print "Gegl::Op->print_variables() ::: Unimplemented";
  }

sub print_new
  {
    my $op = shift;
    print <<HERE
  public $op->{class_name} * new ($op->{arguments})
  {
    $op->{class_name} * self = $op->{class_cast}(GET_NEW);

    if (!constructor(self, $op->{constructor_args}))
      return NULL;

    GEGL_OBJECT(self)->constructed = TRUE;

     /* ref and sink it */
    gegl_object_ref(GEGL_OBJECT(self));
    gtk_object_sink(GTK_OBJECT(self));

   return self;
  }

HERE
  }



sub print_constructor
  {
    my $op = shift;
    print "Gegl::Op->print_constructor() ::: Unimplemented";
  }

sub print_class_init
  {
# This function is optional so we silently return
  }

sub print_prepare
  {
    my $op = shift;
    print "Gegl::Op->print_prepare() ::: Unimplemented";
  }

sub print_class_specific
  {
# This function is optional so we silently return
  }


1;  # package return code
