%h{
#include "gegl-point-op.h"
%}
%{
#include <stdio.h>
#include "gegl-print-op.h"
#include "gegl-print-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-iterator.h"
#include "gegl-image-buffer.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
%}

class Gegl:Print:Op from Gegl:Point:Op {

  public 
  GeglPrintOp *
  new (GeglImageBuffer *dest, 
       GeglRectangle *dest_rect
       )
  {
    GeglPrintOp * self = GEGL_PRINT_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, dest_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest, 
              GeglRectangle *dest_rect)
  {
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
      GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    

    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_point_op_constructor (
          GEGL_POINT_OP(self), 
          &dest, dest_rect, 1))
      return FALSE;

    /*
      Now based on the image buffer color model(s)/data storage
      choose one of our scanline funcs to install
      This is where some "autogeneration" happens.
    */ 

    {
      GeglColorModel *cm;
      GeglColorSpace color_space;
      GeglChannelDataType data_type;
      cm = gegl_image_buffer_color_model (dest);
      data_type = gegl_color_model_data_type (cm);
      color_space = gegl_color_model_color_space (cm);

      switch (color_space)
       {
       case GEGL_GRAY:
         switch (data_type)
           {
           case GEGL_U8:
             point_op_class->scanline_func = gegl_print_op_GRAY_U8;
             break;
           case GEGL_FLOAT:
             point_op_class->scanline_func = gegl_print_op_GRAY_FLOAT;        
             break;
           default:
             g_warning("PrintOp: Color Model data type none or unknown\n");
             point_op_class->scanline_func = NULL;        
             return FALSE;
           } 
         break;
       case GEGL_RGB:
         switch (data_type)
           {
           case GEGL_U8:
             point_op_class->scanline_func = gegl_print_op_RGB_U8;
             break;
           case GEGL_FLOAT:
             point_op_class->scanline_func = gegl_print_op_RGB_FLOAT;        
             break;
           default:
             g_warning("PrintOp: Color Model data type none or unknown\n");
             point_op_class->scanline_func = NULL;        
             return FALSE;
           } 
         break;
       default:
         g_warning("PrintOp: Color Model data type none or unknown\n");
         point_op_class->scanline_func = NULL;        
         return FALSE;
       } 
    }

    return TRUE;
  }

  private
  void
  COLORSPACE_DATATYPE (GeglPointOp *point_op)
  {
     /*
        Whats the algorithm for this code?
        PRINT DEST

     */

    GENERIC_IMAGE_DECL_BEGIN
    Pixel src(color,alpha,has_alpha);
    GENERIC_IMAGE_DECL_END
    guint width;

    GeglPointOpPrivate *point_opP =
        (GeglPointOpPrivate *)(point_op->_priv);

    width = point_opP->scanline_width;

    /* image_buffers[0] is the dest here */
    gegl_image_iterator_get_scanline_data (point_opP->iterators[0],
                                        (guchar**)channels);

    /* Make r,g,b point to the dest image data */
    GENERIC_IMAGE_IMAGE_DATA_INIT
    
    while (width--)
      {
	GENERIC_IMAGE_CODE_BEGIN
	PRINT (src); 
        GENERIC_IMAGE_CODE_END
 	printf("\n");
      }

  }
}
