%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-diff-op.h"
#include "gegl-diff-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-object-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h>
%}


class Gegl:Diff:Op from Gegl:Dual:Src:Op {

  public 
  GeglDiffOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src1,
       GeglImageBuffer *src2,       
       GeglRect *dest_rect,
       GeglRect *src1_rect,
       GeglRect *src2_rect)
  {
    GeglDiffOp * self = GEGL_DIFF_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src1, src2, 
                     dest_rect, src1_rect, src2_rect))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest,
              GeglImageBuffer *src1,
              GeglImageBuffer *src2,
              GeglRect *dest_rect,
              GeglRect *src1_rect,
              GeglRect *src2_rect)        
  {
    GeglPointOp *point_op = GEGL_POINT_OP (self);
    GeglPointOpClass *point_op_class = 
        GEGL_POINT_OP_CLASS(GTK_OBJECT(point_op)->klass);
    
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;
    
    /* Chain up */
    if (!gegl_dual_src_op_constructor ( 
           GEGL_DUAL_SRC_OP(self),dest, src1, src2, 
           dest_rect, src1_rect, src2_rect))
      return FALSE;

    {
      /* codegen preprocessor puts in "switch" on color_models file  */ 

      point_op_class->scanline_func = 
        gegl_diff_op_scanline_COLORSPACE_DATATYPE;        
    }

    return TRUE;
  }

  private 
  void
  scanline_COLORSPACE_DATATYPE (GeglPointOp *point_op)
  {
    GeglPointOpPrivate *point_opP = 
        (GeglPointOpPrivate *)(point_op->_priv); 
    GeglDualSrcOp *dual_src_op = GEGL_DUAL_SRC_OP(point_op); 
    GeglDualSrcOpPrivate *dual_src_opP = 
        (GeglDualSrcOpPrivate *)(dual_src_op->_priv); 

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha,has_alpha);
    Pixel src1(color,alpha,has_alpha);
    Pixel src2(color,alpha,has_alpha);
    GENERIC_IMAGE_DECL_END
    gint width = point_opP->scanline_width;

    dest_has_alpha = gegl_color_model_has_alpha(
                       dual_src_opP->dest_cm); 
    src1_has_alpha = gegl_color_model_has_alpha(
                       dual_src_opP->src1_cm); 
    src2_has_alpha = gegl_color_model_has_alpha(
                       dual_src_opP->src2_cm); 

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 
    
    GENERIC_IMAGE_IMAGE_DATA_INIT
      
    while (width--)
      {
        GENERIC_IMAGE_BLOCK_BEGIN  

	dest_color = ABS(src1_color - src2_color);

	if (dest_has_alpha)
	  {
	    if (src1_has_alpha && src2_has_alpha)
	      {
		dest_alpha = MIN(src1_alpha, src2_alpha);
	      }       
	    else if (src1_has_alpha)
	      {
		dest_alpha = src1_alpha;
	      }
	    else if (src2_has_alpha)
	      {
		dest_alpha = src2_alpha; 
	      }
	  }

	dX(dest,1);
	dX(src1,1);
	dX(src2,1);  

        GENERIC_IMAGE_BLOCK_END
      }               
  }
}
