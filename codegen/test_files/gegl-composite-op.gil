%h{
#include "gegl-dual-src-op.h"
%}
%{
#include "gegl-composite-op.h"
#include "gegl-composite-op-private.h"
#include "gegl-dual-src-op-private.h"
#include "gegl-point-op-private.h"
#include "gegl-op-private.h"
#include "gegl-image-buffer.h"
#include "gegl-image-iterator.h"
#include "gegl-color-model.h"
#include "gegl-utils.h"
#include <stdio.h> 
%}

class Gegl:Composite:Op from Gegl:Dual:Src:Op {

  private GeglCompositeMode        comp_mode;

  public 
  GeglCompositeOp *
  new (GeglImageBuffer *dest, 
       GeglImageBuffer *src1,
       GeglImageBuffer *src2,       
       GeglRect *dest_rect,
       GeglRect *src1_rect,
       GeglRect *src2_rect,
       GeglCompositeMode mode)
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP(GET_NEW);

    /*Call the constructor */
    if (!constructor(self, dest, src1, src2, 
                     dest_rect, src1_rect, src2_rect, mode))
      return NULL;
    
    /*Okay its constructed*/
    GEGL_OBJECT(self)->constructed = TRUE;

    return self;
  }

  protected 
  gboolean 
  constructor(self, 
              GeglImageBuffer *dest, 
              GeglImageBuffer *src1,
              GeglImageBuffer *src2,       
              GeglRect *dest_rect,
              GeglRect *src1_rect,
              GeglRect *src2_rect,
              GeglCompositeMode mode)
  {
    if(GEGL_OBJECT(self)->constructed) 
      return FALSE;

    /* Chain up */
    if (!gegl_dual_src_op_constructor ( 
           GEGL_DUAL_SRC_OP(self),dest, src1, src2, 
           dest_rect, src1_rect, src2_rect))
      return FALSE;

    {
      GeglPointOpClass *point_op_class = 
        GEGL_POINT_OP_CLASS(GTK_OBJECT(self)->klass);

      GeglColorModel     *src1_cm, *src2_cm;
      gboolean            src1_has_alpha, src2_has_alpha;
       
      src1_cm = gegl_image_buffer_color_model (src1);
      src1_has_alpha = gegl_color_model_has_alpha (src1_cm);

      src2_cm = gegl_image_buffer_color_model (src2);
      src2_has_alpha = gegl_color_model_has_alpha (src2_cm);

      /* dest = src2 op src1 */
      if ( src2_has_alpha && src1_has_alpha)
        point_op_class->scanline_func = 
               gegl_composite_op_COLORSPACEa_op_COLORPSPACEa_DATATYPE;
      else if ( src2_has_alpha && !src1_has_alpha )
        point_op_class->scanline_func = 
               gegl_composite_op_COLORSPACEa_op_COLORSPACE_DATATYPE;
      else if ( !src2_has_alpha && src1_has_alpha )
        point_op_class->scanline_func = 
               gegl_composite_op_COLORSPACE_op_COLORSPACEa_DATATYPE;
      else if ( !src2_has_alpha && !src1_has_alpha )
        point_op_class->scanline_func = 
               gegl_composite_op_COLORSPACE_op_COLORSPACE_DATATYPE;

      self->_priv->comp_mode = mode;
    }
    return TRUE;
  }

  override (Gtk:Object) 
  void 
  destroy (GtkObject *object)
  {
    /* Chain up on destroy */
    PARENT_HANDLER (object)
  }

  GENERIC_IMAGE_PROGRAM colormodels_file
  private 
  void
  COLORSPACEa_op_COLORSPACEa_DATATYPE (GeglPointOp *point_op)
  GENERIC_IMAGE_CODEGEN_BEGIN
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha);
    Pixel src1(color,alpha);
    Pixel src2(color,alpha);
    Channel a, b, c, alpha;
    GENERIC_IMAGE_DECL_END
    gint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            dest_color = src2_color;
            dest_alpha = WP;

            dX(dest,1);
            dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      case COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            a = (WP - src2_alpha) * src1_alpha;
            b = src2_alpha;
            alpha = a + b;

            dest_alpha = alpha;

            if (alpha)
              {
                c = WP / alpha;
                dest_color = (a * src1_color * WP + b * src2_color * WP) * c * WP;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      case COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            alpha = src1_alpha * src2_alpha;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      case COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            alpha = (WP - src1_alpha) * src2_alpha;

            dest_alpha = alpha;

            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      case COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            a = WP - src2_alpha;
            b = src2_alpha;
            alpha = src1_alpha;

            dest_a = alpha;

            if (alpha)
              {
                dest_color = a * src1_color + b * src2_color * WP;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      case COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN

            a = (WP - src2_alpha) * src1_alpha;
            b = (WP - src1_alpha) * src2_alpha;
            alpha = a + b;

            dest_alpha = alpha;

            if (alpha)
              {
                c = 1.0 / alpha;
                dest_color = (a * src1_color * WP + b * src2_color * WP) * c * WP;
              }
            else 
              {
               dest_color = src1_color;

              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END
          }
        break;
      default:
        break;
      }
  }
  GENERIC_IMAGE_CODEGEN_END
 
  GENERIC_IMAGE_PROGRAM colormodels_file
  private 
  void
  COLORSPACEa_op_COLORSPACE_DATATYPE (GeglPointOp *point_op)
  GENERIC_IMAGE_CODEGEN_BEGIN
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color);
    Pixel src1(color);
    Pixel src2(color,alpha);
    Channel a, b, alpha;
    GENERIC_IMAGE_DECL_END
    gint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

       	    dest_color = src2_color;

	    dX(dest,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
	  }
        break;
      case COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            a = (WP - src2_alpha);
            b = src2_alpha;
            dest_color = (a * src1_color * WP + b * src2_color * WP);

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            alpha = src2_alpha;
            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            dest_color = src1_color;

	    dX(dest,1);
	    dX(src1,1);

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            a = WP - src2_alpha;
            b = src2_alpha;
            dest_color = a * src1_color + b * src2_color * WP;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
       break;
      case COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            dest_color = src1_color;

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      default:
        break;
      }
  }

  GENERIC_IMAGE_PROGRAM colormodels_file
  private 
  void
  COLORSPACE_op_COLORSPACEa_DATATYPE (GeglPointOp *point_op)
  GENERIC_IMAGE_CODEGEN_BEGIN
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)(point_op->_priv); 

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color,alpha);
    Pixel src1(color,alpha);
    Pixel src2(color);
    Channel b, alpha;
    GENERIC_IMAGE_DECL_END 
    gint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    GENERIC_IMAGE_IMAGE_DATA_INIT
      
    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            dest_color = src2_color;
            dest_alpha = WP;

	    dX(dest,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_OVER:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            dest_color = src2_color;
            dest_alpha = WP;

	    dX(dest,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_IN:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            alpha = src1_alpha;
            dest_alpha = alpha;
            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
       break;
      case COMPOSITE_OUT:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            alpha = (WP - src1_alpha);
            dest_alpha = alpha;
            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
               dest_color = src1_color;
              }

       	    dX(dest,1);
            dX(src1,1);
            dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      case COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            alpha = src1_alpha;
            dest_alpha = alpha;
	    if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1);

            GENERIC_IMAGE_BLOCK_END 
          }
       break;
      case COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            b = (WP - src1_alpha);
            alpha = b;
            dest_a = alpha;
            if (alpha)
              {
                dest_color = src2_color;
              }
            else 
              {
                dest_color = src1_color;
              }

	    dX(dest,1);
	    dX(src1,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      default:
        break;
      }
  }
  GENERIC_IMAGE_CODEGEN_END

  GENERIC_IMAGE_PROGRAM colormodels_file
  private 
  void
  COLORSPACE_op_COLORSPACE_DATATYPE (GeglPointOp *point_op)
  GENERIC_IMAGE_CODEGEN_BEGIN
  {
    GeglCompositeOp * self = GEGL_COMPOSITE_OP (point_op);
    GeglPointOpPrivate *point_opP = (GeglPointOpPrivate *)
                                    (point_op->_priv); 

    GENERIC_IMAGE_DECL_BEGIN
    Pixel dest(color);
    Pixel src1(color);
    Pixel src2(color);
    GENERIC_IMAGE_DECL_END 
    gint width = point_opP->scanline_width;

    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[0], 
                      (guchar**)dest_data);
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[1],
                      (guchar**)src1_data); 
    gegl_image_iterator_get_scanline_data ( 
                      point_opP->iterators[2],
                      (guchar**)src2_data); 

    GENERIC_IMAGE_IMAGE_DATA_INIT

    switch(self->_priv->comp_mode)
      {
      case COMPOSITE_REPLACE:
      case COMPOSITE_OVER:
      case COMPOSITE_IN:
      case COMPOSITE_ATOP:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

	    dest = src2;

	    dX(dest,1);
	    dX(src2,1); 

            GENERIC_IMAGE_BLOCK_END 
       	  }
        break;
      case COMPOSITE_OUT:
      case COMPOSITE_XOR:
        while (width--)
          {
            GENERIC_IMAGE_BLOCK_BEGIN 

            dest = src1;

	    dX(dest,1);
	    dX(src1,1); 

            GENERIC_IMAGE_BLOCK_END 
          }
        break;
      default:
        break;
      }
  }
  GENERIC_IMAGE_CODEGEN_END
}
