<!-- ##### SECTION Title ##### -->
GeglGraph

<!-- ##### SECTION Short_Description ##### -->
Container for ops.

<!-- ##### SECTION Long_Description ##### -->
<refsect2 id="overview">
<title>Overview</title>
<para>
The Graph object is a container for ops. It allows grouping ops together to be
treated as a single op. This is the typical way to put together a sequence of
ops you want to reuse. <xref linkend="graph"/> shows a Graph which contains 4
ops. It has two inputs and one output.  
<figure id="graph">
<title>A Graph of Ops</title>
<graphic fileref="graph.png"></graphic>
</figure>
</para>
<para>
The Graph is specified by giving the root node, which can be set with
gegl_graph_set_root(). This is C in <xref linkend="graph"/>
above.  It provides the output of the Graph.  Any inputs of nodes in the
interior of a Graph which have no sources provide inputs to the Graph. So the
input of A provides the Graph's first input, and the input
of D is the Graph's second input.
</para>
<para>
Since a Graph is not a #GeglOperation, it does not have an evaluate method.
During evaluation, the #GeglEvalMgr handles this by instead calling evaluate on
each #GeglOperation in the interior of the Graph when it encounters one.  When it
comes to evaluating a Node like A or D in
<xref linkend="graph"/> it must somehow provide an input for these nodes from
the exterior of the Graph. It does this using gegl_graph_find_source(), which
works as shown in <xref linkend="graphsource"/>. Here E will
be the source found for use as an input for D.
<figure id="graphsource">
<title>A Graph source</title>
<graphic fileref="graphsource.png"></graphic>
</figure>
</para>
<para>
<xref linkend="graphsetup"/> shows setting up a Graph by
passing a root. Here the root for the Graph is <literal>fade1</literal>. 
<example id="graphsetup"> 
<title> Setting up a Graph with a root.</title>
<programlisting>
  /* 
     fade2       fade2        (.025,.05,.075)
       |           |                | 
    --------     graph        --------------  
   | fade1 |                  |(.05,.1,.15)|        
   |   |   |                  |     |      | 
   | color |                  | (.1,.2,.3) |
   ---------                  ------------- 
  */ 

  GeglOp * color = g_object_new (GEGL_TYPE_COLOR, 
                                 "pixel-rgb-float", .1, .2, .3, 
                                 NULL); 

  GeglOp * fade1 = g_object_new (GEGL_TYPE_FADE,
                                 "source", color,
                                 "multiplier", .5,
                                 NULL); 

  GeglOp * graph = g_object_new (GEGL_TYPE_GRAPH,
                                 "root", fade1, 
                                 NULL);

  GeglOp * fade2 = g_object_new (GEGL_TYPE_FADE,
                                 "multiplier", .5,
                                 "source", graph,
                                 NULL); 
                        

  gegl_op_apply(fade2); 

  g_object_unref(fade2);
  g_object_unref(graph);
  g_object_unref(fade1);
  g_object_unref(color);
</programlisting>
</example>
</para>
</refsect2>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### SECTION Stability_Level ##### -->


<!-- ##### STRUCT GeglGraph ##### -->
<para>

</para>


<!-- ##### STRUCT GeglGraphClass ##### -->
<para>

</para>

@parent_class: 

<!-- ##### FUNCTION gegl_graph_add_child ##### -->
<para>

</para>

@self: 
@child: 
@Returns: 


<!-- ##### FUNCTION gegl_graph_remove_child ##### -->
<para>

</para>

@self: 
@child: 
@Returns: 


<!-- ##### FUNCTION gegl_graph_get_nth_child ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 


<!-- ##### FUNCTION gegl_graph_get_children ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_graph_remove_children ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_graph_get_num_children ##### -->
<para>

</para>

@self: 
@Returns: 


