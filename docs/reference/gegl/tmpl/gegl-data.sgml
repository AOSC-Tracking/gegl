<!-- ##### SECTION Title ##### -->
GeglData

<!-- ##### SECTION Short_Description ##### -->
Abstract data class

<!-- ##### SECTION Long_Description ##### -->
<refsect2 id="dataproperties">
<title>Overview</title>
<para>
#GeglData objects describe the data that passes through a graph in Gegl. This
data is passed from op to op, with outputs becoming inputs and each op doing
its part by transforming inputs into outputs during its operation. Common examples
of data that can be passed along a graph include images, pixels, channels, and
scalars. The subclasses of #GeglData that correspond to these are
#GeglImageData, #GeglPixelData, #GeglChannelData, and #GeglScalarData
respectively.  Typically an Op will have one output, a #GeglImageData and one
or more inputs of various kinds. However, some ops may produce more than one
output. For example an op that breaks an RGB image into separate R, G, and B
planes would have 3 #GeglImageData outputs (one for each plane) and a single
#GeglImageData input (the RGB image).
</para>
<para>
Each Data object contains three important parts:
<itemizedlist>
  <listitem>
    <para>
     <emphasis> Name and type of data </emphasis> &mdash; 
     The name of the input or output this data is for and whether it  is an
     image, pixel, scalar, string, etc.
     </para>
  </listitem>
  <listitem>
    <para>
     <emphasis> The value of the data </emphasis>&mdash; a #GValue which holds 
     the actual data. 
     </para>
  </listitem>
  <listitem>
    <para>
     <emphasis> Attributes passed with the data </emphasis>. &mdash; These are 
     attributes specific to the type of data that need to be passed along the 
     graph. For image data this includes need and have rects, color model, 
     image masks.
     </para>
  </listitem>
</itemizedlist>
</para>
<para>
The value of the data is stored in the <literal>value</literal> field
of #GeglData. This is a glib #GValue. So basically a #GeglData object is 
a wrapper for a #GValue, with some additions. Gegl uses standard #GValue 
mechanisms to set up conversions between the value fields of different 
data objects.
</para>
<para>
#GeglData objects are stored in the #GeglOp's arrays of input and
output data, each one added by the #GeglOp object during 
its init() methods. This is described below in <link linkend="datasetup">section</link> 
below showing how #GeglOp set up input and output data. 
</para>
</refsect2>

<refsect2 id="datasetup">
<title>Adding Data</title>
<para>
During initialization (the object's various init() methods) each Op must add 
the #GeglData objects that will hold values for inputs and outputs. This happens
in gegl_op_add_input_data() and gegl_op_add_output_data(). Each of these add
a data element of the appropriate kind to either 
<literal>input_data_array</literal> or <literal>output_data_array</literal>
fields of #GeglOp.  For example, consider the #GeglFade op. It is a subclass of 
both #GeglImageOp and #GeglUnary. Let's follow the various object init() calls of 
#GeglFade and its superclasses when a new #GeglFade object is created. 
</para>
<para>
First g_object_new is called: 
<programlisting>
GeglOp * fade = g_object_new(GEGL_TYPE_FADE,
                             "multiplier", .5,
                             NULL);
</programlisting>
During this call the various object init() methods are called for all the
superclasses of #GeglFade starting with #GeglObject first and then in each
subclass down the class heirarchy until #GeglFade. The first we need to worry
about is #GeglImageOp: 
<programlisting>
static void 
init (GeglImageOp * self, 
      GeglImageOpClass * klass)
{
  /* Add an image output */
  gegl_op_add_output_data(GEGL_OP(self), GEGL_TYPE_IMAGE_DATA, "dest");

  /* Other initialization code */
}
</programlisting>
This code adds the "dest" image data, which holds the output image. 
The next one that concerns us is #GeglUnary init(). Here we see the
"source" image data added: 
<programlisting>
static void 
init (GeglUnary * self, 
      GeglUnaryClass * klass)
{
  /* Add an image input */
  gegl_op_append_input(GEGL_OP(self), GEGL_TYPE_IMAGE_DATA, "source");
}
</programlisting>
Finally the #GeglFade object init() adds the data input "multiplier", which
is a scalar:
<programlisting>
static void 
init (GeglFade * self, 
      GeglFadeClass * klass)
{
  /* Add the multiplier input. */
  gegl_op_append_input(GEGL_OP(self), GEGL_TYPE_SCALAR_DATA, "multiplier");

  /* Other initialization code */
}
</programlisting>
Once we are done, we have added one image output and two inputs, one an image
and the other a scalar. This describes all the data outputs and inputs for the
#GeglFade completely.
</para>
</refsect2>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### STRUCT GeglData ##### -->
<para>

</para>


<!-- ##### STRUCT GeglDataClass ##### -->
<para>

</para>

@object_class: 

<!-- ##### FUNCTION gegl_data_get_value ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_data_copy_value ##### -->
<para>

</para>

@self: 
@value: 


<!-- ##### FUNCTION gegl_data_set_name ##### -->
<para>

</para>

@self: 
@name: 


<!-- ##### FUNCTION gegl_data_get_name ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### ARG GeglData:data-name ##### -->
<para>

</para>

