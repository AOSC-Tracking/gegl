<!-- ##### SECTION Title ##### -->
GeglImageMgr

<!-- ##### SECTION Short_Description ##### -->


<!-- ##### SECTION Long_Description ##### -->
<para>
This class handles details of computing the graph. When the root Op's apply
method is called, it retrieves the singleton ImageMgr instance and calls the
ImageMgr's apply routine, passing itself along as the root of the graph to
evaluate.  The ImageMgr sets up the graph for traversal, fetches input image
data for each Op to use (ie in the form of Tiles) and passes the Op a dest
output as well. Decoupling the details of the graph traversal and data
management from the actual image processing classes lets us extend image
operations and graph/memory management implementations separately. We can
subclass ImageMgr to provide different memory management schemes or arrange for
data to be delivered to the Ops in different ways. For example, a
PagingImageMgr subclass or ImageMgr might present requests to the Ops in pages
of a certain size.
</para>
<para>
The ImageManager decides how to traverse the graph, and also if any preliminary
passes over the graph are necessary. For example the TileImageManager computes
the region of interest (or need_rect) and domains of definition (have_rects) on
nodes in preliminary breadth-first and depth-first traversals. Also ColorModels
and data types are derived on Images which do not have these explicitly set.
Eventually the ImageManager calls all the nodes in the image graph (through the
Op's prepare , process, and finish routines) and passes image data for use
as output and inputs. When an operation for a node is complete the ImageManager
decides what to do with the output.  For example it could cache it in memory or
swap it to disk.
</para>
<para>
Below is a picture of the Op and ImageMgr classes. The design of is an example
of a bridge (from GoF Design Patterns).
</para>
<graphic fileref="../images/apply.png"></graphic>
<para>
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### STRUCT GeglImageMgr ##### -->
<para>

</para>


<!-- ##### FUNCTION gegl_image_mgr_install ##### -->
<para>

</para>

@image_mgr: 


<!-- ##### FUNCTION gegl_image_mgr_instance ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION gegl_image_mgr_apply ##### -->
<para>

</para>

@self: 
@root: 
@dest: 
@roi: 


<!-- ##### FUNCTION gegl_image_mgr_delete_image ##### -->
<para>

</para>

@self: 
@image: 
<!-- # Unused Parameters # -->
@image_impl: 


<!-- ##### FUNCTION gegl_image_mgr_add_image ##### -->
<para>

</para>

@self: 
@image: 
<!-- # Unused Parameters # -->
@image_impl: 


<!-- ##### FUNCTION gegl_image_mgr_get_tile_mgr ##### -->
<para>

</para>

@self: 
@Returns: 


