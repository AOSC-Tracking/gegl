<!-- ##### SECTION Title ##### -->
GeglOp

<!-- ##### SECTION Short_Description ##### -->
Abstract class for operation with inputs and outputs.

<!-- ##### SECTION Long_Description ##### -->

<refsect2>
<title>Overview</title>
<para>
Gegl has two main concepts that describe how it works. The first is the concept
of image processing operations, or Ops. The second is the concept of data and
how it is passed between the Ops. Data is described in #GeglData. Ops are described 
here.
</para>
<para>
An Op represents some operation that takes inputs and produces outputs. The
output of an op is usually image data, but it could be some other kind of data
like scalars or histograms. Ops may have multiple outputs as well. Similarly,
the inputs to an Op can be any kind of data, including images, scalars,
pixels, strings or something else. Below we give some examples of ops with
their inputs and outputs.
<xref linkend="inputs-outputs-for-color-op"/>
 shows a #GeglColor.
<figure id="inputs-outputs-for-color-op">
<title>Color op</title>
<graphic fileref="inputs_outputs_for_color_op.png"></graphic>
</figure>
</para>
<para> 
Here the op has one input, called <literal>pixel</literal>, and one output
called <literal>dest</literal>. The input <literal>pixel</literal> is just a
single constant color that will be used to create the output image
<literal>dest</literal>. During its operation, #GeglColor fills in
<literal>dest</literal> with the passed <literal>pixel</literal> value.
</para>
<para> 
The next example <xref linkend="inputs-outputs-for-fade-op"/> shows a 
#GeglFade op which has two inputs and one output.
<figure id="inputs-outputs-for-fade-op">
<title>Fade op</title>
<graphic fileref="inputs_outputs_for_fade_op.png"></graphic>
</figure>
</para>
<para> 
Here the inputs are <literal>source</literal> and <literal>multiplier</literal>.
The output is <literal>dest</literal>. In this case <literal>source</literal> is
the input image, <literal>multiplier</literal> is a scalar 
and <literal>dest</literal> is the output image data. In this case Fade 
applies the <literal>multiplier</literal> factor to each channel in the 
<literal>source</literal> and places the result in <literal>dest</literal>.
</para>
<para> 
<xref linkend="inputs-outputs-for-over-op"/> shows a #GeglOver op.
</para>
<figure id="inputs-outputs-for-over-op">
<title>Over op</title>
<graphic fileref="inputs_outputs_for_over_op.png"></graphic>
</figure>
<para>
Here there are two input images, <literal>foreground</literal> and 
<literal>background</literal> and a boolean <literal>premultiplied</literal> 
input. The output image is <literal>dest</literal>. In this case Over
composites foreground over <literal>background,</literal> premultiplying 
the <literal>foreground</literal> first if the <literal>premultiply</literal> 
flag is set.
</para>
</refsect2>
<refsect2>
<title>Op, Operation, Graph</title>
<para>
Op is the common superclass of #GeglOperation and #GeglGraph. This forms a composite 
or container design pattern (GoF Design Patterns), with #GeglOperation as the "leaf" or 
atomic class, and #GeglGraph as the "composite" or container class. This is
shown in <xref linkend="composite"/>.
<figure id="composite">
<title>Composite or container pattern</title>
<graphic fileref="composite.png"></graphic>
</figure>
</para>
<para>
So <link linkend="GeglOperation">GeglOperation</link>s are the primitive image
processing objects in Gegl and <link linkend="GeglGraph">GeglGraph</link>s 
are containers of other operations and graphs. A #GeglGraph could describe 
a chain or tree of Ops.
</para>
</refsect2>

<refsect2>
<title>Data, Inputs, Outputs</title>
<para>
Ops do their image processing work by operating on inputs to produce outputs.
To describe each input and output, Gegl uses #GeglData objects. For each output
for an op there is a #GeglData object stored in the Op's
<literal>output_data_array</literal> field. This #GeglData object describes the
output data type (image, scalar, pixel, channel value, etc) and holds the value
of the computed result. Likewise, for each input to an Op, there is a #GeglData
object in the Op's <literal>input_data_array</literal> field.  These describe
the type of input data needed by an Op and also hold the input data values the
op will use during operation. Each Op decides how to transform the provided
input data into output data during its operation.  
</para>
<para>
In  <xref linkend="inputs-outputs-for-color-op"/>, <literal>pixel</literal> is 
#GeglPixelData, and <literal>dest</literal> is #GeglImageData. 
In <xref linkend="inputs-outputs-for-fade-op"/>, <literal>source</literal> is 
#GeglImageData, <literal>multiplier</literal> is #GeglScalarData and 
<literal>dest</literal> is #GeglImageData. For  <xref linkend="inputs-outputs-for-over-op"/>
<literal>foreground</literal> and <literal>background</literal> are 
#GeglImageData and <literal>premultiply</literal> is #GeglScalarData. 
</para>
</refsect2>

<refsect2>
<title>Applying an Op</title>
<para>
The most important method in Op is gegl_op_apply(). This is the main image
processing routine. This is where all the action happens. Calling this
method on a Node begins processing the complete graph with that Node
as the root. Everything attached upstream to this Node will be evaluated,
the data pulled through the graph towards the root (the passed Node) and the 
result plopped into the output of the Node. 
<xref linkend="apply"/> shows setting up a #GeglFade op and calling 
apply on it.
<example id="apply"> 
<title>Creating an op and calling apply.</title>
<programlisting>
GeglOp *source = g_object_new(GEGL_TYPE_COLOR, 
                              "width", 720, 
                              "height", 486, 
                              "pixel-rgb-float",.1, .2, .3, 
                              NULL); 

GeglOp *fade = g_object_new(GEGL_TYPE_FADE,
                            "source", source,
                            "multiplier", .5, 
                            NULL);

gegl_op_apply(fade);

g_object_unref(fade);
g_object_unref(source);
</programlisting>
</example>
In this example, no image processing occurs until the call to gegl_op_apply(). 
When that call is finished, the result of the evaluation is in the #GeglData 
object that represents the output for the Op <literal>fade</literal>. This 
#GeglData object is an element in the Op's <literal>output_data_array</literal>.  
Usually the output array just contains one #GeglData element since most Ops have 
produce a single image as output.
</para>

<para>
The method gegl_op_apply_roi() is similar except that you may pass a region 
of interest as well. The image processing in this case will be restricted 
to the passed roi.
</para>

<para>
Calling gegl_op_apply() on the root of a graph causes processing of the 
entire graph in roughly depth-first order. This is done by a #GeglEvalMgr. Ops 
are processed from the leaves of the graph towards the root, with each node waiting 
until inputs are computed before it is evaluated. Once the inputs of a node are 
ready the node is called to perform its operation. <xref linkend="simpleopsgraph"/>
shows setting up a simple graph.
<example id="simpleopsgraph"> 
<title>A Simple graph of Ops.</title>
<programlisting>

  /* 
        iadd              (.55,.7,.85) 
        /   \             /         \ 
     fade  color2   (.05,.1,.15)   (.5,.6,.7)
      |                   | 
     color1          (.1,.2,.3)

  */ 

  GeglOp * color1 = g_object_new(GEGL_TYPE_COLOR, 
                                 "pixel-rgb-float", .1, .2, .3, 
                                 NULL); 

  GeglOp * color2 = g_object_new(GEGL_TYPE_COLOR, 
                                 "pixel-rgb-float", .5, .6, .7, 
                                 NULL); 

  GeglOp * fade = g_object_new (GEGL_TYPE_FADE,
                                "source", color1,
                                "multiplier", .5,
                                NULL); 

  GeglOp * iadd = g_object_new (GEGL_TYPE_I_ADD, 
                                "source-0", fade,
                                "source-1", color2,
                                NULL);  

  gegl_op_apply(iadd); 

  g_object_unref(iadd);
  g_object_unref(fade);
  g_object_unref(color1);
  g_object_unref(color2);
</programlisting>
</example>
The evaluation order of the ops here is: <literal>color1</literal>,
<literal>fade</literal>, <literal>color2</literal>, and 
finally <literal>iadd</literal>. This order is determined by a depth-first 
traversal of the graph. 
</para>
</refsect2>

<refsect2>
<title>Generic Properties</title>
<para>
Gegl uses the idea of generic properties to handle passing data of the 
same generic type but with different data type realizations. For example
pixel values that represent colors can be given alternatively with components
that are given as uint8, float, or uint16 values. These generic properties
correspond to bundles of regular glib properties, installed for each input
that needs to handle several different versions of the data being passed
in a property. As an example let's look at <xref linkend="genericproperties"/> 
where #GeglColor sets up the bundle of glib properties that correspond to it's 
input data "pixel". During the class_init() method of #GeglColor we register a 
regular glib property for each version of the pixel that is needed.
<example id="genericproperties"> 
<title>Pixel property for ColorOp.</title>
<programlisting>
static void 
class_init (GeglColorClass * klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS(klass);

  /* Other init code */ 

  /* Now install the various versions of the property "pixel". */

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGB_FLOAT,
    gegl_param_spec_pixel_rgb_float ("pixel-rgb-float",
                                     "Pixel-Rgb-Float",
                                     "The pixel-rgb-float pixel",
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     0.0, 0.0, 0.0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGBA_FLOAT,
    gegl_param_spec_pixel_rgba_float ("pixel-rgba-float",
                                     "Pixel-Rgba-Float",
                                     "The pixel-rgba-float pixel",
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     0.0, 1.0,
                                     0.0, 0.0, 0.0, 0.0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGB_UINT8,
    gegl_param_spec_pixel_rgb_uint8 ("pixel-rgb-uint8",
                                     "Pixel-Rgb-Uint8",
                                     "The rgb-uint8 pixel",
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 0, 0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGBA_UINT8,
    gegl_param_spec_pixel_rgba_uint8 ("pixel-rgba-uint8",
                                     "Pixel-Rgba-Uint8",
                                     "The rgba-uint8 pixel",
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 0, 0, 0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_NODE,
               g_param_spec_object ("pixel-node",
                                    "PixelNode",
                                    "The pixel node",
                                     GEGL_TYPE_OP,
                                     G_PARAM_WRITABLE));

  /* More initialization code */
}
</programlisting>
</example>
</para> 
<para> 
We see that we have installed versions of "pixel" for rgb-float, rgba-float,
rgb-uint8, rgba-uint8, and a special node version as well. All of these 
are bundled together and thought of just as the generic property "pixel" 
for input data of #GeglColor. Any of these versions can be plugged
in as the "pixel" input for #GeglColor and will work. This allows setting 
up versions of #GeglColor that correspond to the correct data type. 
<xref linkend="floatcolor"/> shows an example of a float channel version.
<example id="floatcolor"> 
<title>Float version of Color op</title>
<programlisting>
  /* Here's an example of a float pixel constant color image */
  GeglOp *color = g_object_new(GEGL_TYPE_COLOR, 
                               "width", 720, 
                               "height", 486, 
                               "pixel-rgb-float", .1, .2, .3, 
                               NULL); 

  gegl_op_apply(color);
  g_object_unref(color);
</programlisting>
</example>
</para>
<para>
And <xref linkend="uint8color"/> shows an example of a uint8 
version.
<example id="uint8color"> 
<title>Uint8 version of Color op</title>
<programlisting>
  /* Here's an example of a uint8 pixel constant color image */
  GeglOp *color = g_object_new(GEGL_TYPE_COLOR, 
                               "width", 720, 
                               "height", 486, 
                               "pixel-rgb-uint8", 123, 245, 255, 
                               NULL); 

  gegl_op_apply(color);
  g_object_unref(color);
</programlisting>
</example>
</para>
</refsect2>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### USER_FUNCTION GeglValidateDataFunc ##### -->
<para>

</para>

@input_data: 
@other_data: 


<!-- ##### STRUCT GeglOp ##### -->
<para>

</para>


<!-- ##### STRUCT GeglOpClass ##### -->
<para>

</para>

@node_class: 

<!-- ##### FUNCTION gegl_op_apply ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_op_apply_roi ##### -->
<para>

</para>

@self: 
@roi: 


<!-- ##### FUNCTION gegl_op_add_input_data ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 


<!-- ##### FUNCTION gegl_op_add_output_data ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 


<!-- ##### FUNCTION gegl_op_get_input_data_index ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_output_data_index ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_nth_input_data ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_nth_output_data ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_input_data ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_output_data ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_input_data_value ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_set_input_data_value ##### -->
<para>

</para>

@self: 
@name: 
@value: 


<!-- ##### FUNCTION gegl_op_get_output_data_value ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 


<!-- ##### FUNCTION gegl_op_set_output_data_value ##### -->
<para>

</para>

@self: 
@name: 
@value: 


<!-- ##### FUNCTION gegl_op_get_input_data_array ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_op_get_output_data_array ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_op_append_input_data ##### -->
<para>

</para>

@self: 
@data: 


<!-- ##### FUNCTION gegl_op_append_output_data ##### -->
<para>

</para>

@self: 
@data: 


<!-- ##### FUNCTION gegl_op_free_input_data_array ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_op_free_output_data_array ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_op_validate_input_data_array ##### -->
<para>

</para>

@self: 
@collected_array: 
@func: 


