<!-- ##### SECTION Title ##### -->
GeglOp

<!-- ##### SECTION Short_Description ##### -->
Abstract class for operation with inputs and outputs.

<!-- ##### SECTION Long_Description ##### -->
<para>
This is the main abstract class for operations in Gegl. An Op represents some
operation that takes inputs and produces outputs. The outputs may be image data
or some other kind of data, like histograms, or scalars, like the average of a
grayscale image. An Op may produce no output at all but do something useful
during its operation. For example a PrintOp may print the values of its pixels
but otherwise do nothing to the data.
</para>

<para>
Op is the common superclass of Filter and Graph. This forms a composite design
pattern (GoF Design Patterns), with Filter as the "leaf" or atomic class, and
Graph as the "composite" or container class. So Filters can be thought of as
basic image processing objects and Graphs are chains and trees of these. Hence
Graphs will contain other Filters and Graphs. A Graph will typically contain a
root node that corresponds to its output as well as nodes that correspond to
each of its inputs.
</para>

<para>
The inputs and outputs of Ops are described and passed using Attribute
structures. For each output an Op produces, there is a corresponding Attribute
struct that describes the output type and holds the computed result value. In
addition to descriptions of the outputs, the Attribute struct for an output
also holds various synthesized and inherited attributes that are computed and
used while evaluating a Graph. For example, Attributes for image data will
carry regions of interest (need rects) and domains of definitions (have rects)
information. Also they will hold synthesized color models. For example, if an
Op has inputs that have color models RGB and GRAY, respectively, the output
will be placed in a RGB color model. If this Op needs both inputs to be of
the same color model, then the GRAY input will be "promoted" to RGB before
being passed to the Op. Attribute structures keep this kind of information
for each output.
</para>

<para>
The most important method in Op is gegl_op_apply, which is the main image
processing routine. This begins processing a graph for the passed root node.
The method gegl_op_apply_image is similar and may be passed an output
destination SampledImage as well as a region of interest. The image processing
in this case will be restricted to the passed roi. Calling apply on the root of
a graph causes processing of the entire graph in depth-first (or some other
topological sort) order. Ops are processed from the leaves of the graph
towards the root, with each node waiting until inputs are computed before it
begins. Once the inputs of a node are finished the node can perform its
operation.
</para>
<para>
Heres an example of setting up a Mult op and calling apply on it:
<example>
<title>Setting up a Mult Op</title>
<programlisting>

  /* Make some SampledImages to use as inputs */
  gint w = 720; 
  gint h = 486; 
  GeglColorModel *rgb_u8 = gegl_color_model_instance("RgbU8");

  GeglOp *A = g_object_new(GEGL_TYPE_SAMPLED_IMAGE,
                           "colormodel", rgb_u8,
                           "width", w,
                           "height", h,
                            NULL);

  GeglOp *B = g_object_new(GEGL_TYPE_SAMPLED_IMAGE,
                           "colormodel", rgb_u8,
                           "width", w,
                           "height", h, 
                           NULL);

  /* Do something to set up the SampledImages above... */

  /* 
      Now set up the mult op

        mult
        / \
       A   B
  */

  GeglOp * mult = g_object_new (GEGL_TYPE_MULT,
                                "input0", A,
                                "input1", B,
                                NULL);

  /* Create a sampled image to hold result */
  GeglSampledImage *dest = g_object_new(GEGL_TYPE_SAMPLED_IMAGE,
                                        "colormodel", rgb_u8, 
                                        "width", w, 
                                        "height", h, 
                                        NULL);

  /* Call apply to do the operation, put result in dest */
  gegl_op_apply_image (mult, dest, NULL);

  g_object_unref (mult);
  g_object_unref (A);
  g_object_unref (B);
  g_object_unref (rgb_u8);

</programlisting>
</example>
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### FUNCTION gegl_op_apply ##### -->
<para>

</para>

@self: 
<!-- # Unused Parameters # -->
@dest: 
@roi: 


<!-- ##### FUNCTION gegl_op_apply_image ##### -->
<para>

</para>

@self: 
@image: 
@roi: 


<!-- ##### FUNCTION gegl_op_apply_roi ##### -->
<para>

</para>

@self: 
@roi: 


<!-- ##### FUNCTION gegl_op_allocate_attributes ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_op_get_nth_attributes ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 
<!-- # Unused Parameters # -->
@op: 


<!-- ##### FUNCTION gegl_op_get_attributes ##### -->
<para>

</para>

@self: 
@Returns: 


