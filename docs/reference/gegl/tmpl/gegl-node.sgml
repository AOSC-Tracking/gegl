<!-- ##### SECTION Title ##### -->
GeglNode

<!-- ##### SECTION Short_Description ##### -->
Abstract node class.

<!-- ##### SECTION Long_Description ##### -->
<para>
This is the abstract node class for Gegl. Since we want to be able to share
nodes, graphs in Gegl are directed acyclic graphs (DAGs). Nodes have both
inputs and outputs. Usually the number of these is fixed for the duration of
the Node's existence. If the nodes of a graph are all distinct, the graph is a
tree.
</para>

<para>
Each input of a Node has at most one Node attached to the other end of it
upstream. There may be no Node upstream that is attached to a particular input
for a Node if the graph is still being constructed. 
</para>

<para>
In contrast, each output of a Node can have multiple Nodes attached to it
downstream. This is because more than one Node may be pulling data downstream
from the same output of a Node. A Node with more than one Node attached
downstream like this is called a shared node. We use GObject reference counting
to keep track of shared nodes. 
</para>

<para>
A Node is called a leaf node if it has no inputs. A Node is called a root node
if there are no Nodes attached to the outputs of it.
</para>

<para>
Heres a simple example of an graph for Comp(Blur(A), Mult(A,B)):
</para>
<graphic fileref="../images/chain.png"></graphic>
<para>
Here Comp (composite over) is the root node, A and B are leaf SampledImage
nodes. Blur has A as input and Comp as output and Mult has two inputs, A and B,
with Comp as output. A is shared by both its outputs Blur and Mult. Finally
Comp is downstream from Blur, A and B are upstream from everything, etc. 
</para>

<para>
The Node class also manages adding and removing inputs as well as nodes
attached to outputs.
</para>

<para>
The Node class keeps track of output-to-input information for each Node by
using Connectors. An input Connector holds the information about which Node is
an input to a given Node, and which output that input Node came from.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### STRUCT GeglConnection ##### -->
<para>

</para>

@node: 
@input_index: 
@input: 
@output_index: 

<!-- ##### FUNCTION gegl_node_get_nth_input ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 


<!-- ##### FUNCTION gegl_node_set_nth_input ##### -->
<para>

</para>

@self: 
@input: 
@n: 
<!-- # Unused Parameters # -->
@Returns: 


<!-- ##### FUNCTION gegl_node_set_nth_input_connection ##### -->
<para>

</para>

@self: 
@input: 
@output_index: 
@n: 


<!-- ##### FUNCTION gegl_node_get_nth_input_connection ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 


<!-- ##### FUNCTION gegl_node_get_num_inputs ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_node_get_num_outputs ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_node_get_input_connections ##### -->
<para>

</para>

@self: 
@Returns: 


<!-- ##### FUNCTION gegl_node_get_outputs ##### -->
<para>

</para>

@self: 
@output_index: 
@Returns: 
<!-- # Unused Parameters # -->
@index_num_outputs: 
@index: 


<!-- ##### FUNCTION gegl_node_accept ##### -->
<para>

</para>

@self: 
@visitor: 


<!-- ##### FUNCTION gegl_node_set_num_inputs ##### -->
<para>

</para>

@self: 
@num_inputs: 


<!-- ##### FUNCTION gegl_node_set_num_outputs ##### -->
<para>

</para>

@self: 
@num_outputs: 


