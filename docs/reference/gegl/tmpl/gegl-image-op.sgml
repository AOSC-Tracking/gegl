<!-- ##### SECTION Title ##### -->
GeglImageOp

<!-- ##### SECTION Short_Description ##### -->
Abstract class that produces an image data output.

<!-- ##### SECTION Long_Description ##### -->
<para>
The ImageOp represents image operations that produce a single image output.
This is the most common image processing op. It includes point ops, area ops,
geometric ops, and others.   
</para>
<para>
The data output for the ImageOp is a #GeglImageData object, created during
ImageOp's init() method. This represents the image data, area, 
and colormodel that are needed to specify the output image data. 
The <literal>rect</literal> and <literal>colormodel</literal> fields of 
#GeglImageData are filled in by #GeglEvalMgr visitors before the 
ImageOp is evaluated. This happens during preliminary breadth-first and 
depth-first passes of the graph that the #GeglEvalMgr makes before the 
actual Op evaluation pass. During these passes #GeglEvalMgr calls
gegl_image_op_evaluate_have_rect(), gegl_image_op_evaluate_need_rects(),
and gegl_image_op_evaluate_color_model(). These in turn call virtual
methods on ImageOp, which subclasses override to fill in their 
versions of these calculations:
<variablelist>
  <varlistentry>
      <term>compute_have_rect()</term>
        <listitem>
         <para>
Calculates the have rect of this op. This is the domain of definition of the
image data described by this op. This depends on where the ImageOp is defined.
For example an image read from a file has a domain of definition determined by
the file width and height and where the image is placed. The have rect of a
procedurally defined op like Noise could be infinite.
         </para>
        </listitem>
  </varlistentry>
  <varlistentry>
      <term>compute_need_rect()</term>
        <listitem>
         <para>
Calculates the need rect of an image input of this op. This is the region of
interest for the input based on that of the op.  For example a convolution op
requires a need rect on its input which is bigger by a border of half the width
of the kernal size. The input of a point op has a need rect which exactly the
same size as the op, since each pixel in a point op is determined by a
corresponding pixel in the input.
         </para>
         <para>
         </para>
        </listitem>
  </varlistentry>
  <varlistentry>
      <term>compute_color_model()</term>
        <listitem>
         <para>
Synthesizes the color model of the op based on the inputs.
         </para>
        </listitem>
  </varlistentry>
</variablelist>
</para>

<para>
Need rects are calculated in a breadth-first pass of the graph by the 
GeglEvalMgr, and so are passed from root to leaves.
Have rects and color models are calculated in a depth-first
pass and so are passed from leaves to the root.
These are like inherited and synthesized attributes in compiler
terminology.  Doing these rect calculations this way leads to more
efficient calculations and avoids overcomputing.
</para>

<para>
The ImageOp also has a pointer to an image buffer that it creates to store its
result. This is the #GeglImage field <literal>image</literal>.  This object
holds things like the color model, and details about the storage type and
tiles. 
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### STRUCT GeglImageOp ##### -->
<para>

</para>


<!-- ##### FUNCTION gegl_image_op_compute_need_rects ##### -->
<para>

</para>

@self: 


<!-- ##### FUNCTION gegl_image_op_compute_have_rect ##### -->
<para>

</para>

@self: 
<!-- # Unused Parameters # -->
@have_rect: 
@data_inputs: 


<!-- ##### FUNCTION gegl_image_op_compute_color_model ##### -->
<para>

</para>

@self: 
<!-- # Unused Parameters # -->
@data_inputs: 
@Returns: 


