<!-- ##### SECTION ./tmpl/gegl-atop.sgml:Long_Description ##### -->
<para>
This composites foreground (f,fa) atop background (b,ba). The part of the
foreground lying inside of the background is composited onto the background.
</para>
<para>
<literallayout>
c  = f*ba + b*(1-fa)
ca = ba 
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-atop.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-atop.sgml:Short_Description ##### -->
Composite foreground atop background


<!-- ##### SECTION ./tmpl/gegl-atop.sgml:Title ##### -->
GeglAtop


<!-- ##### SECTION ./tmpl/gegl-channel-data.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-data.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-data.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-channel-data.sgml:Title ##### -->
GeglChannelData


<!-- ##### SECTION ./tmpl/gegl-channel-space-float.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space-float.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space-float.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-channel-space-float.sgml:Title ##### -->
GeglChannelSpaceFloat


<!-- ##### SECTION ./tmpl/gegl-channel-space-uint8.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space-uint8.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space-uint8.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-channel-space-uint8.sgml:Title ##### -->
GeglChannelSpaceU8


<!-- ##### SECTION ./tmpl/gegl-channel-space.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-channel-space.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-channel-space.sgml:Title ##### -->
GeglChannelSpace


<!-- ##### SECTION ./tmpl/gegl-color-alpha.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-color-alpha.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-color-alpha.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-color-alpha.sgml:Title ##### -->
GeglPointOp


<!-- ##### SECTION ./tmpl/gegl-copy.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-copy.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-copy.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-copy.sgml:Title ##### -->
GeglCopy


<!-- ##### SECTION ./tmpl/gegl-darken.sgml:Long_Description ##### -->
<para>
Selects the darker of the background and foreground colors. The background is
replaced with the foreground when the foreground is darker, otherwise it is left
unchanged.
<literallayout>
c = min(f*ba, b*fa) + f*(1-ba) + b*(1-fa) 
ca = fa + ba - fa*ba 
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-darken.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-darken.sgml:Short_Description ##### -->
Darken blend mode


<!-- ##### SECTION ./tmpl/gegl-darken.sgml:Title ##### -->
GeglDarken


<!-- ##### SECTION ./tmpl/gegl-data.sgml:Long_Description ##### -->
<refsect2 id="dataproperties">
<title>Overview</title>
<para>
#GeglData objects describe the data that passes through a graph in Gegl. This
data is passed from op to op, with outputs becoming inputs and each op doing
its part by transforming inputs into outputs during its operation. Common examples
of data that can be passed along a graph include images, pixels, channels, and
scalars. The subclasses of #GeglData that correspond to these are
#GeglImageData, #GeglPixelData, #GeglChannelData, and #GeglScalarData
respectively.  Typically an Op will have one output, a #GeglImageData and one
or more inputs of various kinds. However, some ops may produce more than one
output. For example an op that breaks an RGB image into separate R, G, and B
planes would have 3 #GeglImageData outputs (one for each plane) and a single
#GeglImageData input (the RGB image).
</para>
<para>
Each Data object contains three important parts:
<itemizedlist>
  <listitem>
    <para>
     <emphasis> Name and type of data </emphasis> &mdash; 
     The name of the input or output this data is for and whether it  is an
     image, pixel, scalar, string, etc.
     </para>
  </listitem>
  <listitem>
    <para>
     <emphasis> The value of the data </emphasis>&mdash; a #GValue which holds 
     the actual data. 
     </para>
  </listitem>
  <listitem>
    <para>
     <emphasis> Attributes passed with the data </emphasis>. &mdash; These are 
     attributes specific to the type of data that need to be passed along the 
     graph. For image data this includes need and have rects, color model, 
     image masks.
     </para>
  </listitem>
</itemizedlist>
</para>
<para>
The value of the data is stored in the <literal>value</literal> field
of #GeglData. This is a glib #GValue. So basically a #GeglData object is 
a wrapper for a #GValue, with some additions. Gegl uses standard #GValue 
mechanisms to set up conversions between the value fields of different 
data objects.
</para>
<para>
#GeglData objects are stored in the #GeglOp's arrays of input and
output data, each one added by the #GeglOp object during 
its init() methods. This is described below in <link linkend="datasetup">section</link> 
below showing how #GeglOp set up input and output data. 
</para>
</refsect2>

<refsect2 id="datasetup">
<title>Adding Data</title>
<para>
During initialization (the object's various init() methods) each Op must add 
the #GeglData objects that will hold values for inputs and outputs. This happens
in gegl_op_add_input_data() and gegl_op_add_output_data(). Each of these add
a data element of the appropriate kind to either 
<literal>input_data_array</literal> or <literal>output_data_array</literal>
fields of #GeglOp.  For example, consider the #GeglFade op. It is a subclass of 
both #GeglImageOp and #GeglUnary. Let's follow the various object init() calls of 
#GeglFade and its superclasses when a new #GeglFade object is created. 
</para>
<para>
First g_object_new is called: 
<programlisting>
GeglOp * fade = g_object_new(GEGL_TYPE_FADE,
                             "multiplier", .5,
                             NULL);
</programlisting>
During this call the various object init() methods are called for all the
superclasses of #GeglFade starting with #GeglObject first and then in each
subclass down the class heirarchy until #GeglFade. The first we need to worry
about is #GeglImageOp: 
<programlisting>
static void 
init (GeglImageOp * self, 
      GeglImageOpClass * klass)
{
  /* Add an image output */
  gegl_op_add_output_data(GEGL_OP(self), GEGL_TYPE_IMAGE_DATA, "dest");

  /* Other initialization code */
}
</programlisting>
This code adds the "dest" image data, which holds the output image. 
The next one that concerns us is #GeglUnary init(). Here we see the
"source" image data added: 
<programlisting>
static void 
init (GeglUnary * self, 
      GeglUnaryClass * klass)
{
  /* Add an image input */
  gegl_op_append_input(GEGL_OP(self), GEGL_TYPE_IMAGE_DATA, "source");
}
</programlisting>
Finally the #GeglFade object init() adds the data input "multiplier", which
is a scalar:
<programlisting>
static void 
init (GeglFade * self, 
      GeglFadeClass * klass)
{
  /* Add the multiplier input. */
  gegl_op_append_input(GEGL_OP(self), GEGL_TYPE_SCALAR_DATA, "multiplier");

  /* Other initialization code */
}
</programlisting>
Once we are done, we have added one image output and two inputs, one an image
and the other a scalar. This describes all the data outputs and inputs for the
#GeglFade completely.
</para>
</refsect2>


<!-- ##### SECTION ./tmpl/gegl-data.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-data.sgml:Short_Description ##### -->
Abstract data class


<!-- ##### SECTION ./tmpl/gegl-data.sgml:Title ##### -->
GeglData


<!-- ##### SECTION ./tmpl/gegl-difference.sgml:Long_Description ##### -->
<para>
Subtracts the darker of the two constituent colors from the lighter. Painting
with white inverts the destination color. Painting with black produces no
change.
<literallayout>
c = ABS(b*fa - b*ba) + f*(1-ba) + b*(1-fa) 
  = f + b - 2*MIN(f*ba,b*fa)
ca = fa + ba - fa*ba
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-difference.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-difference.sgml:Short_Description ##### -->
Difference blend mode


<!-- ##### SECTION ./tmpl/gegl-difference.sgml:Title ##### -->
GeglDifference


<!-- ##### SECTION ./tmpl/gegl-fade.sgml:Long_Description ##### -->
<para>
This op applies a multiplier constant to all channels, including alpha.
<literallayout>
multiplier * R
multiplier * B
multiplier * G
multiplier * A
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-fade.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-fade.sgml:Short_Description ##### -->
Apply multiplier to image and alpha


<!-- ##### SECTION ./tmpl/gegl-fade.sgml:Title ##### -->
GeglFade


<!-- ##### SECTION ./tmpl/gegl-fill.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-fill.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-fill.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-fill.sgml:Title ##### -->
GeglFill


<!-- ##### SECTION ./tmpl/gegl-i-add.sgml:Long_Description ##### -->
<para>
Add two images.
</para>
<para>
A + B
</para>


<!-- ##### SECTION ./tmpl/gegl-i-add.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-i-add.sgml:Short_Description ##### -->
Add two images


<!-- ##### SECTION ./tmpl/gegl-i-add.sgml:Title ##### -->
GeglIAdd


<!-- ##### SECTION ./tmpl/gegl-i-mult.sgml:Long_Description ##### -->
<para>
Multiply two images.
</para>
<para>
A * B
</para>


<!-- ##### SECTION ./tmpl/gegl-i-mult.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-i-mult.sgml:Short_Description ##### -->
Multiply two images


<!-- ##### SECTION ./tmpl/gegl-i-mult.sgml:Title ##### -->
GeglIMult


<!-- ##### SECTION ./tmpl/gegl-image-param-specs.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-image-param-specs.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-image-param-specs.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-image-param-specs.sgml:Title ##### -->
gegl-image-param-specs


<!-- ##### SECTION ./tmpl/gegl-inside.sgml:Long_Description ##### -->
<para>
Composite foreground (f,fa) inside background (b,ba).
The part of the foreground lying inside of the background replaces the background.
</para>

<para>
<literallayout>
c = f * ba 
ca = fa * ba
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-inside.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-inside.sgml:Short_Description ##### -->
Composite foreground inside background


<!-- ##### SECTION ./tmpl/gegl-inside.sgml:Title ##### -->
GeglInside


<!-- ##### SECTION ./tmpl/gegl-lighten.sgml:Long_Description ##### -->
<para>
Selects the lighter of the background and foreground colors. The background is
replaced with the foreground when the foreground is lighter, otherwise it is left
unchanged.
<literallayout>
c = max(f*ba, b*fa) + f*(1-ba) + b*(1-fa)
ca = fa + ba - fa*ba
</literallayout>

</para>


<!-- ##### SECTION ./tmpl/gegl-lighten.sgml:See_Also ##### -->
<para>
#GeglBlend

</para>


<!-- ##### SECTION ./tmpl/gegl-lighten.sgml:Short_Description ##### -->
Lighten blend mode


<!-- ##### SECTION ./tmpl/gegl-lighten.sgml:Title ##### -->
GeglLighten


<!-- ##### SECTION ./tmpl/gegl-max.sgml:Long_Description ##### -->
<para>
Take the maximum of two images.
</para>
<para>
Max(A,B)
</para>


<!-- ##### SECTION ./tmpl/gegl-max.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-max.sgml:Short_Description ##### -->
Max of two images


<!-- ##### SECTION ./tmpl/gegl-max.sgml:Title ##### -->
GeglMax


<!-- ##### SECTION ./tmpl/gegl-min.sgml:Long_Description ##### -->
<para>
Take the minimum of two images.
</para>
<para>
Min(A,B)
</para>


<!-- ##### SECTION ./tmpl/gegl-min.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-min.sgml:Short_Description ##### -->
Min of two images


<!-- ##### SECTION ./tmpl/gegl-min.sgml:Title ##### -->
GeglMin


<!-- ##### SECTION ./tmpl/gegl-no-input.sgml:Long_Description ##### -->
<para>
This is the abstract class that represents single image output operations that
take no image inputs. This includes solid color ops, noise ops, and other
procedurally defined operations.
</para>


<!-- ##### SECTION ./tmpl/gegl-no-input.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-no-input.sgml:Short_Description ##### -->
Abstract class for operation with no input


<!-- ##### SECTION ./tmpl/gegl-no-input.sgml:Title ##### -->
GeglNoInput


<!-- ##### SECTION ./tmpl/gegl-normal.sgml:Long_Description ##### -->
<para>
Composite foreground (f,fa) and background (b,ba) using normal
blend mode, blend(x,y)=x.
<literallayout>
c = (1-fa)*b + f
ca = fa + ba - fa*ba
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-normal.sgml:See_Also ##### -->
<para>
#GeglBlend

</para>


<!-- ##### SECTION ./tmpl/gegl-normal.sgml:Short_Description ##### -->
Composite foreground and background using normal blend mode.


<!-- ##### SECTION ./tmpl/gegl-normal.sgml:Title ##### -->
GeglNormal


<!-- ##### SECTION ./tmpl/gegl-op.sgml:Long_Description ##### -->

<refsect2>
<title>Overview</title>
<para>
Gegl has two main concepts that describe how it works. The first is the concept
of image processing operations, or Ops. The second is the concept of data and
how it is passed between the Ops. Data is described in #GeglData. Ops are described 
here.
</para>
<para>
An Op represents some operation that takes inputs and produces outputs. The
output of an op is usually image data, but it could be some other kind of data
like scalars or histograms. Ops may have multiple outputs as well. Similarly,
the inputs to an Op can be any kind of data, including images, scalars,
pixels, strings or something else. Below we give some examples of ops with
their inputs and outputs.
<xref linkend="inputs-outputs-for-color-op"/>
 shows a #GeglColor.
<figure id="inputs-outputs-for-color-op">
<title>Color op</title>
<graphic fileref="inputs_outputs_for_color_op.png"></graphic>
</figure>
</para>
<para> 
Here the op has one input, called <literal>pixel</literal>, and one output
called <literal>dest</literal>. The input <literal>pixel</literal> is just a
single constant color that will be used to create the output image
<literal>dest</literal>. During its operation, #GeglColor fills in
<literal>dest</literal> with the passed <literal>pixel</literal> value.
</para>
<para> 
The next example <xref linkend="inputs-outputs-for-fade-op"/> shows a 
#GeglFade op which has two inputs and one output.
<figure id="inputs-outputs-for-fade-op">
<title>Fade op</title>
<graphic fileref="inputs_outputs_for_fade_op.png"></graphic>
</figure>
</para>
<para> 
Here the inputs are <literal>source</literal> and <literal>multiplier</literal>.
The output is <literal>dest</literal>. In this case <literal>source</literal> is
the input image, <literal>multiplier</literal> is a scalar 
and <literal>dest</literal> is the output image data. In this case Fade 
applies the <literal>multiplier</literal> factor to each channel in the 
<literal>source</literal> and places the result in <literal>dest</literal>.
</para>
<para> 
<xref linkend="inputs-outputs-for-over-op"/> shows a #GeglOver op.
</para>
<figure id="inputs-outputs-for-over-op">
<title>Over op</title>
<graphic fileref="inputs_outputs_for_over_op.png"></graphic>
</figure>
<para>
Here there are two input images, <literal>foreground</literal> and 
<literal>background</literal> and a boolean <literal>premultiplied</literal> 
input. The output image is <literal>dest</literal>. In this case Over
composites foreground over <literal>background,</literal> premultiplying 
the <literal>foreground</literal> first if the <literal>premultiply</literal> 
flag is set.
</para>
</refsect2>
<refsect2>
<title>Op, Filter, Graph</title>
<para>
Op is the common superclass of #GeglFilter and #GeglGraph. This forms a composite 
or container design pattern (GoF Design Patterns), with #GeglFilter as the "leaf" or 
atomic class, and #GeglGraph as the "composite" or container class. This is
shown in <xref linkend="composite"/>.
<figure id="composite">
<title>Composite or container pattern</title>
<graphic fileref="composite.png"></graphic>
</figure>
</para>
<para>
So <link linkend="GeglFilter">GeglFilter</link>s are the primitive image
processing objects in Gegl and <link linkend="GeglGraph">GeglGraph</link>s 
are containers of other filters and graphs. A #GeglGraph could describe 
a chain or tree of Ops.
</para>
</refsect2>

<refsect2>
<title>Data, Inputs, Outputs</title>
<para>
Ops do their image processing work by operating on inputs to produce outputs.
To describe each input and output, Gegl uses #GeglData objects. For each output
for an op there is a #GeglData object stored in the Op's
<literal>output_data_array</literal> field. This #GeglData object describes the
output data type (image, scalar, pixel, channel value, etc) and holds the value
of the computed result. Likewise, for each input to an Op, there is a #GeglData
object in the Op's <literal>input_data_array</literal> field.  These describe
the type of input data needed by an Op and also hold the input data values the
op will use during operation. Each Op decides how to transform the provided
input data into output data during its operation.  
</para>
<para>
In  <xref linkend="inputs-outputs-for-color-op"/>, <literal>pixel</literal> is 
#GeglPixelData, and <literal>dest</literal> is #GeglImageData. 
In <xref linkend="inputs-outputs-for-fade-op"/>, <literal>source</literal> is 
#GeglImageData, <literal>multiplier</literal> is #GeglScalarData and 
<literal>dest</literal> is #GeglImageData. For  <xref linkend="inputs-outputs-for-over-op"/>
<literal>foreground</literal> and <literal>background</literal> are 
#GeglImageData and <literal>premultiply</literal> is #GeglScalarData. 
</para>
</refsect2>

<refsect2>
<title>Applying an Op</title>
<para>
The most important method in Op is gegl_op_apply(). This is the main image
processing routine. This is where all the action happens. Calling this
method on a Node begins processing the complete graph with that Node
as the root. Everything attached upstream to this Node will be evaluated,
the data pulled through the graph towards the root (the passed Node) and the 
result plopped into the output of the Node. 
<xref linkend="apply"/> shows setting up a #GeglFade op and calling 
apply on it.
<example id="apply"> 
<title>Creating an op and calling apply.</title>
<programlisting>
GeglOp *source = g_object_new(GEGL_TYPE_COLOR, 
                              "width", 720, 
                              "height", 486, 
                              "pixel-rgb-float",.1, .2, .3, 
                              NULL); 

GeglOp *fade = g_object_new(GEGL_TYPE_FADE,
                            "source", source,
                            "multiplier", .5, 
                            NULL);

gegl_op_apply(fade);

g_object_unref(fade);
g_object_unref(source);
</programlisting>
</example>
In this example, no image processing occurs until the call to gegl_op_apply(). 
When that call is finished, the result of the evaluation is in the #GeglData 
object that represents the output for the Op <literal>fade</literal>. This 
#GeglData object is an element in the Op's <literal>output_data_array</literal>.  
Usually the output array just contains one #GeglData element since most Ops have 
produce a single image as output.
</para>

<para>
The method gegl_op_apply_roi() is similar except that you may pass a region 
of interest as well. The image processing in this case will be restricted 
to the passed roi.
</para>

<para>
Calling gegl_op_apply() on the root of a graph causes processing of the 
entire graph in roughly depth-first order. This is done by a #GeglEvalMgr. Ops 
are processed from the leaves of the graph towards the root, with each node waiting 
until inputs are computed before it is evaluated. Once the inputs of a node are 
ready the node is called to perform its operation. <xref linkend="simpleopsgraph"/>
shows setting up a simple graph.
<example id="simpleopsgraph"> 
<title>A Simple graph of Ops.</title>
<programlisting>

  /* 
        iadd              (.55,.7,.85) 
        /   \             /         \ 
     fade  color2   (.05,.1,.15)   (.5,.6,.7)
      |                   | 
     color1          (.1,.2,.3)

  */ 

  GeglOp * color1 = g_object_new(GEGL_TYPE_COLOR, 
                                 "pixel-rgb-float", .1, .2, .3, 
                                 NULL); 

  GeglOp * color2 = g_object_new(GEGL_TYPE_COLOR, 
                                 "pixel-rgb-float", .5, .6, .7, 
                                 NULL); 

  GeglOp * fade = g_object_new (GEGL_TYPE_FADE,
                                "source", color1,
                                "multiplier", .5,
                                NULL); 

  GeglOp * iadd = g_object_new (GEGL_TYPE_I_ADD, 
                                "source-0", fade,
                                "source-1", color2,
                                NULL);  

  gegl_op_apply(iadd); 

  g_object_unref(iadd);
  g_object_unref(fade);
  g_object_unref(color1);
  g_object_unref(color2);
</programlisting>
</example>
The evaluation order of the ops here is: <literal>color1</literal>,
<literal>fade</literal>, <literal>color2</literal>, and 
finally <literal>iadd</literal>. This order is determined by a depth-first 
traversal of the graph. 
</para>
</refsect2>

<refsect2>
<title>Generic Properties</title>
<para>
Gegl uses the idea of generic properties to handle passing data of the 
same generic type but with different data type realizations. For example
pixel values that represent colors can be given alternatively with components
that are given as uint8, float, or uint16 values. These generic properties
correspond to bundles of regular glib properties, installed for each input
that needs to handle several different versions of the data being passed
in a property. As an example let's look at <xref linkend="genericproperties"/> 
where #GeglColor sets up the bundle of glib properties that correspond to it's 
input data "pixel". During the class_init() method of #GeglColor we register a 
regular glib property for each version of the pixel that is needed.
<example id="genericproperties"> 
<title>Pixel property for ColorOp.</title>
<programlisting>
static void 
class_init (GeglColorClass * klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS(klass);

  /* Other init code */ 

  /* Now install the various versions of the property "pixel". */

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGB_FLOAT,
    gegl_param_spec_pixel_rgb_float ("pixel-rgb-float",
                                     "Pixel-Rgb-Float",
                                     "The pixel-rgb-float pixel",
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     0.0, 0.0, 0.0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGBA_FLOAT,
    gegl_param_spec_pixel_rgba_float ("pixel-rgba-float",
                                     "Pixel-Rgba-Float",
                                     "The pixel-rgba-float pixel",
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     -G_MAXFLOAT, G_MAXFLOAT,
                                     0.0, 1.0,
                                     0.0, 0.0, 0.0, 0.0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGB_UINT8,
    gegl_param_spec_pixel_rgb_uint8 ("pixel-rgb-uint8",
                                     "Pixel-Rgb-Uint8",
                                     "The rgb-uint8 pixel",
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 0, 0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_RGBA_UINT8,
    gegl_param_spec_pixel_rgba_uint8 ("pixel-rgba-uint8",
                                     "Pixel-Rgba-Uint8",
                                     "The rgba-uint8 pixel",
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 255,
                                     0, 0, 0, 0,
                                     G_PARAM_READWRITE));

  g_object_class_install_property (gobject_class, PROP_PIXEL_NODE,
               g_param_spec_object ("pixel-node",
                                    "PixelNode",
                                    "The pixel node",
                                     GEGL_TYPE_OP,
                                     G_PARAM_WRITABLE));

  /* More initialization code */
}
</programlisting>
</example>
</para> 
<para> 
We see that we have installed versions of "pixel" for rgb-float, rgba-float,
rgb-uint8, rgba-uint8, and a special node version as well. All of these 
are bundled together and thought of just as the generic property "pixel" 
for input data of #GeglColor. Any of these versions can be plugged
in as the "pixel" input for #GeglColor and will work. This allows setting 
up versions of #GeglColor that correspond to the correct data type. 
<xref linkend="floatcolor"/> shows an example of a float channel version.
<example id="floatcolor"> 
<title>Float version of Color op</title>
<programlisting>
  /* Here's an example of a float pixel constant color image */
  GeglOp *color = g_object_new(GEGL_TYPE_COLOR, 
                               "width", 720, 
                               "height", 486, 
                               "pixel-rgb-float", .1, .2, .3, 
                               NULL); 

  gegl_op_apply(color);
  g_object_unref(color);
</programlisting>
</example>
</para>
<para>
And <xref linkend="uint8color"/> shows an example of a uint8 
version.
<example id="uint8color"> 
<title>Uint8 version of Color op</title>
<programlisting>
  /* Here's an example of a uint8 pixel constant color image */
  GeglOp *color = g_object_new(GEGL_TYPE_COLOR, 
                               "width", 720, 
                               "height", 486, 
                               "pixel-rgb-uint8", 123, 245, 255, 
                               NULL); 

  gegl_op_apply(color);
  g_object_unref(color);
</programlisting>
</example>
</para>
</refsect2>


<!-- ##### SECTION ./tmpl/gegl-op.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-op.sgml:Short_Description ##### -->
Abstract class for operation with inputs and outputs.


<!-- ##### SECTION ./tmpl/gegl-op.sgml:Title ##### -->
GeglOp


<!-- ##### SECTION ./tmpl/gegl-outside.sgml:Long_Description ##### -->
<para>
Composite foreground(f,fa) outside background(b,ba).
Part of the foreground outside of background replaces background.
</para>
<para>
<literallayout>
c = (1-ba) * f 
ca = (1-ba) * fa 
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-outside.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-outside.sgml:Short_Description ##### -->
Composite foreground outside background


<!-- ##### SECTION ./tmpl/gegl-outside.sgml:Title ##### -->
GeglOutside


<!-- ##### SECTION ./tmpl/gegl-over.sgml:Long_Description ##### -->
<para>
This composites foreground (f,fa) over background (b,ba). The foreground is
composited over the background.
</para>
<para>
<literallayout>
c  = f + b*(1-fa)
ca = fa + ba*(1-fa)
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-over.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-over.sgml:Short_Description ##### -->
Composite foreground over background


<!-- ##### SECTION ./tmpl/gegl-over.sgml:Title ##### -->
GeglOver


<!-- ##### SECTION ./tmpl/gegl-pixel-data.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-pixel-data.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-pixel-data.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-pixel-data.sgml:Title ##### -->
GeglPixelData


<!-- ##### SECTION ./tmpl/gegl-pixel.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-pixel.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-pixel.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gegl-pixel.sgml:Title ##### -->
GeglPixel


<!-- ##### SECTION ./tmpl/gegl-premult.sgml:Long_Description ##### -->
<para>
Premultiply the image by the alpha channel.
<literallayout>
A*R
A*G
A*B 
A
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-premult.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-premult.sgml:Short_Description ##### -->
Premultiply image by alpha


<!-- ##### SECTION ./tmpl/gegl-premult.sgml:Title ##### -->
GeglPremult


<!-- ##### SECTION ./tmpl/gegl-screen.sgml:Long_Description ##### -->
<para> 
The foreground and background are complemented and then multiplied and then
replace the background. The resultant color is always at least as light as
either of the two constituent colors. Screening any color with white produces
white.  Screening any color with black leaves the original color unchanged.
<literallayout>
c = f + b - f*b 
ca = fa + ba - fa*ba 
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-screen.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-screen.sgml:Short_Description ##### -->
Composite foreground and background using screen blend mode.


<!-- ##### SECTION ./tmpl/gegl-screen.sgml:Title ##### -->
GeglScreen


<!-- ##### SECTION ./tmpl/gegl-subtract.sgml:Long_Description ##### -->
<para>
Subtract two images.
</para>
<para>
A - B
</para>


<!-- ##### SECTION ./tmpl/gegl-subtract.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-subtract.sgml:Short_Description ##### -->
Subtract two images


<!-- ##### SECTION ./tmpl/gegl-subtract.sgml:Title ##### -->
GeglSubtract


<!-- ##### SECTION ./tmpl/gegl-unpremult.sgml:Long_Description ##### -->
<para>
Unpremultiply the image by the alpha channel.
<literallayout>
R/A
G/A
B/A 
A
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-unpremult.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-unpremult.sgml:Short_Description ##### -->
Unpremultiply the image by alpha


<!-- ##### SECTION ./tmpl/gegl-unpremult.sgml:Title ##### -->
GeglUnpremult


<!-- ##### SECTION ./tmpl/gegl-xor.sgml:Long_Description ##### -->
<para>
Composite foreground(f,fa) exclusive or background(b,ba). The part of the
foreground that lies outside of the background is combined with the part of the
background that lies outside of the foreground.
</para>
<para>
<literallayout>
c = f*(1-ba) + b*(1-fa)  
ca = fa*(1-ba) + ba*(1-fa)
</literallayout>
</para>


<!-- ##### SECTION ./tmpl/gegl-xor.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gegl-xor.sgml:Short_Description ##### -->
Composite foreground xor background


<!-- ##### SECTION ./tmpl/gegl-xor.sgml:Title ##### -->
GeglXor


<!-- ##### MACRO GEGL_FLOAT_TO_UINT8 ##### -->
<para>

</para>

@x: 

<!-- ##### MACRO GEGL_TYPE_COMPONENTS ##### -->
<para>

</para>


<!-- ##### VARIABLE GEGL_TYPE_PARAM_IMAGE ##### -->
<para>

</para>


<!-- ##### MACRO GEGL_VALUE_HOLDS_COMPONENTS ##### -->
<para>

</para>

@value: 

<!-- ##### ARG GeglAdd:constant-rgb-float ##### -->
<para>

</para>


<!-- ##### ARG GeglAdd:constant-rgb-uint8 ##### -->
<para>

</para>


<!-- ##### STRUCT GeglAtop ##### -->
<para>

</para>

@comp: 

<!-- ##### STRUCT GeglAtopClass ##### -->
<para>

</para>

@comp_class: 

<!-- ##### ARG GeglBinary:input-image-a ##### -->
<para>

</para>


<!-- ##### ARG GeglBinary:input-image-b ##### -->
<para>

</para>


<!-- ##### STRUCT GeglChannelData ##### -->
<para>

</para>


<!-- ##### ARG GeglChannelData:float ##### -->
<para>

</para>


<!-- ##### ARG GeglChannelData:uint8 ##### -->
<para>

</para>


<!-- ##### STRUCT GeglChannelDataClass ##### -->
<para>

</para>

@data_class: 

<!-- ##### STRUCT GeglChannelSpace ##### -->
<para>

</para>


<!-- ##### STRUCT GeglChannelSpaceClass ##### -->
<para>

</para>

@object_class: 
@convert_to_float: 
@convert_from_float: 
@convert_value_to_float: 
@convert_value_from_float: 

<!-- ##### STRUCT GeglChannelSpaceFloat ##### -->
<para>

</para>


<!-- ##### STRUCT GeglChannelSpaceFloatClass ##### -->
<para>

</para>

@channel_space_class: 

<!-- ##### STRUCT GeglChannelSpaceU8 ##### -->
<para>

</para>


<!-- ##### STRUCT GeglChannelSpaceU8Class ##### -->
<para>

</para>

@channel_space_class: 

<!-- ##### ARG GeglColor:height ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:pixel-node ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:pixel-rgb-float ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:pixel-rgb-uint8 ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:pixel-rgba-float ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:pixel-rgba-uint8 ##### -->
<para>

</para>


<!-- ##### ARG GeglColor:width ##### -->
<para>

</para>


<!-- ##### ARG GeglColorModel:channel-space ##### -->
<para>

</para>


<!-- ##### ARG GeglComp:input-image-a ##### -->
<para>

</para>


<!-- ##### ARG GeglComp:input-image-b ##### -->
<para>

</para>


<!-- ##### STRUCT GeglComponents ##### -->
<para>

</para>

@num: 
@values: 

<!-- ##### STRUCT GeglConnector ##### -->
<para>

</para>

@node: 
@input: 
@source: 

<!-- ##### STRUCT GeglCopy ##### -->
<para>

</para>

@unary: 

<!-- ##### STRUCT GeglCopyClass ##### -->
<para>

</para>

@unary_class: 

<!-- ##### STRUCT GeglDarken ##### -->
<para>

</para>

@blend: 

<!-- ##### STRUCT GeglDarkenClass ##### -->
<para>

</para>

@blend_class: 

<!-- ##### STRUCT GeglData ##### -->
<para>

</para>


<!-- ##### ARG GeglData:data-name ##### -->
<para>

</para>


<!-- ##### ARG GeglData:param-spec ##### -->
<para>

</para>


<!-- ##### STRUCT GeglDataClass ##### -->
<para>

</para>

@object_class: 

<!-- ##### STRUCT GeglDifference ##### -->
<para>

</para>

@blend: 

<!-- ##### STRUCT GeglDifferenceClass ##### -->
<para>

</para>

@blend_class: 

<!-- ##### ARG GeglEvalMgr:roi ##### -->
<para>

</para>


<!-- ##### ARG GeglEvalMgr:root ##### -->
<para>

</para>


<!-- ##### STRUCT GeglFade ##### -->
<para>

</para>


<!-- ##### ARG GeglFade:multiplier ##### -->
<para>

</para>


<!-- ##### STRUCT GeglFadeClass ##### -->
<para>

</para>

@unary_class: 

<!-- ##### STRUCT GeglFill ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:color ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:color-model-string ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:fill-color ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:height ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:image-data-type ##### -->
<para>

</para>


<!-- ##### ARG GeglFill:width ##### -->
<para>

</para>


<!-- ##### STRUCT GeglFillClass ##### -->
<para>

</para>

@no_input_class: 

<!-- ##### ARG GeglGraph:input ##### -->
<para>

</para>


<!-- ##### ARG GeglGraph:root ##### -->
<para>

</para>


<!-- ##### STRUCT GeglGraphInput ##### -->
<para>

</para>

@node: 
@node_input: 
@graph: 
@graph_input: 

<!-- ##### STRUCT GeglIAdd ##### -->
<para>

</para>


<!-- ##### STRUCT GeglIAddClass ##### -->
<para>

</para>

@binary_class: 

<!-- ##### STRUCT GeglIMult ##### -->
<para>

</para>

@binary: 

<!-- ##### STRUCT GeglIMultClass ##### -->
<para>

</para>

@binary_class: 

<!-- ##### STRUCT GeglInside ##### -->
<para>

</para>

@comp: 

<!-- ##### STRUCT GeglInsideClass ##### -->
<para>

</para>

@comp_class: 

<!-- ##### STRUCT GeglLighten ##### -->
<para>

</para>

@blend: 

<!-- ##### STRUCT GeglLightenClass ##### -->
<para>

</para>

@blend_class: 

<!-- ##### STRUCT GeglMax ##### -->
<para>

</para>

@binary: 

<!-- ##### STRUCT GeglMaxClass ##### -->
<para>

</para>

@binary_class: 

<!-- ##### STRUCT GeglMin ##### -->
<para>

</para>

@binary: 

<!-- ##### STRUCT GeglMinClass ##### -->
<para>

</para>

@binary_class: 

<!-- ##### STRUCT GeglNoInput ##### -->
<para>

</para>


<!-- ##### STRUCT GeglNoInputClass ##### -->
<para>

</para>

@point_op_class: 
@get_scanline_function: 

<!-- ##### ARG GeglNode:input ##### -->
<para>

</para>


<!-- ##### ARG GeglNode:num-inputs ##### -->
<para>

</para>


<!-- ##### ARG GeglNode:num-outputs ##### -->
<para>

</para>


<!-- ##### STRUCT GeglNodeInfo ##### -->
<para>

</para>

@visited: 
@discovered: 
@shared_count: 

<!-- ##### STRUCT GeglNormal ##### -->
<para>

</para>

@blend: 

<!-- ##### STRUCT GeglNormalClass ##### -->
<para>

</para>

@blend_class: 

<!-- ##### STRUCT GeglOp ##### -->
<para>

</para>


<!-- ##### STRUCT GeglOpClass ##### -->
<para>

</para>

@node_class: 

<!-- ##### STRUCT GeglOutside ##### -->
<para>

</para>

@comp: 

<!-- ##### STRUCT GeglOutsideClass ##### -->
<para>

</para>

@comp_class: 

<!-- ##### STRUCT GeglOver ##### -->
<para>

</para>


<!-- ##### STRUCT GeglOverClass ##### -->
<para>

</para>

@comp_class: 

<!-- ##### STRUCT GeglParamSpecImage ##### -->
<para>

</para>

@pspec: 

<!-- ##### ARG GeglPipe:input-image ##### -->
<para>

</para>


<!-- ##### STRUCT GeglPixel ##### -->
<para>

</para>

@object: 

<!-- ##### STRUCT GeglPixelClass ##### -->
<para>

</para>

@object_class: 

<!-- ##### STRUCT GeglPixelData ##### -->
<para>

</para>


<!-- ##### ARG GeglPixelData:rgb-float ##### -->
<para>

</para>


<!-- ##### ARG GeglPixelData:rgb-uint8 ##### -->
<para>

</para>


<!-- ##### ARG GeglPixelData:rgba-float ##### -->
<para>

</para>


<!-- ##### ARG GeglPixelData:rgba-uint8 ##### -->
<para>

</para>


<!-- ##### STRUCT GeglPixelDataClass ##### -->
<para>

</para>

@data_class: 

<!-- ##### STRUCT GeglPremult ##### -->
<para>

</para>


<!-- ##### STRUCT GeglPremultClass ##### -->
<para>

</para>

@unary_class: 

<!-- ##### STRUCT GeglScreen ##### -->
<para>

</para>

@blend: 

<!-- ##### STRUCT GeglScreenClass ##### -->
<para>

</para>

@blend_class: 

<!-- ##### STRUCT GeglSubtract ##### -->
<para>

</para>

@binary: 

<!-- ##### STRUCT GeglSubtractClass ##### -->
<para>

</para>

@binary_class: 

<!-- ##### ARG GeglUnary:input-image ##### -->
<para>

</para>


<!-- ##### STRUCT GeglUnpremult ##### -->
<para>

</para>

@unary: 

<!-- ##### STRUCT GeglUnpremultClass ##### -->
<para>

</para>

@unary_class: 

<!-- ##### USER_FUNCTION GeglValidateDataFunc ##### -->
<para>

</para>

@input_data: 
@other_data: 

<!-- ##### STRUCT GeglXor ##### -->
<para>

</para>

@comp: 

<!-- ##### STRUCT GeglXorClass ##### -->
<para>

</para>

@comp_class: 

<!-- ##### FUNCTION LOG_DEBUG ##### -->
<para>

</para>

@function: 
@format: 
@Varargs: 
@args...: 

<!-- ##### FUNCTION LOG_DIRECT ##### -->
<para>

</para>

@format: 
@Varargs: 
@args...: 

<!-- ##### FUNCTION LOG_INFO ##### -->
<para>

</para>

@function: 
@format: 
@Varargs: 
@args...: 

<!-- ##### FUNCTION LOG_MESSAGE ##### -->
<para>

</para>

@function: 
@format: 
@Varargs: 

<!-- ##### MACRO LOG_MSG ##### -->
<para>

</para>

@function: 
@args...: 

<!-- ##### FUNCTION gegl_add_get_constant ##### -->
<para>

</para>

@self: 
@constant: 

<!-- ##### FUNCTION gegl_add_set_constant ##### -->
<para>

</para>

@self: 
@constant: 

<!-- ##### FUNCTION gegl_binary_get_fade ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_binary_set_fade ##### -->
<para>

</para>

@self: 
@fade: 

<!-- ##### FUNCTION gegl_blend_get_opacity ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_blend_set_opacity ##### -->
<para>

</para>

@self: 
@opacity: 

<!-- ##### FUNCTION gegl_channel_data_get_channel_space ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_bits ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_channel_space_type ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_convert_from_float ##### -->
<para>

</para>

@self: 
@dest: 
@src: 
@num: 

<!-- ##### FUNCTION gegl_channel_space_convert_to_float ##### -->
<para>

</para>

@self: 
@dest: 
@src: 
@num: 

<!-- ##### FUNCTION gegl_channel_space_convert_value_from_float ##### -->
<para>

</para>

@self: 
@dest: 
@src: 

<!-- ##### FUNCTION gegl_channel_space_convert_value_to_float ##### -->
<para>

</para>

@self: 
@dest: 
@src: 

<!-- ##### FUNCTION gegl_channel_space_instance ##### -->
<para>

</para>

@channel_space_name: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_is_channel_data ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_name ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_channel_space_register ##### -->
<para>

</para>

@channel_space: 
@Returns: 

<!-- ##### FUNCTION gegl_color_data_get_color_model ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_color_data_set_color_model ##### -->
<para>

</para>

@self: 
@color_model: 

<!-- ##### FUNCTION gegl_color_get_height ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_color_get_pixel ##### -->
<para>

</para>

@self: 
@pixel: 

<!-- ##### FUNCTION gegl_color_get_width ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_color_model_channel_type ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_color_model_pixel_type ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_color_set_height ##### -->
<para>

</para>

@self: 
@height: 

<!-- ##### FUNCTION gegl_color_set_pixel ##### -->
<para>

</para>

@self: 
@pixel: 

<!-- ##### FUNCTION gegl_color_set_width ##### -->
<para>

</para>

@self: 
@width: 

<!-- ##### FUNCTION gegl_comp_get_premultiply ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_comp_set_premultiply ##### -->
<para>

</para>

@self: 
@premultiply: 

<!-- ##### FUNCTION gegl_data_copy_value ##### -->
<para>

</para>

@self: 
@value: 

<!-- ##### FUNCTION gegl_data_get_name ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_data_get_param_spec ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_data_get_value ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_data_set_name ##### -->
<para>

</para>

@self: 
@name: 

<!-- ##### FUNCTION gegl_data_set_param_spec ##### -->
<para>

</para>

@self: 
@param_spec: 

<!-- ##### FUNCTION gegl_direct_log ##### -->
<para>

</para>

@level: 
@format: 
@Varargs: 

<!-- ##### FUNCTION gegl_direct_logv ##### -->
<para>

</para>

@level: 
@format: 
@args: 

<!-- ##### FUNCTION gegl_dump_graph ##### -->
<para>

</para>

@root: 

<!-- ##### FUNCTION gegl_dump_graph_msg ##### -->
<para>

</para>

@msg: 
@root: 

<!-- ##### FUNCTION gegl_eval_mgr_evaluate ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_eval_mgr_get_roi ##### -->
<para>

</para>

@self: 
@roi: 

<!-- ##### FUNCTION gegl_eval_mgr_get_root ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_eval_mgr_set_roi ##### -->
<para>

</para>

@self: 
@roi: 

<!-- ##### FUNCTION gegl_eval_mgr_set_root ##### -->
<para>

</para>

@self: 
@root: 

<!-- ##### FUNCTION gegl_fade_get_multiplier ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_fade_set_multiplier ##### -->
<para>

</para>

@self: 
@multiplier: 

<!-- ##### FUNCTION gegl_filter_validate_inputs ##### -->
<para>

</para>

@self: 
@collected_data: 
@collected_input_data_list: 
@collected_data_outputs: 
@data_inputs: 

<!-- ##### FUNCTION gegl_filter_validate_outputs ##### -->
<para>

</para>

@self: 
@data_outputs: 

<!-- ##### FUNCTION gegl_graph_find_source ##### -->
<para>

</para>

@self: 
@node: 
@index: 
@Returns: 

<!-- ##### FUNCTION gegl_graph_get_root ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_graph_lookup_input ##### -->
<para>

</para>

@self: 
@node: 
@node_input: 
@Returns: 

<!-- ##### FUNCTION gegl_graph_set_root ##### -->
<para>

</para>

@self: 
@root: 

<!-- ##### FUNCTION gegl_image_op_compute_color_model ##### -->
<para>

</para>

@self: 
@data_inputs: 
@Returns: 

<!-- ##### FUNCTION gegl_image_op_compute_have_rect ##### -->
<para>

</para>

@self: 
@have_rect: 
@data_inputs: 

<!-- ##### FUNCTION gegl_image_op_compute_need_rect ##### -->
<para>

</para>

@self: 
@input_need_rect: 
@need_rect: 
@i: 

<!-- ##### FUNCTION gegl_image_op_compute_need_rects ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_image_op_evaluate_color_model ##### -->
<para>

</para>

@self: 
@data_inputs: 

<!-- ##### FUNCTION gegl_image_op_evaluate_have_rect ##### -->
<para>

</para>

@self: 
@data_inputs: 

<!-- ##### FUNCTION gegl_image_op_evaluate_need_rects ##### -->
<para>

</para>

@self: 
@data_inputs: 

<!-- ##### FUNCTION gegl_image_op_get_image ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_image_op_set_image ##### -->
<para>

</para>

@self: 
@image: 

<!-- ##### FUNCTION gegl_image_param_spec_types_init ##### -->
<para>

</para>


<!-- ##### FUNCTION gegl_log ##### -->
<para>

</para>

@level: 
@file: 
@line: 
@function: 
@format: 
@Varargs: 

<!-- ##### FUNCTION gegl_logv ##### -->
<para>

</para>

@level: 
@file: 
@line: 
@function: 
@format: 
@args: 

<!-- ##### FUNCTION gegl_multi_image_op_compute_color_model ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_multi_image_op_compute_have_rect ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_multi_image_op_compute_need_rects ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_node_accept ##### -->
<para>

</para>

@self: 
@visitor: 

<!-- ##### FUNCTION gegl_node_add_input ##### -->
<para>

</para>

@self: 
@n: 

<!-- ##### FUNCTION gegl_node_add_output ##### -->
<para>

</para>

@self: 
@n: 

<!-- ##### FUNCTION gegl_node_free_inputs ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_node_free_outputs ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_node_get_m_source ##### -->
<para>

</para>

@self: 
@input: 
@output: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_num_inputs ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_num_outputs ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_num_sinks ##### -->
<para>

</para>

@self: 
@output: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_sink ##### -->
<para>

</para>

@self: 
@output: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_sink_input ##### -->
<para>

</para>

@self: 
@output: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_node_get_source ##### -->
<para>

</para>

@self: 
@input: 
@Returns: 
@n: 

<!-- ##### FUNCTION gegl_node_remove_sinks ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_node_remove_sources ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_node_set_m_source ##### -->
<para>

</para>

@self: 
@source: 
@input: 
@output: 

<!-- ##### FUNCTION gegl_node_set_num_inputs ##### -->
<para>

</para>

@self: 
@num_inputs: 

<!-- ##### FUNCTION gegl_node_set_num_outputs ##### -->
<para>

</para>

@self: 
@num_outputs: 

<!-- ##### FUNCTION gegl_node_set_source ##### -->
<para>

</para>

@self: 
@source: 
@input: 
@n: 

<!-- ##### FUNCTION gegl_node_unlink ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_object_add_interface ##### -->
<para>

</para>

@self: 
@interface_name: 
@interface: 

<!-- ##### FUNCTION gegl_object_query_interface ##### -->
<para>

</para>

@self: 
@interface_name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_add_input_data ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 

<!-- ##### FUNCTION gegl_op_add_output_data ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 

<!-- ##### FUNCTION gegl_op_append_data_input ##### -->
<para>

</para>

@self: 
@data: 

<!-- ##### FUNCTION gegl_op_append_data_output ##### -->
<para>

</para>

@self: 
@data: 

<!-- ##### FUNCTION gegl_op_append_input ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 

<!-- ##### FUNCTION gegl_op_append_input_data ##### -->
<para>

</para>

@self: 
@data: 

<!-- ##### FUNCTION gegl_op_append_output ##### -->
<para>

</para>

@self: 
@data_type: 
@name: 

<!-- ##### FUNCTION gegl_op_append_output_data ##### -->
<para>

</para>

@self: 
@data: 

<!-- ##### FUNCTION gegl_op_apply ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_apply_roi ##### -->
<para>

</para>

@self: 
@roi: 

<!-- ##### FUNCTION gegl_op_class_find_data_input_property ##### -->
<para>

</para>

@class: 
@property_name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_class_find_data_output_property ##### -->
<para>

</para>

@class: 
@property_name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_class_install_data_input_property ##### -->
<para>

</para>

@class: 
@pspec: 

<!-- ##### FUNCTION gegl_op_class_install_data_output_property ##### -->
<para>

</para>

@class: 
@pspec: 

<!-- ##### FUNCTION gegl_op_class_list_data_input_properties ##### -->
<para>

</para>

@class: 
@n_properties_p: 
@Returns: 

<!-- ##### FUNCTION gegl_op_class_list_data_output_properties ##### -->
<para>

</para>

@class: 
@n_properties_p: 
@Returns: 

<!-- ##### FUNCTION gegl_op_free_data_inputs ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_free_data_outputs ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_free_input_data_array ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_free_input_data_list ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_free_output_data_array ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_free_output_data_list ##### -->
<para>

</para>

@self: 

<!-- ##### FUNCTION gegl_op_get_data_input ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_data_inputs ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_data_output ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_data_outputs ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_input_data ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_input_data_array ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_input_data_index ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_input_data_list ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_input_data_value ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_nth_input_data ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_nth_output_data ##### -->
<para>

</para>

@self: 
@n: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_output_data ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_output_data_array ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_output_data_index ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_output_data_list ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_op_get_output_data_value ##### -->
<para>

</para>

@self: 
@name: 
@Returns: 

<!-- ##### FUNCTION gegl_op_set_input_data_value ##### -->
<para>

</para>

@self: 
@name: 
@value: 

<!-- ##### FUNCTION gegl_op_set_output_data_value ##### -->
<para>

</para>

@self: 
@name: 
@value: 

<!-- ##### FUNCTION gegl_op_validate_input_data ##### -->
<para>

</para>

@op: 
@collected_input_data_list: 
@func: 

<!-- ##### FUNCTION gegl_op_validate_input_data_array ##### -->
<para>

</para>

@self: 
@collected_array: 
@func: 

<!-- ##### FUNCTION gegl_param_spec_image ##### -->
<para>

</para>

@name: 
@nick: 
@blurb: 
@flags: 
@Returns: 

<!-- ##### FUNCTION gegl_pixel_data_get_color_space ##### -->
<para>

</para>

@self: 
@Returns: 

<!-- ##### FUNCTION gegl_pixel_data_set_color_space ##### -->
<para>

</para>

@self: 
@color_space: 

<!-- ##### FUNCTION gegl_pixel_get_type ##### -->
<para>

</para>

@Returns: 

<!-- ##### FUNCTION gegl_visitor_collect_data_inputs ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_collect_input_data ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_collect_input_data_list ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_get_discovered ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_get_shared_count ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_get_visited ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_node_insert ##### -->
<para>

</para>

@self: 
@node: 

<!-- ##### FUNCTION gegl_visitor_node_lookup ##### -->
<para>

</para>

@self: 
@node: 
@Returns: 

<!-- ##### FUNCTION gegl_visitor_set_discovered ##### -->
<para>

</para>

@self: 
@node: 
@discovered: 

<!-- ##### FUNCTION gegl_visitor_set_shared_count ##### -->
<para>

</para>

@self: 
@node: 
@shared_count: 

<!-- ##### FUNCTION gegl_visitor_set_visited ##### -->
<para>

</para>

@self: 
@node: 
@visited: 

<!-- ##### FUNCTION gegl_visitor_visit_filter ##### -->
<para>

</para>

@self: 
@filter: 

<!-- ##### FUNCTION gegl_visitor_visit_graph ##### -->
<para>

</para>

@self: 
@graph: 

<!-- ##### FUNCTION gegl_visitor_visit_op ##### -->
<para>

</para>

@self: 
@op: 

