<refentry id="gegl-unittests" revision="14 Jan 2003">
<refmeta>
<refentrytitle>Running Unit Tests for GEGL</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GEGL Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Running Unit Tests for GEGL</refname>
<refpurpose>
Compiling and running the unit tests for GEGL.
</refpurpose>
</refnamediv>

<refsect1>
<title>Running Unit Tests for GEGL</title>

<para>
GEGL comes with an extensive set of unit tests used for development and 
testing. These can be found in the <filename>tests</filename> directory. 
The unit test framework that is used is found in the
<filename>tools/testsuite</filename>. You can also read more about it in this
<ulink url="http://www.cuj.com/articles/2000/0009/0009d/0009d.htm?topic=articles">
CUJ article</ulink> as well. There is an example <filename>testcomplex.c</filename> 
in the <filename>tools/testsuite</filename> directory which illustrates how
the library is used. Make sure that <filename>libtestsuite</filename> gets built 
before running the GEGL unit tests.
</para>

<para>
To run the unit tests for GEGL cd to the tests directory and do
the following:
<programlisting>
$ cd tests
$ make check
</programlisting>
This causes the unit tests listed in <filename>testgegl.c</filename>
to be compiled and run. If you want to change the tests that get run
or add some, you can do that in <filename>testgegl.c</filename>.
</para>

</refsect1>

<refsect1>
<title>Typical Unit Test Example</title>

<para>
As a simple example consider <filename>imagetest.c</filename>, which
tests <link linkend="GeglImage">GeglImage</link> objects. The following 
code sets up the tests for this file:
<example> 
<title> A simple unit test file.</title>
<programlisting>
static void
test_image_g_object_new(Test *test)
{
  /* Code for testing g_object_new for image object */ 
}

static void
test_image_construct_properties(Test *test)
{
  /* Code for testing construct properties for image objects */ 
}

static void
image_test_setup(Test *test)
{
  /* Common set up code */ 
}

static void
image_test_teardown(Test *test)
{
  /* Common tear down code */ 
}

Test *
create_image_test()
{
  Test* t = ct_create("GeglImageTest");

  g_assert(ct_addSetUp(t, image_test_setup));
  g_assert(ct_addTearDown(t, image_test_teardown));
  g_assert(ct_addTestFun(t, test_image_g_object_new));
  g_assert(ct_addTestFun(t, test_image_construct_properties));

  return t; 
}
</programlisting>
</example>
Here the create_image_test function will be called by 
<filename>testgegl.c</filename>.
It creates a Test object for this set of tests, and names it
"GeglImageTest". It then adds setup and teardown methods, and 
then two test functions, test_image_g_object_new and 
test_image_construct_properties. Each test function is called
during the testing, with the setup and teardown being called
before and after each test. In this example nothing happens in 
the setup and teardown, but if you wanted to set up some common 
initialization for each test, you could do it there. 
</para>

<para>
Now take a look at the details of test_image_g_object_new:
<example> 
<title> Details of a unit test method.</title>
<programlisting>
static void
test_image_g_object_new(Test *test)
{
  GeglImage * image = g_object_new (GEGL_TYPE_IMAGE, NULL);  

  ct_test(test, image != NULL);
  ct_test(test, GEGL_IS_IMAGE(image));
  ct_test(test, g_type_parent(GEGL_TYPE_IMAGE) == GEGL_TYPE_OBJECT);
  ct_test(test, !strcmp("GeglImage", g_type_name(GEGL_TYPE_IMAGE)));

  g_object_unref(image);
}
</programlisting>
</example>
Here a <link linkend="GeglImage">GeglImage</link> object is created
then there four tests are run. The first tests the image is not
NULL. The second makes sure the object is
a <link linkend="GeglImage">GeglImage</link>.  Next the parent type is
tested to make sure it is
a <link linkend="GeglObject">GeglObject</link>.  Finally the type name
for <link linkend="GeglImage">GeglImage</link> is tested to make sure
it is "GeglImage". Any test failures are reported by the ct_test
function.
</para>

<para>
Unit tests are a great way to learn how GEGL objects work as well. Here's
some of the best examples to look at next:
<variablelist>
  <varlistentry>
    <term><filename>addtest-rgb-float.c</filename></term>
    <listitem><para>How <link linkend="GeglAdd">GeglAdd</link> works.</para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename>imulttest-rgb-float.c</filename></term>
    <listitem><para>How <link linkend="GeglIMult">GeglIMult</link> works.</para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename>simpletreetest-rgb-float.c</filename></term>
    <listitem><para>How trees of ops work.</para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename>graphapplytest-rgb-float.c</filename></term>
    <listitem><para>How graphs and ops work.</para></listitem>
  </varlistentry>
</variablelist>
</para>

</refsect1>

<refsect1>
<title>Mock Objects for Unit Tests</title>
<para>
For unit testing abstract classes it is sometimes easier to create mock objects
that extend from the abstract class. These are used to test functionality of
the abstract class they extend from.  Gegl has some of these mock objects in
the test directory for use in unit testing. They all include "Mock" as part of
the class name. For example GeglMockOp is used in <filename>optest.c</filename>
to test <link linkend="GeglOp">GeglOp</link>.
</para>
</refsect1>

</refentry>
