<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12-20 i686) [Netscape]">
   <title>Generic Channel Data</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#840084" alink="#0000FF">

<div 
CLASS="ARTICLE"
>
<div 
CLASS="TITLEPAGE"
>
<h1 CLASS="TITLE">
<a NAME="AEN2"></a><font size=+2>Generic Channel Data</font></h1>

<div CLASS="AUTHOR"><font size=+0>Calvin Williamson</font>
<br>calvinw@mindspring.com
<p>Caroline Dahll&ouml;f
<br>caro@rhythm.com</div>

<div CLASS="COPYRIGHT">&nbsp;</div>

<div 
CLASS="ABSTRACT"
>This describes an approach for dealing with different
data types that occur in image processing algorithms in gegl or elsewhere,
and how to write generic code for the algorithms. In this approach we attempt
to write very C-like code that contains some embedded generic channel data
and math statements.&nbsp; We then use lex and yacc to parse these embedded
generic channel data declarations and statements out to regular C, the
idea being that except for the details of the channel&nbsp; data math,
the algorithms for different image types are very similar. Hopefully this
can also be a mechanism for supporting various optimization techniques
and autogenerating this kind of code as well.</div>

<hr></div>

<div 
CLASS="TOC"
>
<dl 
>
<dt>
<b>Generic Channel Math</b></dt>

<dt>
<a href="#Channel Type">Channel Type</a></dt>

<dt>
<a href="#ChannelMacros">Channel Macros, Functions</a></dt>

<dt>
<a href="#ChannelnelExpressions">Channel Expressions, Rewrite Rules</a></dt>

<dt>
<a href="#Code Examples">Code Examples</a></dt>

<dt>
<a href="#Vector Space Structure of Channels">Vector Space Structure of
Channels</a></dt>

<dt>
<a href="#Pixel Type">Pixel Type</a></dt>

<br>&nbsp;
<dt>
<b>Code Generation</b></dt>

<dt>
<a href="#Lex/Yacc">LexYacc</a></dt>
</dl>
</div>

<div 
CLASS="SECT1"
>
<h1 CLASS="SECT1">
<a NAME="Channel Type"></a><font size=+2>Channel Type</font></h1>
First, every colormodel has a channel&nbsp; math data type defined, called
here <b><tt>Channel </tt></b>for short.&nbsp; For regular 8bit unsigned
chars
<b><tt>Channel
</tt></b>would just be <b><tt>uint8</tt></b> as usual,&nbsp;
and for floating point channel images it would be <b><tt>float</tt></b>.
This channel math data type has a <b><tt>CHANNEL_MIN</tt></b> and<b><tt>
CHANNEL_MAX </tt></b>which are the max and min values the data type can
obtain. These are not to be confused with the colormodel white point interval,
<b><tt>[0,WP]</tt></b>,
which characterises a "black" to "white" range. We require that <b><tt>[0,WP]</tt></b>
be contained within
<b><tt>[CHANNEL_MIN, CHANNEL_MAX] </tt></b>though.
<p>Here are some important channel data type expressions involved with
generic coding:
<p><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt></b>channel
data&nbsp; in <b><tt>[CHANNEL_MIN, CHANNEL_MAX]</tt></b>
<br><b><tt>FloatChannel&nbsp;&nbsp;&nbsp; </tt></b>float channel data in<b><tt>
[CHANNEL_MIN, CHANNEL_MAX]</tt></b>
<p>In addition we will have occasion to refer to these restrictions of
the above:
<p><b><tt>Channel0W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt></b>channel
data in <b><tt>[0, WP]</tt></b>
<br><b><tt>FloatChannel0W&nbsp;&nbsp; </tt></b>float channel data in <b><tt>[0,
WP]</tt></b>
<h4>
<u>examples:</u></h4>
<b>1) <tt>uint8 </tt></b>with <b><tt>WP= 255</tt></b>:
<blockquote><b><tt>[CHANNEL_MIN, CHANNEL_MAX] </tt></b>is<b><tt> [0,255]</tt></b>
<br><b><tt>Channel </tt></b>is integer channel data in <b><tt>[0, 255]</tt></b>
<br><b><tt>FloatChannel </tt></b>is float channel data in <b><tt>[0.0,
255.0]</tt></b>
<br><b><tt>Channel0W </tt></b>is same as <b><tt>Channel</tt></b>
<br><b><tt>FloatChannel0W </tt></b>is same as <b><tt>FloatChannel</tt></b></blockquote>
<b>2)</b> <b><tt>uint16</tt></b> with <b><tt>WP= 4095</tt></b>:
<blockquote><b><tt>[CHANNEL_MIN, CHANNEL_MAX] </tt></b>is<b><tt> [0,65535]</tt></b>
<br><b><tt>Channel </tt></b>is integer channel data in <b><tt>[0, 65535]</tt></b>
<br><b><tt>FloatChannel </tt></b>is float channel data in <b><tt>[0.0,
65535.0]</tt></b>
<br><b><tt>Channel0W </tt></b>is channel data in<b><tt> [0, 4095]</tt></b>
<br><b><tt>FloatChannel0W </tt></b>is float channel data in <b><tt>[0.0,
4095.0]</tt></b></blockquote>
<b>3)<tt> float </tt></b>with <b><tt>WP = 1.0</tt></b>:
<blockquote><tt><b>[CHANNEL_MIN, CHANNEL_MAX]</b> </tt>is<tt> <b>[FLT_MIN,
FLT_MAX]</b></tt>
<br><b><tt>Channel </tt></b>is float channel data in <b><tt>[FLT_MIN, FLT_MAX]</tt></b>
<br><b><tt>FloatChannel </tt></b>is same as <b><tt>Channel</tt></b>
<br><b><tt>Channel0W </tt></b>is float channel data in<b><tt> [0.0, 1.0]</tt></b>
<br><b><tt>FloatChannel0W </tt></b>is same as <b><tt>Channel0W</tt></b></blockquote>
Note: Perhaps we want to consider spaces with BlackPoint not 0 as well
at some point.</div>

<div 
CLASS="SECT1"
>
<hr>
<h1 CLASS="SECT1">
<a NAME="ChannelMacros"></a><font size=+2>Channel Macros, Functions</font></h1>
We assume there is a way to "multiply" channel math data types:
<p><b><tt>CHANNEL_MULT: Channel x Channel -> Channel</tt></b>
<p>which satisfies the following: If <b><tt>x</tt></b> and&nbsp; <b><tt>y
</tt></b>are
<b><tt>Channel0W</tt></b>,
then so is <b><tt>CHANNEL_MULT(x,y) </tt></b>and&nbsp; <b><tt>CHANNEL_MULT(WP,
WP) = WP</tt></b>.
<p>Also we require a WhitePoint normalization factor, which is a <b><tt>float</tt></b>:
<p><b><tt>WP_NORM = 1.0/(float)WP</tt></b>
<p>Similar to the white point <b><tt>Channel</tt></b> value <b><tt>WP</tt></b>
we denote the <b><tt>Channel</tt></b> zero element by <b><tt>ZERO</tt></b>.
<p>Also we require a way to "round" <b><tt>FloatChannel </tt></b>to <b><tt>Channel
</tt></b>values:
<p><b><tt>CHANNEL_ROUND: FloatChannel -> Channel</tt></b>
<p>We require a way to "clamp" values to the white point interval <b><tt>[0,WP]</tt></b>:
<p><b><tt>WP_CLAMP: Channel -> Channel0W</tt></b>
<br><b><tt>WP_CLAMP: FloatChannel ->&nbsp; FloatChannel0W</tt></b>
<p><b><tt>WP_CLAMP: int, uint -> Channel0W</tt></b>
<br><b><tt>WP_CLAMP: float ->FloatChannel0W</tt></b>
<p>Finally we also need a way to "clamp" values to the channel interval
<b><tt>[CHANNEL_MIN,
CHANNEL_MAX]</tt></b>:
<p><b><tt>CHANNEL_CLAMP: value -> [CHANNEL_MIN, CHANNEL_MAX]</tt></b>
<p>where value could be any type: <b><tt>int</tt></b>, <b><tt>uint</tt></b>,
<b><tt>float</tt></b>,
etc. Specifically we get this:
<p><b><tt>CHANNEL_CLAMP: int,uint -> Channel</tt></b>
<br><b><tt>CHANNEL_CLAMP: float -> FloatChannel</tt></b>
<p><b><tt>Channel </tt></b>values are obviously already clamped like this,
but this is for use when "clamping" another data type down to the <b><tt>Channel
</tt></b>or
<b><tt>FloatChannel
</tt></b>range.
<p>note: It may be better to introduce "high" and "low" clamp versions
of the above to reduce the operations.
<h4>
<u>examples:</u></h4>
<b>1) <tt>uint8</tt></b> with <b><tt>WP = 255</tt></b>:
<blockquote><b><tt>CHANNEL_MULT(x,y)&nbsp;&nbsp;&nbsp;&nbsp; INT_MULT8(x,y,t)</tt></b>
<br><b><tt>WP_NORM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1/255.0</tt></b>
<br><b><tt>CHANNEL_ROUND(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((x) + .5)</tt></b>
<br><b><tt>WP_CLAMP(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CLAMP(x, 0, 255)</tt></b>
<br><b><tt>CHANNEL_CLAMP(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLAMP(x, 0, 255)</tt></b></blockquote>
where<b><tt> INT_MULT8(x,y,t)</tt></b> on the right hand side is a regular
C macro defined like this:
<p><b><tt>#define INT_MULT8(x,y,t) ((t) = (a) * (b) + 0x80, ((((t) >> 8)
+ (t)) >> 8)</tt></b>
<p>and <b><tt>CLAMP</tt></b> is also a regular C macro defined by:
<p><b><tt>#define CLAMP(x,a,b) (((x) > (b)) ? (b) : (((x) &lt; (a)) ? (a)
: (x))</tt></b>
<p><b>2)</b> <b><tt>float </tt></b>with <b><tt>WP = 1.0</tt></b>:
<blockquote><b><tt>CHANNEL_MULT(x,y)&nbsp;&nbsp;&nbsp;&nbsp; x * y</tt></b>
<br><b><tt>WP_NORM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.0</tt></b>
<br><b><tt>CHANNEL_ROUND(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</tt></b>
<br><b><tt>WP_CLAMP(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CLAMP(x, 0.0, 1.0)</tt></b>
<br><b><tt>CHANNEL_CLAMP(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</tt></b></blockquote>
</div>

<div 
CLASS="SECT1"
>
<hr>
<h1 CLASS="SECT1">
<a NAME="ChannelnelExpressions"></a><font size=+2>Channel Expressions ,
Rewrite Rules</font></h1>

<div CLASS="SECT1">We have multiplication, scalar multiplication, addition
and assignment for channel variables (both <b><tt>Channel </tt></b>and
<b><tt>FloatChannel</tt></b>).
<p>In the following <b><tt>x,y</tt></b> represent channel variables (either
<b><tt>Channel</tt></b>
or <b><tt>FloatChannel </tt></b>types) and
<b><tt>a</tt></b> represents
a scalar variable (<b><tt>float</tt></b>,
<b><tt>int</tt></b> or <b><tt>uint</tt></b>).
It makes sense to think of the channel variables as a sort of vector space
(scalar multiplication and addition) with a product defined as well (multiplication)
. This multiplication is the <b><tt>CHANNEL_MULT</tt></b> operation. The
other kind of multiplication is just a scalar variable times a channel
variable.
<h1>
<b><u><font size=+0>multiplication</font></u></b></h1>
<b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- Channel * Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: CHANNEL_MULT(x,y)</tt></b>
<br><b><tt>FloatChannel &lt;- FloatChannel * FloatChannel&nbsp; rewrite
rule: WP_NORM * x * y</tt></b>
<br><b><tt>FloatChannel &lt;- Channel * FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: WP_NORM * x * y</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- Channel / Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: ((x&nbsp; * WP) / y)</tt></b>
<br><b><tt>FloatChannel &lt;- FloatChannel / FloatChannel&nbsp; rewrite
rule: ((x&nbsp; * WP) / y)</tt></b>
<br><b><tt>FloatChannel &lt;- FloatChannel / Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: ((x&nbsp; * WP) / y)</tt></b>
<br><b><tt>FloatChannel &lt;- Channel / FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: ((x&nbsp; * WP) / y)</tt></b>
<p><b><u>scalar multiplication</u></b>
<p><b><tt>FloatChannel &lt;- float * Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- int * Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- uint * Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<p><b><tt>FloatChannel &lt;- float * FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<br><b><tt>FloatChannel &lt;- int * FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<br><b><tt>FloatChannel &lt;- uint * FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: a * x</tt></b>
<p><b><tt>FloatChannel &lt;- Channel / float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x / a</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- Channel / uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x / a</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- Channel / int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x / a</tt></b>
<p><b><u>addition</u></b>
<p><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;- Channel + Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x + y</tt></b>
<br><b><tt>FloatChannel &lt;- FloatChannel + FloatChannel&nbsp; rewrite
rule: x + y</tt></b>
<br><b><tt>FloatChannel &lt;- Channel + FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x + y</tt></b>
<p><b><u>assignment</u></b>
<p><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x = y</tt></b>
<br><b><tt>Channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = FloatChannel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rewrite rule: x = CHANNEL_ROUND(y)</tt></b>
<br>&nbsp;</div>

<div 
CLASS="SECT2"
>
<hr>
<h1 CLASS="SECT2">
<a NAME="Code Examples"></a><font size=+2>Code Examples</font></h1>
This section gives some very simple examples of the generic code and the
re-written (generated) C code. The generic code should make clear when
a scalar multiplication (eg <b><tt>int * Channel</tt></b>) is meant and
when a vector (<b><tt>Channel * Channel</tt></b>)&nbsp; multiplication
is meant. Also
<b><tt>CHANNEL_CLAMP</tt></b>s are actually specified in
the generic code (ie by hand) to avoid having to insert them for each rewritten
rule automatically.&nbsp; This saves unnecessary clamps, as they are not
always needed depending for each algorithm. For floating cases the <b><tt>CHANNEL_CLAMP
</tt></b>has
no effect and just becomes the identity. The assignment rules in the last
section make it possible to write integer channel values mixed with float
values, and at the end if the result has become a <b><tt>FloatChannel</tt></b>,
then a <b><tt>CHANNEL_ROUND</tt></b> will be required upon assignment to
a <b><tt>Channel
</tt></b>variable. Again in the float case the <b><tt>CHANNEL_ROUND</tt></b>
macro is just the identity. The examples below show the generic expression
and then underneath two examples of the corresponding generated code.
<div CLASS="SECT2">
<h4>
<u>examples:</u></h4>
</div>

<div CLASS="SECT2">
<div CLASS="SECT2"><b><tt><font size=+1>1)</font></tt></b>
<p><b><tt>/* generic version*/</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; Channel s1,s2,d;</tt></b>
<p><b><tt>&nbsp; d = s1 * s2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Channel * Channel */</tt></b></div>

<div CLASS="SECT2"><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; unsigned char s1,s2,d;</tt></b>
<p><b><tt>&nbsp; d = INT_MULT8(s1, s2);</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float s1,s2,d;</tt></b>
<p><b><tt>&nbsp; d = s1 * s2;</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt><font size=+1>2)</font></tt></b>
<p><b><tt>/* generic version */</tt></b>
<div CLASS="SECT2"><b><tt>{</tt></b>
<br><b><tt>&nbsp; Channel s, d;</tt></b>
<br><b><tt>&nbsp; int a = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* a is a "scalar" variable */</tt></b>
<p><b><tt>&nbsp; d = CHANNEL_CLAMP(a * s);&nbsp;&nbsp; /* int * Channel
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* note: CHANNEL_CLAMP in generic code */</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation */</tt></b>
<br><b><tt>{</tt></b></div>

<div CLASS="SECT2"><b><tt>&nbsp; unsigned char s, d;</tt></b>
<br><b><tt>&nbsp; int a = 5;</tt></b>
<p><b><tt>&nbsp; d = CLAMP(a * s, 0, 255);</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float s, d;</tt></b>
<br><b><tt>&nbsp; int a = 5;</tt></b>
<p><b><tt>&nbsp; d = a * s;</tt></b>
<br><b><tt>}</tt></b></div>
</div>

<div CLASS="SECT2">&nbsp;
<br><b><tt><font size=+1>3)</font></tt></b>
<p><b><tt>/* generic version*/</tt></b>
<div CLASS="SECT2"><b><tt>{</tt></b>
<br><b><tt>&nbsp; Channel d, s1, s2, s3;</tt></b></div>

<div CLASS="SECT2"><b><tt>&nbsp; d = (s1 + s2 + s3)/3;&nbsp;&nbsp; /* (Channel
+ Channel + Channel)/3 */</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; unsigned char d, s1, s2, s3;</tt></b>
<p><b><tt>&nbsp; d = (s1 + s2 + s3)/3;</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float d, s1, s2, s3;</tt></b>
<p><b><tt>&nbsp; d = (s1 + s2 + s3)/3;</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt><font size=+1>4)</font></tt></b>
<div CLASS="SECT2">&nbsp;
<br><b><tt>/* generic version */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; Channel d, s1, s2, s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* s a Channel, not a scalar! */</tt></b></div>

<div CLASS="SECT2"><b><tt>&nbsp; d = s * s1 + (WP-s) * s2;&nbsp;&nbsp;&nbsp;&nbsp;
/* Channel * Channel + Channel * Channel */</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation*/</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; unsigned char d, s1, s2, s;</tt></b>
<p><b><tt>&nbsp; d = INT_MULT8(s,s1) + INT_MULT8(255-s, s2);</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float d, s1, s2, s;</tt></b>
<p><b><tt>&nbsp; d = s * s1 + (1.0-s) * s2;</tt></b>
<br><b><tt>}</tt></b></div>
</div>
</div>

<p><br><b><tt><font size=+1>5)</font></tt></b>
<div CLASS="SECT2">&nbsp;
<br><b><tt>/* generic version */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; Channel d, s1, s2, s3;</tt></b></div>

<div CLASS="SECT2"><b><tt>&nbsp; d = CHANNEL_CLAMP(s1 * s2 + s3);&nbsp;&nbsp;&nbsp;
/* (Channel * Channel) + Channel */</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation*/</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; unsigned char d, s1, s2, s3;</tt></b>
<p><b><tt>&nbsp; d = CLAMP(INT_MULT8(s1,s2) + s3, 0, 255);</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float d, s1, s2, s3;</tt></b>
<p><b><tt>&nbsp; d = s1 * s2 + s3;</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt><font size=+1>6)</font></tt></b>
<p><b><tt>/* generic version */</tt></b></div>
<b><tt>{</tt></b>
<div CLASS="SECT2"><b><tt>&nbsp; Channel d, s1, s2, s3;</tt></b>
<br><b><tt>&nbsp; float weight = .333;</tt></b></div>

<div CLASS="SECT2"><b><tt>&nbsp; d = weight * (s1 + s2 + s3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Channel = float * (Channel + Channel + Channel) */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Channel = FloatChannel */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* rhs is FloatChannel so will involve CHANNEL_ROUND*/</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* u8 version after code generation*/</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; unsigned char d, s1, s2, s3;</tt></b>
<br><b><tt>&nbsp; float weight = .333;</tt></b>
<p><b><tt>&nbsp; d = ROUND(weight * (s1 + s2 + s3));</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>/* float version after code generation */</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; float d, s1, s2, s3;</tt></b>
<br><b><tt>&nbsp; float weight = .333;</tt></b>
<p><b><tt>&nbsp; d = weight * (s1 + s2 + s3);</tt></b>
<br><b><tt>}</tt></b></div>
</div>

<div CLASS="SECT2">
<div CLASS="SECT2">&nbsp;
<p>
<hr>
<h1 CLASS="SECT2">
<a NAME="Vector Space Structure of Channels"></a><font size=+2>Vector Space
Structure of Channels</font></h1>
Heres some more discussion of the vector space of the <b><tt>Channel</tt></b>
data type:
<p>As a quick review of vector spaces, if you have two vectors <b><tt>v1</tt></b>
and <b><tt>v2</tt></b>, then the sum <b><tt>v1 + v2</tt></b>&nbsp; is also
vector.&nbsp; If you multiply a vector <b><tt>v</tt></b> by a scalar <b><tt>c</tt></b>
the result <b><tt>c*v</tt></b> is also a vector. If you are lucky there
will be some type of vector multiplication defined for your vector space(like
for matrices). You cannot add a vector <b><tt>v</tt></b> and a scalar <b><tt>c
</tt></b>though.
So <b><tt>v + c</tt></b> doesnt make sense.
<p>For the <b><tt>Channel</tt></b> data type, we do have a vector space
(channels are components of n-tuples that you can add and multiply by scalars),
but we also have clipping and rounding operations due to data type restrictions.
For example, <b><tt>uint8</tt></b>s certainly dont form a vector space
by themselves (eg no additive inverse <b><tt>-v</tt></b> exists in the
<b><tt>uint8</tt></b>
data type space. ) . But the uint8 <b><tt>Channel</tt></b> type is embedded
in some larger vector space, and so they act like them but with clipping
and rounding restrictions.
<p>The "vector multiplication" thats defined here is the <b><tt>CHANNEL_MULT.
</tt></b>This
is usually defined as some macro trickery to really just do this : If <b><tt>x,
y</tt></b>&nbsp; are <b><tt>Channels</tt></b>&nbsp; then a <b><tt>Channel</tt></b>
multiplication of&nbsp; these is just <b><tt>(x * y)/WP</tt></b>.&nbsp;
Here <b><tt>WP</tt></b> is just the normalizing white point constant and
the division is just regular division. That is one way to define <b><tt>CHANNEL_MULT</tt></b>:
<b><tt>Channel
x Channel -> Channel</tt></b> . There may be fancier and faster ways, like
the
<b><tt>INT_MULT
</tt></b>macros which use shifts instead of integer
division but they are basically just a better version of<b><tt> (x * y)/WP</tt></b>.
<p>All the usual math with <b><tt>int</tt></b>s, <b><tt>float</tt></b>s,
<b><tt>uint</tt></b>s
and so on is now thought of as"scalar" math. In addition we have the math
of <b><tt>Channel</tt></b>s and <b><tt>FloatChannel</tt></b>s thrown in
as well. (<b><tt>FloatChannel</tt></b>s are basically a <b><tt>Channel</tt></b>
with a float granularity, so they are vector type things as well.)
<p><b><u>example:</u></b>
<p><b><tt>int f, g, h;</tt></b>
<br><b><tt>Channel u,v;</tt></b>
<p><b><tt>h = f * g;&nbsp;&nbsp;&nbsp; //regular C ints, a scalar = scalar
* scalar operation.</tt></b>
<p><b><tt>u = f * v;&nbsp;&nbsp;&nbsp; //a Channel = scalar * Channel,
so a "vector" expression.</tt></b>
<p>So when you are constructing the generic algorithms...you would never
do this:
<p><b><u>example:</u></b>
<p><b><tt>int f;</tt></b>
<br><b><tt>Channel d, s;</tt></b>
<p><b><tt>d = s + f;&nbsp; //adding a vector and a scalar--not allowed.</tt></b>
<p>But you might do this:
<p><b><tt>d = s + f*WP&nbsp;&nbsp; //WP represents the Channel constant
WP</tt></b>
<p>This makes perfect sense now, since here <b><tt>WP</tt></b> is a "vector",
so <b><tt>f * WP</tt></b> is a "vector" as well. Now <b><tt>f *WP</tt></b>
might take you out of the data type space,&nbsp; and thats where the <b><tt>CHANNEL_CLAMP</tt></b>s
are needed. You have to always restrict your vector space back down to
the channel data type.
<br>&nbsp;
<div CLASS="SECT2">
<div CLASS="SECT2">
<hr>
<h1 CLASS="SECT2">
<a NAME="Pixel Type"></a><font size=+2>Pixel Type</font></h1>
With the above <b><tt>Channel</tt></b> type, we can now define a vector
of
<b><tt>Channel</tt></b>s, which we call a <b><tt>Pixel</tt></b>. <b><tt>Pixel</tt></b>s
will be used for the n-tuple that represents the color and (optional) alpha
channel of pixel data. The number of color channels depends on the type
of color model, and the <b><tt>Channel</tt></b> type of course is fixed
by the color model's channel data type.
<p>The mathematics of the <b><tt>Pixel</tt></b> type follows from the math
of the <b><tt>Channel</tt></b> type.&nbsp; <b><tt>Pixel</tt></b>s have
a dimension that is given by the number of components in the vector.&nbsp;
Operations with <b><tt>Pixel</tt></b>s of different dimension are not allowed.
Multiplication of <b><tt>Pixel</tt></b>s by scalars and multiplication
of <b><tt>Pixel</tt></b>s by <b><tt>Channel</tt></b>s is defined componentwise
in the natural way. <b><tt>Pixel</tt></b> vector multiplication (<b><tt>Pixel</tt></b>
* <b><tt>Pixel</tt></b> ) is also defined componentwise.
<p>We use <b><tt>WP</tt></b> to denote the <b><tt>Pixel</tt></b> whose
components are all the <b><tt>Channel</tt></b> white point value. Note
we use <b><tt>WP</tt></b> for the single <b><tt>Channel</tt></b> representing
the <b><tt>WP</tt></b> as well, with the meaning clear from the context.
Likewise,
<b><tt>ZERO</tt></b> will denote the <b><tt>Pixel</tt></b> (or
<b><tt>Channel</tt></b>)
whose components are the zero
<b><tt>Channel</tt></b> value.
<p><b><tt><u>examples:</u></tt></b>
<p>1) Multiplication <b><tt>Channel * Pixel</tt></b>
<p>If&nbsp; <b><tt>Pixel d</tt></b>&nbsp; is given by
<p><b><tt>d = [d_r, d_g, d_b]</tt></b>
<p>and <b><tt>a</tt></b> is a <b><tt>Channel</tt></b> then
<p><b><tt>a * d = [a * d_r, a * d_g, a * d_b]</tt></b>
<p>and each component is a <b><tt>Channel * Channel </tt></b>multiplication.
<p>2) Multiplication <b><tt>Pixel</tt> *</b> <b><tt>Pixel</tt></b>
<p>If <b><tt>Pixel</tt></b>s <b><tt>d</tt></b> and <b><tt>s</tt></b> are
given by
<p><b><tt>d = [d_r, d_g, d_b]</tt></b>
<br><b><tt>s = [s_r, s_g, s_b]</tt></b>
<p>Then
<p><b><tt>d * s = [d_r * s_r, d_g * s_g, d_b * s_b]</tt></b>
<p>and each component is a <b><tt>Channel * Channel</tt></b> multiplication.
<br>&nbsp;</div>
</div>
</div>
</div>
</div>

<div 
CLASS="SECT2"
>
<hr>
<h1 CLASS="SECT2">
<a NAME="Lex/Yacc"></a><font size=+2>Lex/Yacc</font></h1>
See <a href="genericImageLanguage.html">Generic Image Language </a>for
details.</div>
</div>

<div 
CLASS="SECT1"
>
<div 
CLASS="FORMALPARA"
>
<div CLASS="SECT1">
<hr></div>
</div>
</div>

<div 
CLASS="SECT1"
>&nbsp;
<h1 CLASS="SECT1">
<a NAME="References"></a><font size=+2>References</font></h1>

<ul 
><a href="genericImageLanguage.html">Generic Image Language</a>
<br><a href="http://www.oreilly.com/catalog/lex">Lex &amp; Yacc</a>
<br><a href="http://www.lysator.liu.se/c/ANSI-C-grammar-y.html">C code
Yacc Parser</a>
<br><a href="http://www.lysator.liu.se/c/ANSI-C-grammar-l.html">C code
Lexer</a>
<br><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra">Vigra1.0
Image Processing Lib</a></ul>
</div>
</div>

</body>
</html>
