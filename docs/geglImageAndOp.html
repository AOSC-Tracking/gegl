<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; I; Linux 2.2.13 i686) [Netscape]">
   <title>Gegl Image Classes</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#840084" alink="#0000FF">

<div 
CLASS="ARTICLE"
>
<div 
CLASS="TITLEPAGE"
>
<h1 CLASS="TITLE">
<a NAME="AEN2"></a><font size=+2>Gegl Image Classes</font></h1>

<div CLASS="AUTHOR"><font size=+0><b>Calvin Williamson&nbsp;</b>&nbsp;
calvinw@mindspring.com</font></div>

<div CLASS="AUTHOR"><font size=+0><b>Jay Cox&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font>jaycox@gimp.org</div>
<b>Caroline Dahll&ouml;f</b>&nbsp;&nbsp;&nbsp;&nbsp; caro@rhythm.com
<br>&nbsp;
<div 
CLASS="AFFILIATION"
>
<div 
CLASS="ADDRESS"
>
<div CLASS="ADDRESS">This is a simple example that illustrates how to treat
Image and Op classes in gegl so that chaining of image operations is possible.
This allows one to combine multiple operations easily and arrange for allocating
temporary buffers automatically when computing such effects.&nbsp; It requires
that Ops and ImageBuffers both be treated as something that can produce
pixels on demand (with the same call, <b><tt>get_pixels</tt>)</b> and place
them into a user supplied destination. This also allows us to use Ops as
inputs to further Ops, and so create chains and trees of image operations
or filters.
<p>The example classes below assume for now that ImageBuffers have simple
pointers to their data and that the data is completely loaded into memory
(no tiles or swapping or caches or files for now, just pointers to channel
data).
<p>Most of this is just a simplified version of the <a href="http://techpubs.sgi.com/library/dynaweb_bin/ebt-bin/0650/nph-infosrch.cgi/infosrchtpl/SGI_Developer/IL_PG/@InfoSearch__BookTextView/44">ImageVision
</a>model.&nbsp;
The documentation for that library is a good source for motivation. Jay
Cox suggested we try some of this approach in <a href="http://www.mindspring.com/~calvinw/geglClasses.html">gegl.</a></div>
</div>
</div>

<hr></div>

<div 
CLASS="TOC"
>
<dl 
>
<dt>
<b>Gegl Image Classes</b></dt>

<dt>
<a href="#GeglImage">GeglImage</a></dt>

<dt>
<a href="#GeglOp">GeglOp</a></dt>

<dt>
<a href="#GeglImageBuffer">GeglImageBuffer</a></dt>

<dt>
<a href="#GeglIterator">GeglIterator</a></dt>

<dt>
<a href="#ImageChainsExamples">Image Chain Examples</a></dt>
</dl>
</div>

<div 
CLASS="SECT1"
>
<h1>

<hr></h1>

<h1 CLASS="SECT1">
<a NAME="GeglImage"></a><font size=+2>GeglImage</font></h1>
This is an abstract base class with a virtual <b><tt>get_pixels</tt></b>
method. Both Ops and ImageBuffers inherit from this class:
<p><b><tt>GeglImage</tt></b>
<br><b><tt>&nbsp;&nbsp; GeglOp</tt></b>
<br><b><tt>&nbsp;&nbsp; GeglImageBuffer</tt></b>
<p>So both ops (GeglOp) and images inherit from the common class GeglImage.
<p><b><tt>abstract</tt></b>
<br><b><tt>Class GeglImage from GeglObject</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; private int width;</tt></b>
<br><b><tt>&nbsp; private int height;</tt></b>
<br><b><tt>&nbsp; private GeglColorModel *cm;</tt></b>
<p><b><tt>&nbsp; /* Get pixels from the (input)sources and place in dest
*/</tt></b>
<br><b><tt>&nbsp; virtual public GeglImage* get_pixels(self,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglImage *dest,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *roi);</tt></b>
<p><b><tt>&nbsp; /* Copy pixels into this image from a passed src */</tt></b>
<br><b><tt>&nbsp; virtual public void copy_pixels(self,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *self_rect,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglImage *src,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *src_rect);</tt></b>
<p><b><tt>&nbsp; virtual boolean is_writable(self);</tt></b>
<p><b><tt>};</tt></b>
<p>The <b><tt>get_pixels</tt></b> routine is overridden by subclasses in
different ways.&nbsp; Ops will implement <b><tt>get_pixels</tt></b> to
place the result of their operation in <b><tt>dest</tt></b>. ImageBuffers
will implement <b><tt>get_pixels</tt></b> to just copy their image data
to <b><tt>dest</tt></b>. If the user supplied Image <b><tt>dest</tt></b>
is <b><tt>NULL</tt></b> then an Op will allocate a temporary buffer&nbsp;
for the result and pass this back when returning from the function .&nbsp;
The rect passed is a region of interest for the destination.
<p>It may be that the above is replaced with Iterators in certain places
instead of ImageBuffers,/Images once we are farther along. This would allow
to store the temp buffers in the Iterators instead of as part of the Op
itself. Basically this would allow easier multithreaded/multiprocessor
support. Also we will likely want to do versions of the above that are
non-blocking (and just queue requests for portions of the image) so that
results can be delivered in a work proc style fashion (in gimp <b><tt>image_map</tt></b>
style)
<p>There is a fundamental difference between Ops and ImageBuffers though.
Ops cant have data "copied" into them from the outside. They arent writable.
You can write to ImageBuffers, but not to Ops. So Ops will implement <b><tt>copy_pixels
</tt></b>by
returning an error<b><tt>. </tt></b>But ImageBuffers will implement
<b><tt>copy_pixels
</tt></b>so
that passed src data is copied to the ImageBuffer<b><tt>.</tt></b> Essentially
Ops can produce image data only by pulling and operating on their inputs
(<b><tt>get_pixels</tt></b>), never by "copying "data directly in.</div>

<div 
CLASS="SECT1"
>&nbsp;</div>

<div 
CLASS="SECT1"
>
<hr>
<h1 CLASS="SECT1">
<a NAME="GeglOp"></a><font size=+2>GeglOp</font></h1>
This is the basic op class for gegl. Each Op is seen as something with
a number of sources (inputs) and parameters that determine its operation.&nbsp;
The Op uses these together and during its operation places its result in
a user-supplied <b><tt>dest</tt></b> (output) Image or allocates a result
buffer itself (if <b><tt>dest</tt></b> is <b><tt>NULL</tt></b>). During
a <b><tt>get_pixels</tt></b> call, it fills in the result buffer and returns
it. Before it does its image processing it also calls each of its sources
<b><tt>get_pixels
</tt></b>routines
to allow them to get ready .
<br>&nbsp;
<div CLASS="SECT1"><b><tt>abstract class GeglOp from GeglImage</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; private GeglImage **sources;&nbsp;&nbsp; /* the input
sources&nbsp; (ops or images)*/</tt></b>
<br><b><tt>&nbsp; private GeglRect *source_rois; /* rois of sources&nbsp;
*/</tt></b>
<br><b><tt>&nbsp; private gint num_sources;</tt></b>
<br><b><tt>&nbsp; private GeglImageBuffer **input_buffers; /* actual input
buffers needed--</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
some temp, some actual images */</tt></b>
<p><b><tt>&nbsp; GeglImage*</tt></b>
<br><b><tt>&nbsp; get_pixels (GeglImage *self,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglImage *dest,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *roi)</tt></b>
<br><b><tt>&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglOp *self_op = GEGL_OP (self);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglRect dest_rect;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gint i;</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* If dest exists but isnt writable return
NULL */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; if (dest &amp;&amp; !gegl_image_is_writable
(dest))</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_warning("gegl_op_get_pixels:
dest is not writable.\n");</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Determine all the source rois, from the
passed roi */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_op_compute_source_rois (self_op, roi);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Ready each source input */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; self_op->_priv->num_sources;
i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { self_op->_priv->input_buffers[i]
= GEGL_IMAGE_BUFFER(</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gegl_image_get_pixels (</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self_op->_priv->sources[i],</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NULL,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;self_op->_priv->source_rois[i]));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Determine colormodel of this ops result
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; compute_color_model (self_op, dest);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Allocate a temp dest buffer for result
if needed */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; if (!dest)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Allocate
the temp dest (actually it is an ImageBuffer)*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dest = GEGL_IMAGE
(gegl_image_buffer_new (</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self->_priv->color_model,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
roi->w,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
roi->h));</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!dest)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g_warning("gegl_op_get_pixels: Cant allocate temp data\n");</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return NULL;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gegl_rect_set
(&amp;dest_rect,0,0,roi->w,roi->h);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; else</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gegl_rect_copy(&amp;dest_rect,
roi);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Initialize anything that depends on inputs
being present */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_op_prepare (self_op,dest,&amp;dest_rect);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Everything is ready, actually do the op
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_op_apply (self_op, dest, &amp;dest_rect);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Delete any temp buffers used for inputs
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; self_op->_priv->num_sources;
i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Free any non writable
input data */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!gegl_image_is_writable(self_op->_priv->sources[i]))</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gegl_object_destroy(GEGL_OBJECT(</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self_op->_priv->input_buffers[i]));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; return dest;</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<p><b><tt>&nbsp; /* called after all the inputs are present, before the
actual apply*/</tt></b>
<br><b><tt>&nbsp; virtual protected void prepare (self, GeglImage *dest,
GeglRect *dest_rect);</tt></b>
<p><b><tt>&nbsp; /* this does the apply once all the inputs are present
and ready */</tt></b>
<br><b><tt>&nbsp; virtual protected void apply (self, GeglImage *dest,
GeglRect *dest_rect);</tt></b>
<p><b><tt>&nbsp;&nbsp; /*A subclass implements this for their particular
operation. */</tt></b>
<br><b><tt>&nbsp;&nbsp; virtual private void scanline_func (self);</tt></b>
<br><b><tt>}</tt></b>
<br>&nbsp;
<br>&nbsp;
<p>The version above just allocates a temp buffer at each node if it is
not a leaf node or the root node. We can improve on this as well with caching,
tilng, and some memory management. But the above has no more than num_sources
+ 1 temp buffers in use at a time.
<br>
<hr>
<h1 CLASS="SECT1">
<a NAME="GeglImageBuffer"></a><font size=+2>GeglImageBuffer</font></h1>
This is the basic standard image class for gegl. The image data here is
allocated and resides in memory. Right now we think of the image data as
just pointers to separate channels in main memory. Later we will do tiles
or other storages and caches and handle other&nbsp; memory management issues.
<p><b><tt>class GeglImageBuffer from GeglImage</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; private guchar **data;&nbsp;&nbsp;&nbsp; /* channel data
pointers */</tt></b>
<p><b><tt>&nbsp; /* data and methods */</tt></b>
<p><b><tt>&nbsp; /* Heres the ImageBuffer's version of get_pixels */</tt></b>
<br><b><tt>&nbsp; GeglImage *</tt></b>
<br><b><tt>&nbsp; get_pixels (GeglImage *self,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglImage *dest,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *roi)</tt></b>
<br><b><tt>&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; /* check for leaf of chain, just return if
it is one */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; if (dest == NULL)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; if (!gegl_image_is_writable(dest))</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_warning("gegl_image_buffer_get_pixels:
dest not writable\n");</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Otherwise copy pixels from me to dest */</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; g_warning("gegl_image_buffer_get_pixels: routine
not implemented yet!\n");</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; return dest;</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<p><b><tt>&nbsp; void</tt></b>
<br><b><tt>&nbsp; copy_pixels (GeglImage *self,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *self_rect,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglImage *src,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect&nbsp; *src_rect)</tt></b>
<br><b><tt>&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; /* This will write to self from src */</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<p><b><tt>&nbsp; boolean is_writable(self)</tt></b>
<br><b><tt>&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<br><b><tt>}</tt></b></div>

<div 
CLASS="SECT2"
>
<hr>
<h1 CLASS="SECT2">
<a NAME="GeglIterator"></a><font size=+2>GeglIterator Classes</font></h1>

<div CLASS="SECT2">These classes are&nbsp; responsible for returning pointers
to image data for an ImageBuffer and keeping track of these during image
operations. You use iterators anytime you need data from an ImageBuffer/Image
and are going to access pixels.&nbsp; The current class is just a stand
in for what may be several classes of iterators eventually to allow accessing
image data in different ways. Right now an iterator is returned for a particular
<b><tt>current_rect</tt></b>.
The pointers returned in <b><tt>get_scanline_data
</tt></b>are the scanline
pointers to the current line in that rectangle. The pointers are advanced
to the next scanline with <b><tt>next_scanline</tt></b>.&nbsp; and reset
to the first scanline in the current_rect with<tt> <b>begin_scanline</b></tt>.
Since ImageBuffers are currently just data pointers to separate channels,
<b><tt>get_scanline_data
</tt></b>returns
an array of pointers to the channels for the current scanline.</div>

<div CLASS="SECT2">&nbsp;
<br><b><tt>GeglIterator</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; private GeglRect current_rect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* the rect we work on */</tt></b>
<br><b><tt>&nbsp; private int current_scanline;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* current scanline in the rect */</tt></b>
<br><b><tt>&nbsp; private unsigned char *scanline_data[];&nbsp;&nbsp; /*
pointers to scanline data */</tt></b>
<p><b><tt>&nbsp; GeglIterator * new(GeglRect *rect)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_rect = rect;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_scanline = 0;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b><b><tt></tt></b>
<p><b><tt>&nbsp; /* TODO: Destroy functions */</tt></b>
<p><b><tt>&nbsp; /* These update current scanline and pointers to data
*/</tt></b>
<p><b><tt>&nbsp; void next_scanline (self) = 0;</tt></b>
<br><b><tt>&nbsp; void goto_scanline (self, int scanline) = 0;</tt></b>
<br><b><tt>&nbsp; void get_scanline_data (self, Pixel **data_ptrs) = 0;</tt></b>
<br><b><tt></tt></b>&nbsp;<b><tt></tt></b>
<p><b><tt>&nbsp; boolean writeable() = 0;</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>GeglImageBufferIterator from GeglIterator</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>/* Ultimatly The Image Buffer Iterator will ref a tile in the
image buffer</tt></b>
<br><b><tt>&nbsp;&nbsp; and unref it when it is finished */</tt></b>
<br><b><tt>&nbsp; private GeglImageBuffer *image_buffer;&nbsp;&nbsp;&nbsp;
/* image buffer we point to */</tt></b>
<br><b><tt>&nbsp; GeglImageBufferIterator * new(GeglImageBuffer *buffer,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglRect *rect) : GelgImage(rect)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_buffer = buffer;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp; void next_scanline(self)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (current_scanline &lt;
current_rect->height - 1)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_scanline++;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp; void goto_scanline(self, int scanline)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_return_if_fail(scanline
>= 0);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_return_if_fail(scanline
&lt; current_rect->height);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_scanline = scanline;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp; void get_scanline_data(self, Pixel **data_ptrs)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; image_buffer->num_channels;
i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_ptrs[i] = image_buffer->get_channel(scanline
+ current_rect->y, i)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+ image_buffer->cm->bytes_per_channel * current_rect->x;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp; boolean writeable()</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return image_buffer->writeable();</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>}</tt></b>
<p><b><tt>GeglConstantIterator from GeglIterator</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp; void *channels[];</tt></b>
<br><b><tt>&nbsp; GeglConstantIterator * new(GeglColor color, GeglRect
*rect) : GelgImage(rect)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; channels = g_new(void *,
color->num_channels);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;
color->num_channels; i++);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; channels[i]
= g_new(char, color->bytes_per_channel;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TODO: fill channels
with the passed in color */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp; void next_scanline(self)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; { /* do nothing*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>&nbsp; void goto_scanline(self, int scanline)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; { /* do nothing */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp; void get_scanline_data(self, Pixel **data_ptrs)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; image_buffer->num_channels;
i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_ptrs[i] = channels[i];</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b><b><tt></tt></b>
<p><b><tt>&nbsp; boolean writeable()</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; }</tt></b>
<br><b><tt>}</tt></b>
<br>&nbsp;
<p>
<hr>
<h1 CLASS="SECT2">
<a NAME="ImageChainsExamples"></a><font size=+2>Image Chains Examples</font></h1>

<div CLASS="SECT2">Image chains are just graphs representing a sequence
of Ops to be applied to produce a destination image. These have a natural
tree structure with the root being the target destination and the leaf
nodes being input images. Other nodes represent Ops to be applied to inputs
with outputs being passed along the graph.&nbsp; First lets just look at
a single Op:
<p><b><tt>example: single op--invert</tt></b>
<p><b><tt>{</tt></b>
<br><b><tt>&nbsp; /* Get a source and dest from somewhere */</tt></b>
<br><b><tt>&nbsp; GeglImage *src = ...</tt></b>
<br><b><tt>&nbsp; GeglImage *dest = ...</tt></b>
<br><b><tt>&nbsp; GeglRect roi_rect = choose your rect</tt></b>
<p><b><tt>&nbsp; /* Set up the op. No image processing happens here, just
setup */</tt></b>
<br><b><tt>&nbsp; GeglImage *invert = gegl_invert_op_new (src, .2);</tt></b>
<p><b><tt>&nbsp; /* Apply the above */</tt></b>
<br><b><tt>&nbsp; gegl_image_get_pixels (invert, dest, &amp;roi_rect);</tt></b>
<p><b><tt>}</tt></b>
<p><b><tt>get_pixels</tt></b> applies the operator. It gets passed a <b><tt>dest</tt></b>
image and a region of interest.
<p>Heres an example of a brightness op followed by a contrast op and applied
to an input image.</div>

<div CLASS="SECT2">&nbsp;
<br><b><tt>example: brightness followed by a contrast</tt></b>
<p><b><tt>{</tt></b>
<br><b><tt>&nbsp; /* Get a source and dest from somewhere */</tt></b>
<br><b><tt>&nbsp; GeglImage *src = ...</tt></b>
<br><b><tt>&nbsp; GeglImage *dest = ...</tt></b>
<br><b><tt>&nbsp; GeglRect roi_rect = choose your rect</tt></b>
<p><b><tt>&nbsp; /* Set up the ops. No image processing happens here, just
setup */</tt></b>
<br><b><tt>&nbsp; GeglImage *bright = gegl_brightness_op_new (src, .2);</tt></b>
<br><b><tt>&nbsp; GeglImage *contrast = gegl_contrast_op_new (bright, .7);</tt></b>
<p><b><tt>&nbsp; /* Apply the above */</tt></b>
<br><b><tt>&nbsp; gegl_image_get_pixels (contrast, dest, roi_rect);</tt></b>
<p><b><tt>}</tt></b>
<p>Heres the Image chain that goes with this code:
<p><b><tt>&nbsp;&nbsp;&nbsp; src ----------bright ---------contrast</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp; &lt;--get_pixels&nbsp;&nbsp; &lt;--get_pixels&nbsp;&nbsp;&nbsp;
&lt;--get_pixels</tt></b>
<br>&nbsp;
<p>The last get_pixels on contrast triggers the evaluation of the chain
.&nbsp; The get_pixels calls propagate to the src leaf, then the image
processing begins at the brightness node first and then that result is
passed back to the contrast node which finishes it off and puts it into
dest.&nbsp; With multi-source ops involved you will get a more complicated
tree graph with images at the leaf nodes.&nbsp; The same get_pixels on
the root node will cause the whole graph to be computed.</div>
</div>
</div>
</div>

<hr>
<h2>
Revised Class structure:</h2>

<pre><b>GeglImage
&nbsp;&nbsp;&nbsp; GeglImageBuffer
&nbsp;&nbsp;&nbsp; GeglOperatorCache
&nbsp;&nbsp;&nbsp; GeglConstantImage
&nbsp;&nbsp;&nbsp; GeglOperator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglAreaOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglConvolveOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglBlurOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglSharpenOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglLaplaceOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglSobelOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglRobertsonOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglKernalOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglKernalMedianOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglKernalMaxOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglKernalMinOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglPointOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglSingleSrcOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglThresholdOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglEqualizeOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglBrightnessOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglEqualizeOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglContrastOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglPosterizeOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglInvertOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglSaturationOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorConvertOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorConvertOpToRgb&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorConvertOpToCmyk&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorConvertOpToHsv&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorConvertOpToCiexyz&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglChannelSelect
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglMultiSrcOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglAddOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglSubtractOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglMultOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglMinOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglMaxOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglDivOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglAbsDiffOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglCompositeOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglGeometricOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglAffineTransformOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglWarpOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglStatisticsOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglHistogramOp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglMeanOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglPassthroughOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglTranslateOp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglRoiOp

GeglIterator
&nbsp;&nbsp;&nbsp; GeglImageBufferIterator
&nbsp;&nbsp;&nbsp; GeglConstantImageIterator
&nbsp;&nbsp;&nbsp; GeglTmpIterator</b></pre>

<div 
CLASS="SECT1"
>
<div 
CLASS="FORMALPARA"
>
<div CLASS="SECT1">
<hr></div>
</div>
</div>

<h3>
Similarities between gegl++ and SGI's ImageVision Library</h3>

<ul>
<li>
Image Operators may be used interchangably with ImageBuffers.</li>

<li>
Complete trees of operations may be created by passing one operator as
input into another operator.</li>

<li>
The results of one filter may be passes as an input to another.</li>

<li>
No destination Image is specified until the call to copy_image (or similar
function)</li>

<li>
Processing is demand driven.</li>
</ul>

<h3>
Ideas we can borrow from ImageVision</h3>

<ul>
<li>
The Region Of Interest is just another Operator</li>

<li>
Automatic conversion of mismatched colormodels</li>

<li>
The ability to reconfigure an operator chain via a set_input method</li>
</ul>

<hr>
<div 
CLASS="SECT1"
>&nbsp;
<h1 CLASS="SECT1">
<a NAME="References"></a><font size=+2>References</font></h1>

<ul>
<li>
<a href="http://techpubs.sgi.com/library/dynaweb_bin/ebt-bin/0650/nph-infosrch.cgi/infosrchtpl/SGI_Developer/IL_PG/@InfoSearch__BookTextView/44">SGI
Image Vision Library </a>.</li>

<li>
<a href="http://www.ddj.com/articles/1997/9707/9707b/9707b.html">A Memory-Constrained
Image Processing Architecture</a></li>
</ul>
</div>
</div>

</body>
</html>
