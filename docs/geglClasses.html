<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (X11; U; Linux 2.2.16-22 i686) [Netscape]">
   <title>Gegl Classes</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#840084" alink="#0000FF">

<div 
CLASS="ARTICLE"
>
<div 
CLASS="TITLEPAGE"
>
<h1 CLASS="TITLE">
<font size=+2>Gegl Classes</font></h1>

<h3 CLASS="AUTHOR">
<font size=+0>Calvin Williamson</font></h3>

<div 
CLASS="AFFILIATION"
>
<div 
CLASS="ADDRESS"
>
<div CLASS="ADDRESS">calvinw@mindspring.com</div>
</div>
</div>

<div CLASS="COPYRIGHT">&nbsp;</div>

<div 
CLASS="ABSTRACT"
>This document describes basic architecture for
an image processing library (<b>gegl</b>) built using Gtk/GObjects.&nbsp;
This library is intended to cover basic image operations for image editing
applications (like gimp).&nbsp; It assumes a Gtk/GObject inheritance model.
Currently gegl uses the Gtk Object Builder (gob) for generating GtkObjects.&nbsp;
Feedback is welcome. (gegldev@gegl.org mailing list). Others involved with
this page are Manish Singh, Jay Cox, and Caroline Dahlloff.</div>

<hr></div>

<div 
CLASS="TOC"
>
<dl 
>
<dt>
These classes currently have implementations in gegl:</dt>

<br><b><tt><a href="#GeglObject">GeglObject</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglNode">GeglNode</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglImage">GeglImage</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#GeglImageBuffer">GeglImageBuffer</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#GeglOp">GeglOp</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglPointOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglSingleSrcOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglFillOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglPrintOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglPremultOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglUnpremultOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorConvertOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorConvertToRgbOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorConvertToGrayOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglCopyOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglCopyChanOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglDualSrcOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglAddOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglDarkOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglDiffOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglLightOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglMaxOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglMinOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglMultOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglScreenOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglSubtractOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglCompositeOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglCompositePremultOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglColor">GeglColor</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglColorModel">GeglColorModel</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelRgbU8</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelRgbU16</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelRgbFloat</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelGray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelGrayU8</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelGrayU16</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GeglColorModelGrayFloat</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglImageManager">GeglImageManager</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglTileImageManagger</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglTile">GeglTile</a></tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglTileIterator</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglCache</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; <a href="#GeglDataBuffer">GeglDataBuffer</a></tt></b>
<br>&nbsp;
<p>
<hr><a NAME="GeglObject"></a><b><font size=+2>GeglObject</font></b>
<p>This is the base class for gegl. It keeps track of some high level gegl
info,&nbsp; and passes some calls on to Gtk/GObject. It has some reference
counting debugging functions similar to those in Gtk/GObject. All gegl
classes extend from this class.
<p>
<hr><a NAME="GeglNode"></a><b><font size=+2>GeglNode</font></b></dl>
</div>

<div 
CLASS="SECT1"
>This is the basic graph node class for gegl. Since
we want graphs to be able to share nodes, image graphs in gegl are directed
acyclic graphs, with inputs (children) and outputs (parents).&nbsp; If
nodes of an image graph are all distinct, the graph is a simple tree. Leaf
nodes have no inputs (children) and root nodes have no outputs (parents).&nbsp;
Shared nodes have multiple parents. Normal Gtk/GObject reference counting
is used to keep track of references to nodes.
<p>The Node class manages adding and removing parents and children .&nbsp;
It also has methods for traversing image graphs (breadth-first, depth-first),&nbsp;
detecting cycles in graphs and topological sorting. Freeing a root node
will free nodes that descend from the root when there are no other objects
holding references to these nodes. When a node descends from more than
one root (ie its part of two or more image graphs) it wont be deleted when
a graph is deleted since its reference count will not be zero.
<p>Heres a simple example of an image graph for Comp(Blur(A), Mult(A,B))
:
<p><img SRC="images/chain.png" NOSAVE height=139 width=118>
<p>Here Comp (eg composite over) is the root node, A and B<b><tt> </tt></b>are
ImageBuffer leaf nodes, and Blur, Mult are nodes with both children and
parent(s). A is shared by the Blur<tt> </tt>and mult<b><tt>.</tt></b>
<br>&nbsp;</div>

<div 
CLASS="SECT1"
>
<div 
CLASS="SECT2"
>
<hr><a NAME="GeglImage"></a><font size=+2><b>GeglImag</b>e</font>
<p>This class is the main base class for Ops and ImageBuffers.&nbsp; Common
features of ops and image buffers are stored here.&nbsp; Images have the
ability to "produce" outputs by operating on inputs and and placing the
result in some buffer.&nbsp; Ops "produce" their output as a result of
performing an image operation on inputs.&nbsp; ImageBuffers&nbsp; "produce"
their output by just returning their normal image data as output.
<p>The most important routine in Image is get_pixels, which is the routine&nbsp;
which asks an Image to produce the output from its inputs, possibly placing
the result in a passed destination buffer. get_pixels is also passed a
region of interest (roi), which restricts image processing to an area.
Calling get_pixels on the root of an image graph will result in processing
the entire graph (in depth-first, or some other topological sort order).
Images are processed from the leaves of the graph towards the root, with
each node waiting until inputs are computed before computing its output.&nbsp;
Once the inputs are finished the node performs its operation and places
its result in a data buffer.
<p>ImageBuffers are a special kind of Image. They have no inputs, and so
are leaf nodes in image graphs. Ops are typically non-leaf nodes (but there
are some Ops without inputs)&nbsp; and have one or more inputs.
<p>The Image class also keeps information that makes image calculations
more efficient. Domains of definitions (called have_rects) and regions
of interest (called need_rects) are kept in this class. have_rects are
defined for leaves and are passed towards the root, and need_rects are
passed from the root towards the leaves. (See Shantzis for an explanation
of these terms). In compiler speak, have_rects are synthesized attributes,
and need_rects are inherited attributes.
<p>Heres an example of setting up an operation (mult) and calling get_pixels
:
<p><b><tt>&nbsp;&nbsp;&nbsp; GeglRect roi;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; /* Get three ImageBuffers to use */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglImage *A = GEGL_IMAGE(gegl_image_buffer_new(color_model,w,h));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglImage *B = GEGL_IMAGE(gegl_image_buffer_new(color_model,w,h));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglImage *C = GEGL_IMAGE(gegl_image_buffer_new(color_model,w,h));</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Set up</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; B</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglImage * op = GEGL_IMAGE(gegl_mult_op_new
(A,B));</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Call get_pixels to do the operation */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_rect_set (&amp;roi, 0,0,w,h);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_image_get_pixels (op, C, &amp;roi);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; gegl_object_unref (GEGL_OBJECT(op));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_object_unref (GEGL_OBJECT(A));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gegl_object_unref (GEGL_OBJECT(B));</tt></b>
<p>
<hr><a NAME="GeglImageManager"></a><b><font size=+2>GeglImageManager</font></b>
<p>This class handles details of computing the image graph. When Image's
get_pixels is called, the Image retrieves the singleton ImageManager instance
and calls the ImageManager get_pixels passing itself along as the root
of the image graph. The ImageManager sets up the graph for traversal, fetches
image data for each Op to use, and takes care of storing the results again
somewhere once the Ops are finished. Separating the details of the graph
traversal and data management from the Op's image processing lets us extend
both parts. We can subclass ImageManager to provide different memory management
schemes or arrange for data to be delivered to the Ops in different ways.
For example, a TileImageManager would present requests to the Image in
pages or Tiles of a certain size.
<p>The ImageManager decides how to traverse the graph, and also if any
preliminary passes over the graph are necessary.&nbsp; For example the
TileImageManager computes the region of interest (or need_rect) and domains
of definition (have_rects) on nodes in preliminary breadth-first and depth-first
traversals. Also ColorModels and data types are derived on Images which
do not have these explicitly set. Eventually the ImageManager calls all
the nodes in the image graph (in Image's prepare ,apply, and finish routines)
and passes image data for use as output and inputs. Finally after an operation
for a node is complete the ImageManager decides what to do with the output.
For example it could cache it in memory or swap it to disk.
<p>Below is a picture of the Image and ImageManager classes. The design
of the ImageManager is intended to follow the Bridge Pattern.(GoF Design
Patterns)
<p><img SRC="images/image_to_image_manager_bridge.png" NOSAVE height=347 width=770>
<br>&nbsp;
<p>The Image's prepare, apply, and finish routines all take a GList of
ImageRequests. This list of ImageRequests tells the Image which areas on
the inputs and output it will be processing and also which data buffers
to use.&nbsp;&nbsp; The output is given first in the list, followed by
any inputs. Each ImageRequest is made up of a region to use (Area) together
with some image data (Tile) . The Tile corresponds to an area of image
space and Area is the subportion of that Tile to use or process during
the operation. Tiles used here are just thought of as "chunks of image
data", and may be of any size. They might correspond to what is usually
called "pages" or they might be the entire data of the Image. It depends
on the way the ImageManager in question organizes things.
<p>Here is a picture of an ImageRequest:
<p><img SRC="images/image_request.png" NOSAVE height=247 width=400>
<p>Note that Op nodes may receive ImageRequests that correspond to any
area of its image space, and do not have an intrinsic width and height.
So it is legal to ask an Op to compute its result anywhere in the plane.
ImageBuffers, which correspond more to in-memory representations of image
files, do have a width and height.&nbsp; Of course if the area you request
is outside of the have_rects (domain of definitions) of the inputs to the
Op then you will likely just get a zero-valued output.
<p>
<hr>
<br><a NAME="GeglOp"></a><b><font size=+2>GeglOp</font></b>
<br>&nbsp;</div>

<div CLASS="SECT1">This is the fundamental class for image operations.
Specific image operations all inherit from Op.&nbsp; Subclasses override
Image's apply routine and this is the actual routine that does image processing
and produces an output.&nbsp;&nbsp; Most subclasses of Op implement an
initialization&nbsp; routine (prepare) for setting up details of the operaton
based on parameters and inputs. For example subclasses of PointOp set up
a function pointer to be called on individual scanlines. These scanline
routines are then called from PointOp's implementation of apply.
<p>The Ops are divided into four main subclasses.&nbsp; These classes arise
from the way operators compute their outputs.
<ul>
<li>
PointOps are point processes. For these, the output pixel at (x,y) depends
only on source input(s) at (x,y) .</li>

<li>
AreaOps are area operations. The result output (x,y) for these is determined
by a fixed size area around the (x,y) of the sources. (convolutions, kernel
operations).</li>

<li>
GeometricOps determine values at (x,y) based on some geometric transform
or warp of inputs.</li>

<li>
StatisticsOps collect information about the image (histograms, means, etc).</li>
</ul>
As mentioned above, PointOp implements an apply that is called for each
Op that inherits from PointOp. The apply is passed a GList of ImageRequests
as discussed in the section on the ImageManager . PointOp then creates
TileIterators for each of the Tiles and Areas in the requests list. A TileIterator
provides a way to iterate over scanlines of a subportion of a Tile.&nbsp;
The PointOp updates the TileIterators and calls the installed scanline
function of the subclass for each scanline returned from the the iterator.
<p>Here's the implementation of apply in PointOp:
<p><b><tt>&nbsp; override (Gegl:Image)</tt></b>
<br><b><tt>&nbsp; void</tt></b>
<br><b><tt>&nbsp; apply(GeglImage *self_image,</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GList *requests)</tt></b>
<br><b><tt>&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglImageRequest * request;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gint i,j;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gint width, height;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglPointOp *self =&nbsp; GEGL_POINT_OP(self_image);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglPointOpClass *self_class =</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GEGL_POINT_OP_CLASS
(GTK_OBJECT(self_image)->klass);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglNode *self_node = GEGL_NODE(self_image);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gint num_inputs = gegl_node_num_inputs(self_node);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglTileIterator **iters = g_new (GeglTileIterator*,
num_inputs+1);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Get tile iterators for dest and sources.
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; num_inputs+1; i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request = (GeglImageRequest*)g_list_nth_data(requests,i);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Get the tile,
if it is not NULL */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(request->tile)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
iters[i] = gegl_tile_iterator_new (request->tile, &amp;request->rect);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gegl_tile_iterator_first (iters[i]);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
iters[i] = NULL;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Get the height and width of dest rect we
want to process */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; request = (GeglImageRequest*)g_list_nth_data(requests,0);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; width = request->rect.w;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; height = request->rect.h;</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Now iterate over the scanlines in the dest.
*/</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; for(j=0; j &lt; height; j++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Call the subclass
scanline func. */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (self_class->scanline_func)(self,
iters, width);</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Advance all the
scanlines. */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt;
num_inputs+1; i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if(iters[i])</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gegl_tile_iterator_next(iters[i]);</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Free the iterators */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; num_inputs+1; i++)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iters[i])</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gegl_object_unref
(GEGL_OBJECT (iters[i]));</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></b>
<p><b><tt>&nbsp;&nbsp;&nbsp; /* Free the array of iterator pointers */</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; g_free (iters);</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<p>The final code for implementations of specific image operators (eg in
scanline_funcs) may be autogenerated by the code generator gil&nbsp; (currently
codegen) based on the generic description of the algorithm,&nbsp; the color
models, and the data types of the inputs and outputs. It should be possible
to allow for "specialized" data types/color model algorithms&nbsp; that
are not autogenerated in cases where finer tuning over optimization is
desired, or where autogeneration is just impossible (like LUT operations
on small bitdepth channels vs floating point channels)
<p>ColorConvertOp is the base class for color model conversions. Every
ColorConvertOp is a single source op that converts from the color model
of the input source to the color model of the output buffer. Specific ColorConvertOps
query the color model of the output for a converter function that can convert
from the color model of the source to the color model of the output. When
no converter is found, then a default conversion from the source to CIE_XYZ
and from CIE_XYZ to the output color model is used.&nbsp; The actual color
conversion routines are located in the ColorModel classes. When inputs
and outputs have color models that are different, the ImageManager will
automatically inserts whatever ColorConvertOps are necessary to bring inputs
and their color models into sync with the output color model.
<p>
<hr><a NAME="GeglImageBuffer"></a><b><font size=+2>GeglImageBuffer</font></b>
<br>&nbsp;</div>
This object describes what is usually thought of as normal image data.&nbsp;
ImageBuffer is the basic writable image data object. They occur as leaf
nodes for image graphs and are used as inputs for Ops.&nbsp; An ImageBuffer
sets its ColorModel when it is created and has a width and height.&nbsp;
ImageBuffer doesnt actually have an operation to perform during get_pixels,
its output is basically just itself.&nbsp; ImageBuffers may be passed to
any get_pixels routine as the destination buffer for an&nbsp; Op. This
is how ImageBuffers are written to.&nbsp; Since ImageBuffers have a width
and height, this determines their domain of definition (have_rects).&nbsp;
During the evaluation of an image graph, these have_rects are propagated
back up the graph towards the root.&nbsp; Depending on the ImageManager,
image data for an ImageBuffer may be stored in different ways. This is
left up to the ImageManager implementation. TileImageManager stores an
ImageBuffer in "pages" or Tiles, which may be swapped out or cached.
<div 
CLASS="SECT1"
>
<div CLASS="SECT1">
<div CLASS="SECT1">
<div CLASS="SECT1">&nbsp;</div>

<hr>
<h1 CLASS="SECT1">
<a NAME="GeglTile"></a><font size=+2>GeglTile</font></h1>

<div CLASS="SECT1">This object describes a chunk of image data that corresponds
to a portion of image space. It represents image data for an Op or ImageBuffer.
Tiles have ColorModels and pointers to DataBuffers. They return pointers
to the underlying data and provide (through TileIterators) different ways
to traverse the data.&nbsp; The number of banks a Tile's DataBuffer has
depends on the type of Tile it is.&nbsp; Packed data Tiles will have just
a DataBuffer with one bank, while separated channel Tiles may have a DataBuffer
with banks for each channel.&nbsp; Tiles are the basic image data structure
the ImageManager passes back to Ops in its prepare, apply, and finish routines.
<p>
<hr>
<h1 CLASS="SECT1">
<a NAME="GeglDataBuffer"></a><font size=+2>GeglDataBuffer</font></h1>

<div CLASS="SECT1">DataBuffers hold an array of pointers to data banks.&nbsp;
Each bank of a DataBuffer has a size in bytes. The number of banks is determined
by the Tile that has the DataBuffer. The DataBuffer has no knowledge of
the type of data in the buffer.&nbsp; An ImageManager that uses swapping
can transfer data from a DataBuffer to secondary storage.&nbsp;&nbsp;</div>

<div CLASS="SECT1">&nbsp;
<br>
<hr>
<h1 CLASS="SECT1">
<a NAME="GeglColor"></a><font size=+2>GeglColor</font></h1>

<div CLASS="SECT1">The Color object is designed to hold single pixel color
values. It is used for things like the current foreground or background
color, and also for color constants like WHITE, BLACK, RED, etc.&nbsp;
It is left to the individual ColorModels to determine what each of these
constants means in a particular case. Color is generic enough to handle
any channel data type (8bit, 16bit, float).&nbsp; Colors have pointers
to ColorModels that describe the interpretation of the components.&nbsp;
They also have a pointer to an array of channel values that represent the
components for the color value. Colors are for operations that need a small
number of colors (like for a fill) to specify some color related action.
For large numbers of colors, use an actual ImageBuffer with an appropriate
color model and data type, etc.
<p>Heres the Color object:
<p><b><tt>typedef union</tt></b>
<br><b><tt>{</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; guint8 u8;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; guint16 u16;</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; gfloat f;</tt></b>
<br><b><tt>}GeglChannelValue;</tt></b>
<p><b><tt>class Gegl:Color from Gegl:Object {</tt></b>
<p><b><tt>&nbsp; private GeglColorModel *color_model;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* The color model */</tt></b>
<br><b><tt>&nbsp; private GeglChannelValue *channel_values;&nbsp;&nbsp;&nbsp;&nbsp;
/* components */</tt></b>
<br><b><tt>&nbsp; private gint num_channels;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* number of channels*/</tt></b>
<br><b><tt>}</tt></b></div>
</div>

<hr></div>
</div>
</div>
</div>

<h1 CLASS="SECT1">
<a NAME="GeglColorModel"></a><font size=+2>GeglColorModel</font></h1>
ColorModel and its subclasses describe the different color image data types.
ColorModels have a ColorSpace, a ChannelDataType, and fields that describe
the nunber of channels, bytes per channel, names of channels,&nbsp; presence
of alpha channels, and color conversion routines.
<p>The ColorSpace corresponds to spaces like RGB, GRAY, CMYK, INDEXED,
CIE_XYZ, CIE_LAB,&nbsp; sRGB, HSV etc.&nbsp; The data type of a color model
corresponds to channel bitdepth.&nbsp; Color models can be defined in terms
of ICC profiles, and corresponding subclasses of&nbsp; ColorModel may have
ICC profile information where appropriate.&nbsp; The CIE_XYZ based color
model is used as a profile connection space, and color models must implement
mappings to and from this color model.
<p>Corresponding to concrete subclasses of ColorModel&nbsp; (eg ColorModelRgb)
are matching ColorConvertOps (eg ColorConvertToRgbOp) that handle the details
of color conversion of images from any source color model to the specified
one. Conversions between images whose color models are the same except
for the channel data type (ie conversions between different bit-depths)
are also handled by this color conversion operator. (eg conversion from
rgb 8bit to rgb float)
<h4>
examples:</h4>
Part of the (only partially implemented) color model tree:
<p><b><tt>GeglColorModel</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelIndexed</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelIndexedU8</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelGray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8Gray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU16Gray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelFloatGray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8Rgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU16Rgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelFloatRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelCmyk</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8Cmyk</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU16Cmyk</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelCieXyz</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8CieXyz</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU16CieXyz</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelsRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8sRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelHsv</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelU8Hsv</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorModelMultiChannel</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeglColorModelFloatMultiChannel</tt></b>
<p>The matching Color conversion operators:
<p><b><tt>GeglColorConvertOp</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToIndexed</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToGray</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToCmyk</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToCieXyz</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpTosRgb</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp; GeglColorConvertOpToHsv</tt></b></div>

<div 
CLASS="SECT1"
>
<div CLASS="SECT1">&nbsp;</div>
</div>

<div 
CLASS="SECT1"
>
<div 
CLASS="FORMALPARA"
>
<div CLASS="SECT1">
<hr></div>
</div>
</div>

<div 
CLASS="SECT1"
>
<div 
CLASS="TOC"
>
<dl 
>
<h1>
<a NAME="BlendOps"></a><b><font size=+2>Blend ops for Gegl</font></b></h1>
</dl>
</div>

<div 
CLASS="SECT1"
>Suppose we have three images and some op and we wish
to find <b><tt>C = B op A</tt></b>.
<p>The basic formula for Blend modes (including Porter-Duff compositing)
are as follows
<p>Let the images be given by <b><tt>(A,aA) (B,aB) (C,aC) </tt></b>all
premultiplied. Then:
<p><b><tt>aC * C = (1-aB) * aA * A + (1-aA) * aB * B + aA * aB * f(A,B)</tt></b>
<br><b><tt>aC =&nbsp; aA + aB - aA * aB</tt></b>
<p><b><tt>Mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(A,B)</tt></b>
<p><b><tt>1)Normal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B</tt></b>
<br><b><tt>2)Multiply&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A*B</tt></b>
<br><b><tt>3)Screen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1-(1-A)*(1-B)</tt></b>
<br><b><tt>4)Overlay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2*A*B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A&lt;.5</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1-2*(1-A)*(1-B)&nbsp;&nbsp;&nbsp; A>=.5</tt></b>
<br><b><tt>5)HardLight&nbsp;&nbsp;&nbsp;&nbsp; 2*A*B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
B&lt;.5</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1-2*(1-A)*(1-B)&nbsp;&nbsp;&nbsp; B>=.5</tt></b>
<br><b><tt>6)SoftLight&nbsp;&nbsp;&nbsp;&nbsp; 2*remap(A,.25,.75)*B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
B&lt;.5</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1-2*(1-remap(A,.25,.75))(1-B)&nbsp;&nbsp; B>=.5</tt></b>
<br><b><tt>7)ColorDodge&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A=0</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A>=(1-B)</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A/(1-B)</tt></b>
<br><b><tt>8)ColorBurn&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A=0</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1-A)>=B</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 - (1-A)/B</tt></b>
<br><b><tt>9)Darken&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min(A,B)</tt></b>
<br><b><tt>10)Lighten&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max(A,B)</tt></b>
<br><b><tt>11)Difference&nbsp;&nbsp; |A-B|</tt></b>
<p>Some of these might not be quite right (eg SoftLight). Compare versions
from recent Ghostscript cvs <a href="http://cvs.sourceforge.net/cgi-bin/cvsweb.cgi/gs/src/gxblend.c?rev=1.2&content-type=text/x-cvsweb-markup&cvsroot=ghostscript">here.
</a>Also
compare the descriptions in <a href="http://partners.adobe.com/asn/developer/technotes/acrobatpdf.html">Adobe
PDF&nbsp; spec</a>, and the <a href="http://www.w3.org/TR/SVG/filters.html#feBlend">SVG
spec</a> as well.</div>

<h1 CLASS="SECT1">
<a NAME="References"></a><font size=+2>References</font></h1>

<ul 
><a href="http://techpubs.sgi.com/library/dynaweb_bin/ebt-bin/0650/nph-infosrch.cgi/infosrchtpl/SGI_Developer/IL_PG/@InfoSearch__BookTextView/44">SGI
Image Vision Library </a>.
<br><a href="http://java.sun.com/products/java-media/jai/">Java Advanced
Imaging API</a>.
<br><a href="http://dev.acm.org/pubs/citations/proceedings/graph/192161/p147-shantzis/">A
Model for Effecient and Flexible Image Computing</a>
<br><a href="http://www.ddj.com/articles/1997/9707/9707b/9707b.htm">A Memory
Constrained Image Processing Architecture</a>
<p><a href="http://www.5z.com/jirka/gob.html">Gtk+ Object Builder</a></ul>
</div>
</div>

</body>
</html>
