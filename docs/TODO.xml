<!-- This is used to generate the online TODO list for GEGL using
     the script docs/make-todo. Whenever a change to this file is
     committed to CVS,the file is run through make-todo and the online
     version updated. If you modify this file, you should check for
     parse errors by running:

     $ docs/make-todo TODO.xml > /dev/null

     before committing, or you may screw up the online version.--> 
<todo logourl="images/gegl.jpg">
  <title>Gegl Task list</title>
  <section>
    <title>Gegl</title>

    <entry size="medium" status="80%" target="0.0">
      <title>GeglNode</title>
      <description>
        <p>
            This class is to hold the information for a node in an image graph
            dag and will have lists for the input and output nodes.  This class
            will be responsible for keeping track of all the graph related
            things for Nodes (images, ops). It will have lists for the inputs
            and outputs and provide traversals for depth-first, breadth-first,
            and topologically sorting. It will keep track of the reference
            counting (via gtk ref counting) associated with adding inputs and
            outputs to nodes, and check graphs for cycles. This means that it
            will be possible to set up graphs and pass them around and delete
            them by just deleting the root, since ref counting will take care
            of finding and destroying nodes automatically.
        </p>
        <p>
            Most of the above is finished. One outstanding issue is detecting
            cycles. DAGs are okay, and nodes may be shared in the same and
            different graphs, but cycles are not allowed. When a node is added
            to a graph, we need to check for any cycles. 
        </p>
        <p>
            Added a flag (alt_input) to let nodes indicate which of their
            inputs to use if a node is disabled or if a node is not an
            GeglImage node (ie an image producing node). This allows nodes to
            perform other kinds of operations besides image-producing ones.
            Some examples of these would be things like PrintOp, StatisticsOps
            SwitchOp, etc.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>In-place Buffers</title>
      <description>
        <p> 
            A dest ImageBuffer can passed to root of a graph during
            gegl_op_apply.  This buffer should be passed up the graph when
            in-place operations are desired. This is similar to inherited
            attributes when parsing.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>Allow disabling nodes</title>
      <description>
        <p> 
            Allow nodes and part of graphs to be disabled/inactive, but still
            part of the graph. Traversal would just skip these nodes, and any
            data passed from below the node would be pulled through an inactive
            node without affecting it. This would use the alt_input flag in the
            Node class to let nodes specify an input to use instead of them
            when they are disabled.  
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>Fix Add,Mult,etc to commute</title>
      <description>
        <p> 
           Currently A mult B is not the same as B mult A, since we are leaving
           part of the full compositing equation: If (A,aA), (B,aB) (C,aC)
           are three premultiplied images, then
           <ul>
             aC * C = (1-aB)*aA*A + (1-aA)*aB*B + f(A,B)  
           </ul>
           <ul>
             aC = aB + aA - aB*aA                       
           </ul>
           where f(A,B) = A*B for mult. Currently we dont use the first two
           terms of the first equation  correctly.  example:   If aA=1, aB=0,
           then we should get just A, and if aB=1, aA=0, then we should get
           just B. Compare the current MultOp.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>Add Automatic Color/Data Conversions</title>
      <description>
        <p>
            There is some support in gegl-utils.c to figure out what color
            model to use when the color model is "derived" from the inputs, but
            it does not set up any color conversion ops automatically when
            inputs dont match the outputs. This should be handled by the
            ImageManager class during its graph traversal. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>Tests</title>
      <description>
        <p>
            tests/testgeglfile.c is out of date, and doesnt compile with the
            latest updates. testgeglfile should read in tiff images from the
            command line, open them and perform tests similar to
            tests/testgegl.c,. Since testgegl.c is really only suitable for
            testing the ops on real small images (built by hand) and not read
            from files.  testgeglfile should give a workout of the ops on more
            normal size images. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="big" status="30%" target="0.0">
      <title>SwitchOp, RoiOp, other noni-GeglImage ops.</title>
      <description>
        <p> 
           The inheritance for the Op class and subclasses allows ops which do
           not produce an image output, but may perform other kinds of useful
           operations necessarily. These ops can do any kind of operation that
           depend on inputs and can be done in the prepare, process, finish
           routines of the Op class. These non-image producing ops (ones which
               dont write a destination image) should inherit from Op directly,
           while image producers should all inherit from Image now.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="big" status="30%" target="0.0">
      <title> Data Storage Types</title>
      <description>
        <p>
            Gegl will have a standard data storage type. The details of this
            still needs to be determined. It would be best if the choice of
            underlying data storage can be kept as independent as possible of
            the details of the operator algorithms. Of course this is a
            difficult problem, but see the 
            <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">Vigra</a>
            library for some ideas. 
        </p>
        <p>
            There is now a class called GeglDataBuffer which will contain
            "banks" of data. These are used by GeglTile to hold its image data.
            GeglTile represents "chunk of image data", and is the thing
            passed back to the ops by the GeglImageManager. 
        </p>
        <p>
            By altering GeglDataBuffers, GeglTile, GeglTileImageManager (by
                subclassing say) together with appropriate gil code it should
            be possible to support different data types and arrangements of
            data in memory. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="big" status="25%" target="0.0">
      <title>Memory,Cache Manager classes</title>
      <description>
        <p>
            Gegl needs memory management classes in the form of cache with
            swappable pages.  This will mean image data will be requested from
            a cache manager, and we need schemes (ref counting,splay trees) for
            deciding what to swap out. This will need to work with tiles. 
        </p>
        <p>
            There is now GeglImageManager, GeglTileImageManager, GeglCache
            classes. GeglTileImageManager provides a tile based implementation
            of the ImageManager and uses a GeglCache to store the tiles.  The
            GeglCache currently just keeps track of Image and Op data in a hash
            table. There is no disk swapping. We need to add swapping code,
            replacement tile policies, and keep track of cache sizes. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="big" status="30%" target="0.0">
      <title> Tile Classes</title>
      <description>
        <p>
            Tile and tile management classes. Want to allow variable size tiles
            for gegl. 
        </p>
        <p>
            We now have GeglTile and GeglTileImageManager classes. They
            currently only store tiles the size of the the result_rect of an
            ops computation.  So they dont actually implement a tile system
            where regions of an image/op are made up of many small tiles (like
                64x64). This needs to be added to the current
            GeglTileImageManager. 
        </p>
        <p>
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="big" status="0%" target="0.0">
      <title>Multi-Threading Support</title>
      <description>
        <p>
            Basic multi-threading support for image ops, and scheduler/task
            management classes. These should be added in the ImageManager,
            which is the appropriate class for managing these.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="medium" status="0%" target="0.0">
      <title>AreaOp</title>
      <description>
        <p>
            Area operations base class. This class requests contiguous regions
            from the ImageManager for doing area-based operations. The ImageManager
            will need to cobble together tiles if the available tiles dont match
            the requested ones. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="medium" status="0%" target="0.0">
      <title>Iterator Classes </title>
      <description>
        <p>
            The Iterator classes will need to iterate over tiles and images in
            different ways. Right now there is a GeglTileIterator class which
            is basically a scanline iterator over a portion of a tile. The
            TileImageManager will need an ImageIterator that iterates over
            tiles of the image. The next, first, done, for these iterators
            provide the next tile, first tile, etc  
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>


    <entry size="medium" status="0%" target="0.0">
      <title>Additional ColorModels</title>
      <description>
        <p>
            Need to fill out details of more of the color models, and the
            corresponding color conversion ops. Also complete a color model
            "promotion" and conversion scheme for use when doing automatic
            color conversion. ie if inputs to some 2-input op are rgb u8 and
            cmyk u8 then the output is rgb u8.

            Some of this is done. See the compute_derived_color_model routine
            in GeglImage. This uses some "inheritance trees" for color spaces,
            channel data types, etc in gegl-utils.c as well. Look at the routine
            implemented in gegl-op.gob for details.
        </p>
        <ul>
            More color models, and color conversion ops: 
            <li> GeglColorModelIndexed </li>
            <li> GeglColorModelCmyk </li>
            <li> GeglColorModelCieXyz </li>
            <li> GeglColorModelsRgb </li>
            <li> GeglColorModelHsv </li>
            <li> GeglColorModelLab </li>
            <li> GeglColorModelMultiChannel </li>             
        </ul>
        <p>
            Some ICC profile based color models would be nice. This would allow
            adding more detailed color management support. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="small" status="0%" target="0.0">
      <title>Gtk-doc Setup</title>
      <description>
        <p>
            Setup gtk-doc for doing documentation in gegl. This is DocBook style
            documentation.
        </p>
        <p>
            This is started in gegl/docs/reference/gegl. Function arguments and
            comments are extracted from the source code files.  Most private
            routines, though documented in the source files, don't show up in
            the generated html files, since gtk-doc only produces documentation
            for public routines. We could put in args/comments for the
            "private" routines, but it would be nice to fix gtk-doc to also
            generate these. 
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

  </section> <!-- Gegl -->

  <section>
    <title>Gil</title>

    <entry size="medium" status="30%" target="0.0">
      <title>Abstract Syntax Trees for gil</title>
      <description>
        <p>
            We need to extend codegen to create abstract syntax trees, so that
            we can do better code generation, type checking and so on.  See gil
            subdirectory for a simple example.  This will eventually replace
            codegen. The new code generator will be just called "gil" and will
            be something that can be used to do various tasks that depend on
            traversing the gil ast. It will use glib and GNodes for creating
            the asts from lex/yacc, and GHashtables for the symbol table. The
            gil syntax will mostly stay the same, but we get a more powerful
            code generator/language.
        </p>
        <p>
            Currently the example builds asts for simple C-like expressions and
            code blocks.
        </p>
      </description>
      <contact>Calvin Williamson &lt;calvinw@mindspring.com&gt;</contact>
    </entry>

    <entry size="medium" status="0%" target="0.0">
      <title>Gil support for AreaOps</title>
      <description>
        <p>
           Gil will need to understand how to get rowstrides and access pixels.
           This involves making sure gil can interpret gil built-in dY function
           calls.
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

    <entry size="medium" status="0%" target="0.0">
      <title>Gil Channels Support</title>
      <description>
        <p>
           Gil currently has no way to reference individual color channnels ie
           red, green, blue for rgb color model. This is needed for Ops that
           will write gil code and will want a standard way to refer to the
           color channels.  
        </p>
      </description>
      <contact>&lt;gegldev@gegl.org&gt;</contact>
    </entry>

  </section> <!-- Gil -->

  <section>
    <title>Opgen</title>

    <entry size="medium" status="0%" target="0.0">
      <title>Opgen Issues</title>
      <description>
        <p>
          Opgen generates gegl-operators from XML files.
        </p>
        <ul>
            <li>
              Write documentation for opgen.
            </li>
            <li>
              Add license entities for gpl, lgpl, bsd, etc?
            </li>
            <li>
              Figure out how we tell GIL to generate multiple versions of the
              point processing functions
            </li>
            <li>
              Figure out how we code with specific colors (ie red, green, blue, cyan...)
            </li>
            <li>
              Automatic code indentation?
            </li>
        </ul>
      </description>
      <contact>Jay Cox &lt;jaycox@gimp.org&gt;</contact>
    </entry>

  </section> <!-- Opgen -->
</todo>
