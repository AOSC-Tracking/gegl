1. Write your first program using frequency-domain operations

The "dft-forward" operation transforms the time-domain image into frenquency-domain, 
and the "dft-backward" do the reverse process. The "dft" here is short for discrete fourier
transfrom. One image which is processed by "dft-forward" operation and then processed by 
"dft-backward" operation will back to the same one as original without any lost. 
In the following example, first two GeglNode objects are generated, which are "dft-forward" 
opeation and "dft-backward" operation respectively. Then, link them and process. After this 
process, the original image goes through "dft-forward" to "dft-backward" and then back to 
the original one.

/****************code example begin****************/
{
  gchar    *file_name = "surfer.png";
  GeglNode *gegl = gegl_node_new();
  GeglNode *image = gegl_node_new_child(gegl,
                                        "operation",
                                        "load",
                                        "path",
                                        file_name,
                                        NULL);
  GeglNode *dft = gegl_node_new_child(gegl, "operation", "dft-forward", NULL);
  GeglNode *idft = gegl_node_new_child(gegl, "operation", "dft-backward", NULL);
  GeglNode *pre = gegl_node_new_child(gegl, "operation",
                                      "preview-frequency", NULL);
  GeglNode *save = gegl_node_new_child(gegl,
                                       "operation",
                                       "png-save",
                                       "path",
                                       "test_result.png",
                                       NULL);
  gegl_node_link_many(image, dft, idft, save, NULL);
  gegl_node_process(save);
}
/****************code example end ****************/

You can preview the frequency domain image by just replace the "idft" with "pre"
in the statement "gegl_node_link_many(image,dft,idft,save,NULL)". 

2. Use Gaussian-Lowpass filter to blur an image.

Generally speaking, the digital signal processing in frequency domain follows 
this pattern:
.-----.	     .---.     .------.     .----.     .-----.
|image| -->  |dft| --> |filter| --> |idft| --> |image|
.-----.      .---.     .------.     .----.     .-----.

Take gaussian-lowpass filter as an example:

There are two parameters of this operation. "cutoff" refers to the cut off 
frequency. The higher cutoff frequency, the deutlicher the processed image. 
The "flag" parameter is a mask which are used to indicate which component of 
"RGBA" to be processed. If only R component is selected to be processed, 
flag should be set to 1000b, and G should be 100b, B should be 10b, A should 
be 1b, etc. You can combine them by an OR operation. 
For example flag=14=1110b=1000b|100b|10b means RGB components but A componet are 
not selected to be processed.

/****************code example begin****************/
{
  gchar    *file_name = "surfer.png";
  GeglNode *gegl = gegl_node_new();
  GeglNode *image = gegl_node_new_child(gegl,
                                        "operation",
                                        "load",
                                        "path",
                                        file_name,
                                        NULL);
  GeglNode *dft = gegl_node_new_child(gegl, "operation", "dft-forward", NULL);
  GeglNode *idft = gegl_node_new_child(gegl,"operation","dft-backward", NULL);
  GeglNode *glpf_filter = gegl_node_new_child(gegl,"operation",
                                              "lowpass-gaussian",
                                              "cutoff",30,"flag",15,NULL);
  GeglNode *save = gegl_node_new_child(gegl,
                                       "operation",
                                       "png-save",
                                       "path",
                                       "test_result.png",
                                       NULL);
  gegl_node_link_many(image,dft,glpf_filter,idft,save,NULL);
  gegl_node_process(save);
}
/****************code example end****************/

3. How does the freq-general-filter.c work.
The input of this process have two main parts. One is the frequency-domain image,
the other is the filter. The frequency-domain image should be the output of
"dft-forward" operation and the filter should be provided by the user. In fact, 
any filter is a complex-number gdouble matrix, and any processing in frequncy domain is 
multiplying the matrix on the frequency domain image. The two parameters of the
"freq-general-filter" operation which are named "filter_real" and "filter_imag"
indicates the real and image component of the filter matrix as their name says. 
Because the frequency domain image is center-symmetric, there is no need to store
the whole matrix but only to store the left half. So, the size of the filter matrix 
is (width/2+1) by height, where the "width" is the width of the original image to be 
processed and the "height" refers to the height of the image. What's more, we use one 
dimension to store the (width/2+1) by height matrix. We assume "Filter_log" is the real 
component of the filter in logical and "Filter_phy" is the real component of the filter in 
physical. Obviously, there should be an equation 
Filter_phy[(y)*(width/2+1)+x] == Filter_log[y][x] to convert the 2-dimension matrix in 
logical to the 1-dimension array in physical.
Then, the filter matrix multiply on the frequency-domain image. Because it is useful for 
visualizing a Fourier transform with the zero-frequency component in the middle of the 
spectrum, so the frequency-domain image has been processed in "dft-forward" operation
by moving the zero-frequency to the center of the matrix as the "fftshift" function of
the famous software "matlab" do. So, multiply has to be a little trick. But as for user,
this is no need to care about because all this has been done in the freq_multiply() function.
Then according to the parameter "flag", corresponding component are multiplied by the fitler.


4. Design your own filter.
Although we have provided many filters, but we can not provide all. The 
operation "freq-general-filter" is for those users who want to use their own 
filters. If you need a filter but we did not provide, you could design it by 
yourself following below. 

In fact, any filter is a complex-number matrix, and any processing in frequncy
 domain is multiplying the matrix on the frequency domain image.
The multiply here does not mean matrices multiplying. Take a m*n image for
example, our "multiply" is means:

for x=1..m
 for y=1..n
   /* Note the "*" here refers to complex-number multiply here.*/
   new_image[m][n] = origin_image[m][n]*filter[m][n];  
 end
end

But one important point is that the filter must be symmetric to ensure the the 
reslut after idft is a real-number matrix(it's no sence if a image's pixel is a 
complex-number). 
Because the filter is symmetric, you need not to give the whole matrix. You just
need to give the left half of the filter.
Here is an example of "ideal lowpass filter".
The function of ideal lowpass filter is :
H(u,v)=1 D(u,v)<=cutoff
       0 D(u,v)> cutoff
The D(u,v) means the distance between point(u,v) and the center of the image:
(width/2,height/2),
which can be easily gotten by sqrt((u-width/2)^2+(v-height/2)^2).
Given we are going to process an image whose size is m*n. 
So the filter should be a (m/2+1)*n matrix because of the symmetric. You should
first allocated an gdouble array of (m/2+1)*n size. And we use one-demison
array to store the matrix, so you must do a little transformation: 
filter[y*(m/2+1)+x] = H[y][x];
The following thing is trivial: compute the function value of H(u,v) at every
point. Since the frequency domain image is a matrix of complex number, the
filter should be given as a matrix of complex number two.
Here is the code of a ideal-lowpass processing:
/*********************************code exampel begin**************************/
{
 gdouble *Hr = gnew0(gdouble,(m/2+1)*n); // Hr is the real componet of the filter
 gdouble *Hi = gnew0(gdouble,(m/2+1)*n); // Hi is the image componet of the filter
 
 for(y=0;y<height;y++)
   for(x=0;x<(m/2+1);x++)
    {
         if(((y-height/2+1)*(y-height/2+1)+(x-width/2+1)*(x-width/2+1))<cutoff*cutoff) 
             Hr[y*FFT_HALF(width)+x] = 1;
	     
    } 

  GeglNode *filter = gegl_node_new_child(gegl, "operation",
                                        "freq-general-filter","realH",
                                        Hr, "imagH", Hi,"flag",14, NULL);
  GeglNode *dft = gegl_node_new_child(gegl, "operation", "dft-forward", NULL);
  GeglNode *idft = gegl_node_new_child(gegl,"operation","dft-backward", NULL);
  GeglNode *save = gegl_node_new_child(gegl,
                                       "operation",
                                       "png-save",
                                       "path",
                                       "test_result.png",
                                       NULL);
  gegl_node_link_many(image,dft,glpf_filter,idft,save,NULL);
  gegl_node_process(save);

}
/*********************************code exampel end****************************/
