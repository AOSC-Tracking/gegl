GIMP 2.0 will consist of the following libraries: 
\begin{itemize}
\item {\em gegl} -- Image processing library. 
\item {\em libgimpcore} -- Core code, includes main GIMP objects and classes.  
\item {\em libgimpcoreui} -- Private widgets needed by app, not exported to plugins. 
\item {\em libgimpui} -- Widgets available for both app and plugins. 
\item {\em libgimpwidget} -- Utility widgets used in building the other ui libaries. 
\item {\em libgimpapp} -- Actual GIMP app.
\item {\em libgimpext} -- Communication library between plug-ins and application.
\item {\em libgimpiface} -- Interfaces for libgimpui and libgimpcore.
\item {\em libgimpjunk} -- Various utilities. 
\end{itemize}

\subsection{GEGL}

Pixel manipulation will be done using GEGL (Generic Graphics Library -- Chapter
3). GEGL abstracts the color model and color depth (8 bit, 16 bit, float) and
provides generic data types for channels or colors.  The algorithms implemented
using these abstract types are converted to the actual C code using a
code-generator. That way it's easier to add additional data types and color
models and optimizations.

Chapter
\ref{ch:GEGL} has a more detailed description of this library.

\subsection{GIMP Core and Plugin Interfaces}

Built on top of this, the GIMP core will implement objects like images, tools,
layers, channels, brushes etc. The interfaces of these high level objects will
be defined in the appropriate library, and implementations of these objects
will be provided for use by plug-ins as well. The relevant code to implement
the objects for the plug-in library will be auto-generated from the object
descriptions.  This will give plug-in developers an object-oriented interface
instead of the simple procedural approach GIMP uses now.

This architecture also allows reuse of UI-elements from the core ui libraries
in plug-ins and provides a clean model-view separation. By exporting the
internal object structure to the plug-ins it will become possible to implement
operators, tools or complete layer types as plug-ins. For example one could
create plugin vector tools for vector layers in with this design.

\subsection{Layer Trees}
 
The simple composite of layers into a projection from GIMP 1.x will become with
the help of GEGL, a chain (or tree) of operations, allowing things like effect
and vector layers to be part of the composite as well. 

Each node (comparable to a layer in current gimp) may compute its data
internally as pixels, vectors, text, or whatever is appropriate for that node,
and  just needs to implement a well-defined interface so it can be plugged into
the computation chain. In this way anything that does image processing
can be used as part of the chain: color corrections, blur filters as well as
affine transformations and more complex effects are all viewed in 
the same way.

\subsection{Common Object Resource Broker Architecture}

The communication between the core application and the plug-ins will be done
using CORBA. The interface between the actual objects and the ORB will be
generated using the object descriptions mentioned above. The developer will
only see GTK+-objects and will not have to deal with the shoals of CORBA.  GIMP
2.0 will use a network-transparent client-server system.

\subsection{Multi-threading}

Another highlight will be multi-threading of image processing computations.
This allows complicated composites and projections of the layers to be computed
efficiently. When an update of the projection becomes necessary, the system
locks the necessary resources and gives the operation to the batch-renderer to
run in its own thread. This way the user interface, and object system stays
responsive.

\subsection{The Application}
The GIMP application is a small layer on top of all the libraries and just
holds the libraries together.  This design will make it possible to implement
other applications like video-editors or compositors with the same set of
libraries.

Most of this chapter is taken from http://www.gimp.org/gimpcon/review.html.
 
