GIMP 2.0 will consist of numerous library, making GIMP modular and easy to maintain and add features.   
\begin{itemize}
\item {\em gegl} Will contain all the image procesing operations. This library is discussed in Chapter 3.
\item {\em libgimpcore} Contains all non-UI logic
\item {\em libgimpcoreui} Core UI widget not usable by plug-ins such as canvas widget
\item {\em libgimpwidget} core-independent widget use such as building libgimpui widget
\item {\em libui} UI widget used to build plug-in and application UI
\item {\em libgimpapp} GIMP application kernel
\item {\em libgimpext} Communication library between plug-ins and application
\item {\em libgimpiface} contains the interfaces for libgimpui and libgimpcore
\item {\em libgimpjunk} Various stuff (Junk yoU Need Kommonly)
\end{itemize}

((GIMP 2.0 will consist of a number of libraries providing the different
functionalities of the core, the Portable Database (PDB) interface and
the plug-in communication layer. The actual GIMP application will only
glue this together and provide a nice user interface.))

\subsection{GEGL}

The actual pixel manipulation will be done using GEGL, the GEneral
Graphics Library. GEGL abstracts from the color-space and color depth
(8 bit, 16 bit, float, double) and provides generic data types like
channel or color. The algorithms implemented using these abstract
types are converted to the actual C code using a code-generator. That
way it's easy to add additional data types and optimizations like
support for MMX or AltiVec later without having to hack each and every
operation by hand. Among the libraries being considered for the new
architecture, GEGL is the furthest along the development cycle.
Chapter \ref{ch:GEGL} has been dedicated to a technical description
of this library.

\subsection{Layer Trees}
 
What used to be a simple layer stack in GIMP 1.x, which is combined
using layer modes (Normal, Combine, Difference, ...) will, with the
help of GEGL, become a rendering pipeline which can be thought of as a
tree of layers which is viewed from its root. The nodes of the tree
are operators with an arbitrary number of inputs and outputs. These
inputs and outputs access rectangular regions of pixel-data, the edges
of the tree. Each edge (comparable to the layers we have now) can hold
its data internally as pixels, vectors, text or whatever and only
needs to provide a well-defined interface so it can be plugged into
the rendering pipeline. A similar approach will be used for the
operators: Simple functions like color corrections or blur filters as
well as affine transformations and more complex effects are possible.

\subsection{GIMP Core and Plugin Interfaces}

Build on top of this, the core will implement objects like images,
tools, brushes etc. The interfaces of all these high level objects are
defined in its own library and have different implementations at the
core and the plug-in side. The relevant code to implement the objects
in the plug-in library will be auto-generated from object
descriptions. This will give plug-in developers an object-oriented
interface instead of the simple procedural approach GIMP uses now.


This architecture also allows to reuse UI-elements from the core in
plug-ins and provides a clean model-view separation. By exporting the
internal object structure to the plug-ins it will become possible to
implement operators, tools or complete layer-types as plug-ins. The
design of layers and tools allows to create specific tools for special
layer-types (like for example vector-tools on vector-layers).

\subsection{Common Object Resource Broker Architecture}

The communication between the core application and the plug-ins is
done using CORBA. The interface between the actual objects and the ORB
will be generated using the object descriptions mentioned above. The
developer will only see GTK+-objects and does not have to deal with
the shoals of CORBA. The term plug-in becomes a historical meaning
since GIMP 2.0 will use a network-transparent client-server system.

\subsection{Parallelization}

Another highlight will be the parallelization of the actual computing.
Eventually you will not only want to build up a nice
rendering-pipeline but you want to see the projection (the view on the
root of the tree). Whenever an update of the projection becomes
necessary, the system locks the necessary resources and hands the
operation to the batch-renderer which runs in its own thread. That way
not only the user interface, but the whole object system stays
responsive all the time.

\subsection{The Application}
On top of all this sits the actual GIMP application and holds it all
together.  This design will make it possible to implement different
GIMP interfaces like a video-editing system or to visualize the
rendering pipeline as an edit-able graph as known from scientific
image manipulation.

The planning website is at http://www.gimp.org/gimpcon/review.html.
 
